;                                                    -*- rtl -*-
;; Registers...
;;    d 	Data        Registers
;;    k         r0-r3         Inputs to MULTIPLIER
;;    b         r4-r7            on multi-function insns.
;;    c         r8-r11	      Inputs to ALU on
;;    l         r12-r15          multi-function insns.
;;
;;    f         MRF MRB
;;
;;    w 	DM Index    Registers
;;    x 	DM Modifier Registers
;;    h         DM base     Registers
;;    j         DM length   registers
;;
;;    y 	PM Index    Registers
;;    z 	PM Modifier Registers
;;    a         PM base     registers
;;    e         PM length   registers
;;
;;    u         USTAT1/USTAT2
;;    t         system-regs
;;
;; Memory addressing...
;;    different memory addressing mechanisms:
;;                      pm           dm
;;    i,m               A            Q	post-modify, accept m-regs and 0,1,-1
;;    m,i               B            R  pre-mod, 'm' must be reg only
;;    i,6               C            S
;;    6,i               C            S
;;    32                T            T
;;    32,i              D            U  pre-mod or just dm(reg)/pm(reg)
;;    [0,+-1],i                     
;;    i,[0+-1]
;;
;;    
;; Constants...
;;    G        floating point zero
;;    H        unimplemented floating point constant constant
;;    I        (const_int 1)
;;    J        6-bit  immediate.
;;    K        24-bit immediate.
;;    L        8-bit  immediate.
;;    M        32-bit immediate.
;;    N        (const_int -1)
;;    O        (const_int 0)
;;==============================================
;; Unspec patterns...
;;
;; unspec 0 is scalb
;; unspec 1 is recips
;; unspec 2 is rsqrts
;; unspec_volatile 3 is a doloop
;; unspec_volatile 4 is the end of the doloop.
;; unspec 5 is for testing df
;; unspec 6 is for a fractional normilization
;;==============================================
;;
;; Print_operand codes:
;; 
;; !	-- Delay Branch spec -- stuffs two nops if needed.
;; ?	-- CALL's tail
;; =    -- Use SZ or EQ condition for eq
;; ~    -- Use NOT SZ or NE condition for eq
;; <    -- Use MS or LT for relational
;; >    -- Use NOT MS or GE for relational
;;
;; N    -- nop;nop; if target is not Z3
;;
;; z    -- encode operator from enum rtx_code i.e. ADD -> + MULT -> *
;; m    -- mode for multiply if any.

;; D	-- L register corresponding to the argument.

;; M	-- pm/dm(op) with post-modify allowed
;; Q	-- pm/dm(op) wothout post-modify.

;; b	-- Bottom part of double mode
;; u	-- Upper  part of double mode

;; j	-- condition of the operand ("eq", "gt", etc.) 
;; J	-- inverse condition of the operand ("eq", "gt", etc.) 

;; l	-- label reference
;; s	-- address of the operand

;; D    -- should I paralize the load of lcntr with the do Loop.
;; L    -- encode argument as actual label.
;;
;;==================================================================

;; targets:
;;
;; ADSP21020u
;; ADSP210Z3u
;;

;;; Type mult_fun_2 is for add/subs with r8-11,r12-15 pairs, i.e,
;;; second functions of multi-function

(define_attr "type"
  "compute,comp_alu_fix,comp_alu_float,comp_mult_fix,comp_mult_float,shiftimm,move,dm_move,pm_move,dreg_move,dreg_zero,dreg_one,misc,imm_move,branch,ubranch,call,tablejump,doloop,doloop_jump"
  (const_string "misc"))
;
; I think a note of explanation is in order for the "type" attribute.
; First, these types are currently used only by the parallelizer and delay
; slot filling.

; Second, some types are subtypes of other.  Insns should be classified into the
; smallest possible subtype.
; 
; The general types are compute, shiftimm, move, and misc:
;
; I. Compute -- any type that will fit into the instruction types 1-5,7-9,11
;               this means alu, mult, shifter, or multifunction compute.
;               Insns will be classified as computes if they cannot be parallelized
;               with any other arithmetic operation.					
;    a. comp_alu_fix -- the alu component of a multifunction compute
;                       with proper operation and register choices
;    b. comp_alu_float -- same as compute_alu_fix, but for floating point
;    c. comp_mult_fix -- mult component of a multifunction compute
;                       with proper operation and register choices.
;    c. comp_mult_float -- multiplier component of a multifunction compute, float
;
; II. Shiftimm -- a shift operation with immediate values, type 6.
;
; III. Move -- any operation that can be parallized with a compute (types 1,3-5,7)
;    a. dm_move -- a dm post modified address dreg move (read or write)
;    b. pm_move -- a pm post modified address dreg move (read or write)
;
; 
; IV.  (other types)
;    a. dreg_move -- a move from one dreg to another.  This could be accomplished
;                    with either a pass or a ureg to ureg copy.
;    b. dreg_zero -- a load of a dreg with a zero.  This can either be done
;                    as a dreg=dreg-dreg or as a dreg=zeromreg;
;    c. dreg_one -- this is a load of a dreg with +/-1.  It should be done with
;                    a load from a +/-1 mreg.
;
; V.  Misc -- any immediate move, or miscellaneous instructions or other things
;              thaat don't fall anywhere else
;    a. imm_move -- type 14-17
;    b. branch 
;    c. ubranch - 2 word (or longer) branches
;    d. call
;    e. tablejump
;    f. doloop
;    g. doloop_jump
				       


(define_attr "length" "" (const_int 1))

(define_attr "mode" "SI,SF,VOID,CCSET"
  (const_string "VOID"))

(define_attr "operator" "plus,minus,mac,other"
  (const_string "other"))

(define_attr "cc"
  "clobber,unchanged,sets,compare,copy,shift,mult"
  (cond [(eq_attr "type" "move,pm_move,dm_move,imm_move")    (const_string "copy")
	 (eq_attr "type" "branch,ubranch")		     (const_string "clobber")
	 (eq_attr "type" "shiftimm")			     (const_string "shift")
	 (eq_attr "type" "comp_mult_fix,comp_mult_float")    (const_string "mult")
	 (eq_attr "type" "compute,comp_alu_fix,comp_alu_float")	     (const_string "compare")]
	(const_string "clobber")))

(define_attr "cpu"
  "21020,Z3"
  (const
   (if_then_else (symbol_ref "ADSP210Z3u") 
		 (const_string "Z3")
		 (const_string "21020"))))

;
;  Here we define how to fill delay branch slots. on the 21k
;  We don't allow annulling of anykind. i.e. all delay slots are
;  executed no matter what happens on the jump.
;
(define_delay (eq_attr "type" "branch")
  [(and (eq_attr "type" "!branch,ubranch,call,doloop,doloop_jump")
        (and (eq_attr "length" "1")(not (eq_attr "mode" "CCSET"))))
     (nil) (nil)

   (and (eq_attr "type" "!branch,ubranch,call,doloop,doloop_jump")
        (eq_attr "length" "1"))
     (nil) (nil)])

; per 3.1rel
;(define_delay (and (eq_attr "cpu"  "Z3")
;		   (eq_attr "type" "call"))
;
;  [(and (const_int 0)  ;;; lmg wants nopss.
;        (and (eq_attr "type" "!branch,call,doloop,doloop_jump")
;             (eq_attr "length" "1")));
;
;  (nil) (nil)])
  


;; We'd like to fill the delay slot with instructions of length
;; two, but for some reason adding this breaks ALL delay slots
;;
;(define_delay (eq_attr "type" "branch,ubranch")
;  [(and (eq_attr "type" "!branch,ubranch,call,doloop,doloop_jump")
;        (eq_attr "length" "2"))
;     (nil) (nil)
;  ])
;

;;
;; Define how our functional units interact.
;;

(define_function_unit "mult" 
  1 1
  (eq_attr "type"
	   "comp_alu_fix,comp_mult_fix,comp_mult_float,compute,shiftimm")
  10 4)

(define_function_unit "dmdag" 
  1 1 (eq_attr "type" "dm_move") 10 4)


(define_function_unit "pmdag"
  1 1 (eq_attr "type" "pm_move") 10 4)

(define_function_unit "move"
  1 1 (eq_attr "type" "move") 10 4)

(define_function_unit "imm_move" 
  1 1 (eq_attr "type" "imm_move") 10 4)

(define_function_unit "misc" 
  1 1 (eq_attr "type" "misc") 10 4)


;;; These are not used yet but they will be some day

(define_parallel 
  [(and (eq_attr "type" "comp_mult_float")
	(eq_attr "mode" "SF"))
   (and (and (eq_attr "type" "comp_alu_float")
	     (eq_attr "operator" "plus"))
	(eq_attr "mode" "SF"))
   (and (and (eq_attr "type" "comp_alu_float")
	     (eq_attr "operator" "minus"))
	(eq_attr "mode" "SF"))])

(define_parallel 
  [(and (eq_attr "type" "comp_mult_float")
	(eq_attr "mode" "SF"))
   (and (eq_attr "type" "comp_alu_float")
	(eq_attr "mode" "SF"))])

(define_parallel 
  [(and (and (eq_attr "type" "comp_alu_float")
	     (eq_attr "operator" "plus"))
	(eq_attr "mode" "SF,SI"))
   (and (and (eq_attr "type" "comp_alu_float")
	     (eq_attr "operator" "minus"))
	(eq_attr "mode" "SF,SI"))])

(define_insn ""
  [(unspec_volatile [(match_operand 0 "general_operand" "ri")	;; loop counter
		     (match_operand 1 "" "")	;; start label
		     (match_operand 2 "" "")	;; end label
		     (match_operand 3 "immediate_operand" "i")]	;; depth
		     3)]
   ""
   "*
      if (GET_CODE (PREV_INSN (insn)) != CODE_LABEL)
        {
           rtx pattern = PATTERN (PREV_INSN (insn));
           if (GET_CODE (pattern) != SET
               || XEXP (pattern, 0) != operands[0])
             abort();
        }

      /* I completely disagree with the idea that we delete do-loops!
	 its not right.  I know that its probably okay but there are
	 validation test that check for this. [mmh 3/25/1994] */
      if (empty_doloop_p (insn)) 
         return \"!lcntr = %0%D0 do (pc, 1) until lce; nop; !! Empty loop !! \";
      else
         return \"lcntr = %0%D0 do %2-1 until lce;\";
   "
   [(set_attr "type" "doloop")])


(define_insn ""
  [(set (cc0)
	(unspec_volatile [(match_operand 0 "" "")] 4))]
   "check_doloop_end(insn)"
   "*
	if (tight_doloop_end_p(insn))
	   return \"nop; !! Padded End of Loop\";
	else if (continued_doloop_p(insn))    
	   return \"nop; !! End of Continued Loop\";
	else 
           return \"End of Doloop\";
   ")

;; I (az) don't remember whether the following is actually used,
;; so we emit a dummy insn to see if we ever get it. If we do,
;; g21k will abort.
;;
;; [9/95-APL] There is code in loop.c that depends on
;; whether HAVE_decrement_and_branch_until_zero is #DEFINE'ed.  There doesn't
;; appear to be any "generator" of this pattern, however.

(define_insn "decrement_and_branch_until_zero"
  [(unspec_volatile
    [(match_operand 0 "general_operand" "ri")	;; loop counter
     (match_operand 1 "immediate_operand" "i")]	;; depth
    99)]
  ""
  "*
   abort();
    return \"\";"
  )

(define_expand "movsi"
  [(set (match_operand:SI 0 "general_operand" "")
	(match_operand:SI 1 "general_operand" ""))]
  ""
  "{
     if (GET_CODE(operands[0]) == MEM 
         && (GET_CODE(operands[1]) == MEM || CONSTANT_P (operands[1])))
     {
         if( !reload_in_progress) {
            rtx reg = gen_reg_rtx (SImode);
            emit_insn ( gen_rtx(SET,SImode,reg,operands[1]));
            emit_insn ( gen_rtx(SET,SImode,operands[0],reg));
            DONE;
         }
         else {
           abort();
         }
     }
}")


;;; SImode moves are almost the same as DMmode, but with mult 
;;; moves added.
;;


;;; SImode moves are almost the same as DMmode, but with mult 
;;; moves added.
;;
;; mmh:
;; Well I believe that if this is a move of the form
;; (insn (set:SI (reg:SI x) (mem:SI (post_modify:PM (reg:PM w) ...))))
;; then we should ignore the 8th alternative for register class preferencing.
;;
;; The compiler only ignores the constraint on the first pass.  If the thing really 
;; wanted to be in an DM-ireg then it probably should have been constructed with
;; a movedm insn.
;;
(define_insn ""
  [(set (match_operand:SI 0 "general_operand"
;;;;;;;;   0,1,2,3,4,5,6,  7,  8,  9, 0,  1, 2,  3,   4, 5, 6, 7, 8,  9, 0,         1,    2,     3,      4,  5,  6,  7,  8, 9,0
	 "=d,d,d,d,A,d,Q,dwx,dwx, wx, d,  B, A,CRS, dwx,AB,*Q,*R,AQ,DUT,DT, hj*udwxae,   *t,*dwxyz,hj*udwx,?*f,?*f,  d,?*r,TD,U")
	(match_operand:SI 1 "general_operand" 
	  "O,P,d,A,d,Q,d, RB, wx,d*A,CS,dwx,wx,  d,DUTi, P, P, P, i,  d,wx,hj*udwxaei,dwxyz,     t,   TDUi,  d,  O,?*f,?*r, P,P"))]
   "(GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)"
  "*
{
  switch( which_alternative ) 
    {
     case 0:  return \"%0=0;\";
     case 1:  return \"%0=%P1;\";
     case 7:  return \"%0=%Q1;\";

     case 15: return \"%0=%P1;\";

     case 16:
     case 17: return \"%0=%R1;\";

     case 25: return \"%b0=%1;\";
     case 27: return \"%0=%b1;\";
     case 29: return \"%0=%P1;\";
     case 30: return \"%0=%R1;\";
     default: return \"%0=%1;\";
    }
   RET;
}"
  [(set_attr
    "type"
    "dreg_zero,dreg_one,dreg_move,pm_move,pm_move,dm_move,dm_move,move,move,move,move,move,move,move,imm_move,move,dm_move,move,imm_move,imm_move,imm_move,move,*,*,*,compute,compute,compute,move,imm_move,imm_move")])


(define_insn "movstrictsi"
  [(set (strict_low_part(match_operand:SI
	 0 "general_operand"
;;;;;;;;   0,1,2,3,4,5,  6,  7, 8, 9,  0, 1,  2,   3, 4,  5, 6,     7,  8,9,0
	 "=d,d,d,A,d,Q,dwx,dwx,wx, d,  B, A,CRS,dwx ,AQ,DUT,DT,hjudwx,hju,t,d"))
	(match_operand:SI
	 1 "general_operand" 
	 " O,d,A,d,Q,d, RB,wx ,dA,CS,dwx,wx,  d,DUTi, i,  d,wx,hjudwx,i,  d,t"))]
   ""
  "*
{
  switch( which_alternative ) 
    {
     case 0:  return \"%0=0;\";
     case 1:  return \"%0=%1;\";
     case 6:  return \"%0=%Q1;\";
     default: return \"%0=%1;\";
    }
   RET;
}"
  [(set_attr
    "type"
    "dreg_zero,dreg_move,pm_move,pm_move,dm_move,dm_move,move,move,move,move,move,move,move,imm_move,imm_move,imm_move,imm_move,move,misc,misc,misc")])

(define_expand "reload_indm"
  [(set (match_operand:DM 0 "general_operand" "=r")
	(match_operand:DM 1 "general_operand" "g"))
   (clobber (match_operand:DM 2 "always_true" "=&d"))]
  ""
  "
{
  extern rtx const1_rtx;
  switch(GET_CODE(operands[1]))
    {
    case MEM:
	emit_move_insn (operands[0], operands[1]);
	DONE;

    case POST_INC:
      {
	rtx x=XEXP(operands[1],0);
	emit_move_insn(operands[2],x);
	emit_move_insn(operands[0],operands[2]);
	emit_insn(gen_add2_insn(operands[2],const1_rtx));
	emit_move_insn(x,operands[2]);
	DONE;
      }
    case REG:
    case SUBREG:
	emit_move_insn(operands[2],operands[1]);
	emit_move_insn(operands[0],operands[2]);
	DONE;
    default:
      abort();
    }
}")

(define_expand "reload_inpm"
  [(set (match_operand:PM 0 "datareg_operand" "=r")
	(match_operand:PM 1 "general_operand" "g"))
   (clobber (match_operand:PM 2 "always_true" "=&d"))]
  ""
  "
{
  extern rtx const1_rtx;
  switch(GET_CODE(operands[1]))
    {
    case MEM:
	emit_move_insn (operands[0], operands[1]);
	DONE;
    case POST_INC:
      {
	rtx x=XEXP(operands[1],0);
	emit_move_insn(operands[2],x);
	emit_move_insn (operands[0], operands[2]);
	emit_insn (gen_add2_insn (operands[2], const1_rtx));
	emit_move_insn(x,operands[2]);
	DONE;
      }
    case REG:
    case SUBREG:
	emit_move_insn(operands[2],operands[1]);
	emit_move_insn(operands[0],operands[2]);
	DONE;
    default:
      abort();
    }
}")
	 
(define_expand "reload_insi"
  [(set (match_operand:SI 0 "always_true"      "=d,*f")
	(match_operand:SI 1 "general_operand"   "g,g"))
   (clobber (match_operand:SI 2 "always_true" "=&d,d"))]
  ""
  "
{
  
  extern rtx const1_rtx,constm1_rtx;

  if (post_modified_operand (operands[1], SImode)) {

	emit_move_insn (operands[2],XEXP(operands[1],0));
        emit_move_insn (operands[0],operands[2]);

	switch (GET_CODE (operands[1])) 
	  {
	  case POST_DEC:
	    emit_insn (gen_add2_insn (operands[2],constm1_rtx));
	    break;
	  case POST_INC:
	    emit_insn (gen_add2_insn (operands[2],const1_rtx));
	    break;
	  case POST_MODIFY:
	    if (REG_P (XEXP( operands[1],1))) 
	      {
		if (!IS_DREG (REGNO( XEXP(operands[1],1)))) 
		  {
		    rtx scratch = gen_rtx (REG, SImode, SCRATCH_DREG);
		    emit_move_insn (scratch,XEXP (operands[1],1));
		    emit_insn (gen_add2_insn (operands[2],scratch));
		  }
		else 
		  emit_insn (gen_add2_insn (operands[2],XEXP (operands[1],1)));
	      }
	    else
	      emit_insn (gen_add2_insn (operands[2],XEXP (operands[1],1)));
	    break;
	  default:
	    abort();
	  }
	emit_move_insn (XEXP(operands[1],0),operands[2]);
	DONE;
  } else if (REG_P (operands[0]) && IS_MULT_ACC_REG (REGNO (operands[0]))
	     && datreg_or_mr_or_zero_operand (operands[1], SImode)) {
    emit_move_insn (operands[0], operands[1]);
    DONE;
  } else {
    emit_move_insn (operands[2], operands[1]);
    emit_move_insn (operands[0], operands[2]);
    DONE;
  }

}")
	   
(define_expand "reload_outdm"
 [(set (match_operand: DM 0 "memory_operand" "=m")
       (match_operand: DM 1 "register_operand" "d"))
  (clobber (match_operand: DM 2 "" "=&d"))]
 ""
 "{
    emit_move_insn ( operands[0], operands[1]);
    DONE;
 }"
)

(define_expand "reload_outpm"
 [(set (match_operand: PM 0 "memory_operand" "=m")
       (match_operand: PM 1 "register_operand" "d"))
  (clobber (match_operand: PM 2 "register_operand" "=&d"))]
 ""
 "{
   emit_move_insn ( operands[0], operands[1]);
   DONE;
  }"
)

(define_expand "reload_outsi"
 [(set (match_operand: SI 0 "memory_operand" "=m")
       (match_operand: SI 1 "register_operand" "d"))
  (clobber (match_operand: SI 2 "register_operand" "=&d"))]
 ""
 "{
   emit_move_insn (operands[0], operands[1]);
   DONE;
  }"
)

(define_expand "movdi"
 [(set (match_operand:DI 0 "general_operand" "")
       (match_operand:DI 1 "general_operand" ""))]
  ""
  "
{
  rtx a0,a1,b0,b1;
  int change = 0;
  
  switch (GET_CODE (operands[0]))
    {
    case MEM:
      switch (GET_CODE (XEXP (operands[0], 0)))
	{
	case REG: /* just writing to an address */
	  {
	    rtx arg=XEXP(operands[0],0);
/*	    if(arg==virtual_incoming_args_rtx)
	      {
		arg=gen_reg_rtx(GET_MODE(arg));
		emit_move_insn(arg,XEXP(operands[0],0));
	      }
	    
	    a0 = gen_rtx (MEM, SImode, gen_rtx (POST_INC, GET_MODE (arg), arg));
	    b0 = gen_rtx (MEM, SImode, gen_rtx (POST_DEC, GET_MODE (arg), arg));
*/
	    a0 = gen_rtx (MEM, SImode, arg);
	    b0 = gen_rtx (MEM, SImode, gen_rtx (PLUS, GET_MODE (arg), arg,const1_rtx));
	  }
	  break;
	case POST_INC:
	  a0 = gen_rtx (MEM, SImode,
			gen_rtx (POST_INC, GET_MODE (XEXP (operands[0], 0)),
				 XEXP (XEXP (operands[0], 0), 0)));
	  b0=gen_rtx(MEM,SImode,gen_rtx(POST_INC,GET_MODE(XEXP(operands[0],0)),
					XEXP(XEXP(operands[0],0),0)));
	  break;
	  
	case POST_DEC:
	  a0 = gen_rtx (MEM, SImode,
			gen_rtx (POST_DEC, GET_MODE (XEXP (operands[0], 0)),
				 XEXP (XEXP (operands[0], 0), 0)));
	  b0 = gen_rtx (MEM, SImode,
			gen_rtx (POST_DEC, GET_MODE (XEXP (operands[0], 0)),
				 XEXP (XEXP (operands[0], 0), 0)));
	  change = 1;
	  break;
	  
	case PLUS:
	  {
	    rtx addr = XEXP (operands[0], 0);

	    if ((GET_CODE (XEXP (addr, 0)) == REG 
		 ||GET_CODE (XEXP (addr, 0)) == SUBREG)
		&& GET_CODE (XEXP (addr, 1)) == CONST_INT)
	      {
		a0 = gen_rtx (MEM, SImode, addr);
		b0 = gen_rtx (MEM, SImode,
			      gen_rtx (PLUS, GET_MODE(addr), 
				       XEXP (addr, 0),
				       gen_rtx (CONST_INT, VOIDmode, 
						INTVAL (XEXP (addr, 1))+1)));
		break;
	      }
	    abort();
	  } 
	  
	case SYMBOL_REF:
	  a0 = gen_rtx (MEM, SImode, XEXP (operands[0], 0));
	  b0 = gen_rtx (MEM, SImode, gen_rtx (PLUS, GET_MODE (XEXP (operands[0], 0)),
					      XEXP (operands[0], 0), const1_rtx));
	  break;
	  
	default:
	  abort();
	}
      break;
      
    case REG:
      a0 = gen_rtx (SUBREG, SImode, operands[0], 0);
      b0 = gen_rtx (STRICT_LOW_PART, SImode, gen_rtx (SUBREG, SImode, operands[0], 1));
      break;
      
    case SUBREG:
      a0 = gen_rtx (SUBREG, SImode, XEXP(operands[0],0), 0);
      b0 = gen_rtx (STRICT_LOW_PART, SImode, gen_rtx(SUBREG, SImode, XEXP(operands[0],0), 1));
      break;
      
    default:
      abort();
    }
  
  switch (GET_CODE (operands[1]))
    {
    case MEM:
      switch (GET_CODE (XEXP (operands[1], 0)))
	{
	case REG: /* just writing to an address */
	  if(change)
	    {
	      a1 = gen_rtx (MEM, SImode,
			    gen_rtx (PLUS, GET_MODE (XEXP (operands[1], 0)),
				     XEXP (operands[1], 0),
				     const1_rtx));
	      b1 = gen_rtx (MEM, SImode, XEXP(operands[1],0));
	      change = 0;
	    }
	  else
	    {
	      rtx arg=XEXP(operands[1],0);
/*	      if(arg==virtual_incoming_args_rtx)
		{
		  arg=gen_reg_rtx(GET_MODE(arg));
		  emit_move_insn(arg,XEXP(operands[1],0));
		}
	      
	      a1 = gen_rtx (MEM, SImode, gen_rtx (POST_INC, GET_MODE (arg), arg));
	      b1 = gen_rtx (MEM, SImode, gen_rtx (POST_DEC, GET_MODE (arg), arg));
*/
	    a1 = gen_rtx (MEM, SImode, arg);
	    b1 = gen_rtx (MEM, SImode, gen_rtx (PLUS, GET_MODE (arg), arg,const1_rtx));
	    }
	  break;
	case POST_INC:
	  if(change)
	    {
	      a1 = gen_rtx(MEM,SImode,
			   gen_rtx(PLUS,GET_MODE(XEXP(operands[1],0)),
				   XEXP(XEXP(operands[1],0),0),
				   const1_rtx));
	      b1 = gen_rtx(MEM,SImode,
			   gen_rtx(POST_MODIFY,GET_MODE(XEXP(operands[1],0)),
				   XEXP(XEXP(operands[1],0),0),
				   const2_rtx));
	      change = 0;
	    }
	  else
	    {
	      a1 = gen_rtx (MEM, SImode,
			    gen_rtx (POST_INC, GET_MODE (XEXP (operands[1], 0)),
				     XEXP (XEXP (operands[1], 0), 0)));
	      b1 = gen_rtx (MEM, SImode,
			    gen_rtx (POST_INC, GET_MODE (XEXP (operands[1], 0)),
				     XEXP (XEXP (operands[1], 0), 0)));
	    }
	  break;
	  
	case POST_DEC:
	  if(GET_CODE(b0)==STRICT_LOW_PART)
	    {
	      a1 = gen_rtx(MEM,SImode,
			   gen_rtx(PLUS,GET_MODE(XEXP(operands[1],0)),
				   XEXP(XEXP(operands[1],0),0),
				   const1_rtx));
	      b1 = gen_rtx(MEM,SImode,
			   gen_rtx(POST_MODIFY,GET_MODE(XEXP(operands[1],0)),
				   XEXP(XEXP(operands[1],0),0),
				   gen_rtx(CONST_INT,VOIDmode,-2)));
	    }
	  else
	    {

	      a1 = gen_rtx (MEM, SImode,
			    gen_rtx (POST_DEC, GET_MODE (XEXP (operands[1], 0)),
				     XEXP (XEXP (operands[1], 0), 0)));
	      b1 = gen_rtx (MEM, SImode,
			    gen_rtx (POST_DEC, GET_MODE (XEXP (operands[1], 0)),
				     XEXP (XEXP (operands[1], 0), 0)));
	      change = !change;
	    }
	  break;
	  
	case PLUS:
	  {
	    rtx addr = XEXP (operands[1], 0);
	    if ((GET_CODE (XEXP (addr, 0)) == REG 
                 || GET_CODE (XEXP (addr, 0)) == SUBREG)
		&& GET_CODE (XEXP (addr, 1)) == CONST_INT)
	      {
		a1 = gen_rtx (MEM, SImode, addr);
		b1 = gen_rtx (MEM, SImode,
			      gen_rtx (PLUS, GET_MODE (addr), 
				       XEXP (addr, 0),
				       gen_rtx (CONST_INT, VOIDmode, 
						INTVAL (XEXP (addr, 1))+1)));
		break;
	      }
	    abort();
	  } 
	  
	case SYMBOL_REF:
	  a1 = gen_rtx (MEM, SImode, XEXP (operands[1], 0));
	  b1 = gen_rtx (MEM, SImode,
			gen_rtx (PLUS, GET_MODE (XEXP (operands[1], 0)),
				 XEXP (operands[1], 0),
				 const1_rtx));
	  break;
	  
	default:
	  abort();
	}
      break;
      
    case REG:
      a1 = gen_rtx (SUBREG, SImode, operands[1], 0);
      b1 = gen_rtx (SUBREG, SImode, operands[1], 1);
      break;
      
    case SUBREG:
 /* We might get a subreg in here that attempts a mode conversion between DI
    and DF mode.  For safety, I check that that is the type of mode conversion
    we're doing.  I can't imagine anything else, but...
    */
      if (((GET_MODE(operands[1])==DFmode 
	    && GET_MODE(XEXP(operands[1],0))==DImode)  
	   || (GET_MODE(operands[1])==DImode 
	       && GET_MODE(XEXP(operands[1],0))==DFmode)) 
	  && XEXP(operands[1],1)==0)
	{
	  a1 = gen_rtx(SUBREG,SImode,XEXP(operands[1],0),0);
	  b1 = gen_rtx(SUBREG,SImode,XEXP(operands[1],0),1);
	}
      else if (((GET_MODE (operands[1]) == DFmode 
		 && GET_MODE(XEXP(operands[1],0)) == DCmode)  
		|| (GET_MODE (operands[1]) == DImode
		    && GET_MODE(XEXP(operands[1],0)) == DCmode)))
	{
	  a1 = gen_rtx(SUBREG, SImode, XEXP(operands[1], 0), 0);
	  b1 = gen_rtx(SUBREG, SImode, XEXP(operands[1], 0), 1);
	}
      else
	abort(); 
      break;

    case CONST_DOUBLE:
      if (GET_MODE (operands[1]) == VOIDmode
	  || GET_MODE_CLASS (GET_MODE (operands[1])) == MODE_INT)
	{
	  a1 = GEN_INT (CONST_DOUBLE_HIGH (operands[1]));
	  b1 = GEN_INT (CONST_DOUBLE_LOW (operands[1]));
	}
      else
	{
	  REAL_VALUE_TYPE hostval;
	  long targval[2];
	  REAL_VALUE_FROM_CONST_DOUBLE(hostval,operands[1]);
	  REAL_VALUE_TO_TARGET_DOUBLE(hostval,targval);
	  a1 = gen_rtx (CONST_INT, VOIDmode, targval[0]);
	  b1 = gen_rtx (CONST_INT, VOIDmode, targval[1]);
	}
      break;
      
/*
;;
;;  Sometimes we like to zero out doubles using a const0_rtx load.
;;  For example, if we have a two element array which we need to initialize,
;;  then expand_expr() calls store_constructor() which calls clear_storage(),
;;  and we end up here with const0_rtx.  Other than const0_rtx, we shouldn't
;;  be moving const_int's to double's, right?
;;
;;     No this definitily wrong.
;;
;;	(view-pr \"1739\")
;;*/

    case CONST_INT:
      a1 = const0_rtx;
      b1 = operands[1];
      break;

    default:
      abort();
    }

  if (!change) {
    emit_move_insn (a0,a1);
    emit_move_insn (b0,b1);
  } else {
    emit_move_insn (a0,b1);
    emit_move_insn (b0,a1);
  }

  DONE;

}")
	  

(define_expand "movdf"
 [(set (match_operand:DF 0 "general_operand" "")
       (match_operand:DF 1 "general_operand" ""))]
  ""
  "emit_insn (gen_movdi (operands[0], operands[1])); DONE;")

(define_expand "movcsi"
  [(set (match_operand:CSI 0 "general_operand" "")
	(match_operand:CSI 1 "general_operand" ""))]
  ""
  "emit_insn (gen_movdi (operands[0], operands[1])); DONE;")

(define_expand "movsc"
  [(set (match_operand:SC 0 "general_operand" "")
	(match_operand:SC 1 "general_operand" ""))]
  ""
  "emit_insn (gen_movdi (operands[0], operands[1])); DONE;")

(define_expand "movdc"
  [(set (match_operand:DC 0 "general_operand" "")
	(match_operand:DC 1 "general_operand" ""))]
  ""
  "abort ();")


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;	Basic Arithmetic
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "adddi3"
  [(set (match_operand:DI 0 "register_operand" "=d")
     (plus:DI
       (match_operand:DI 1 "register_operand" "%d")
       (match_operand:DI 2 "register_operand" "d")))]
  ""
  "%b0=%b1+%b2;\;%u0=%u1+%u2+ci;"
  [(set_attr "length" "2")]
)

(define_insn "subdi3"
  [(set (match_operand:DI 0 "register_operand" "=d")
     (minus:DI
       (match_operand:DI 1 "register_operand" "d")
       (match_operand:DI 2 "register_operand" "d")))]

  ""
  "%b0=%b1-%b2;\; %u0=%u1-%u2+ci-1;"
  [(set_attr "length" "2")]
)

(define_expand "anddi3"
  [(set (subreg:SI (match_operand:DI 0 "register_operand" "=d") 0)
	(and:SI (subreg:SI (match_operand:DI 1 "register_operand" "d") 0)
		(subreg:SI (match_operand:DI 2 "register_operand" "d") 0)))
   (set (subreg:SI (match_dup 0) 1)
	(and:SI (subreg:SI (match_dup 1) 1)
		(subreg:SI (match_dup 2) 1)))]
  ""
  "")

(define_expand "iordi3"
  [(set (subreg:SI (match_operand:DI 0 "register_operand" "=d") 0)
	(ior:SI (subreg:SI (match_operand:DI 1 "register_operand" "d") 0)
		(subreg:SI (match_operand:DI 2 "register_operand" "d") 0)))
   (set (subreg:SI (match_dup 0) 1)
	(ior:SI (subreg:SI (match_dup 1) 1)
		(subreg:SI (match_dup 2) 1)))]
  ""
  "")

(define_expand "xordi3"
  [(set (subreg:SI (match_operand:DI 0 "register_operand" "=d") 0)
	(xor:SI (subreg:SI (match_operand:DI 1 "register_operand" "d") 0)
		(subreg:SI (match_operand:DI 2 "register_operand" "d") 0)))
   (set (subreg:SI (match_dup 0) 1)
	(xor:SI (subreg:SI (match_dup 1) 1)
		(subreg:SI (match_dup 2) 1)))]
  ""
  "")

(define_expand "notdi2"
  [(set (subreg:SI (match_operand:DI 0 "register_operand" "=d") 0)
	(not:SI (subreg:SI (match_operand:DI 1 "register_operand" "d") 0)))
   (set (subreg:SI (match_dup 0) 1)
	(not:SI (subreg:SI (match_dup 1) 1)))]
  ""
  "")


;;;;;;;;;;; Floating Point Moves ;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn ""
  [(set (match_operand:SF
	 0 "general_operand"
;;;;;;;;   0, 1,2,3,4,5, 6,  7, 8, 9,  0, 1,  2,   3, 4,  5, 6,  7,  8,  9
	 "=d,d,d,A,d,Q,dwx,dwx,wx, d,  B, A,CRS, dwx,AQ,DUT,DT,?*f,?*f,  d")
	(match_operand:SF
	 1 "general_operand" 
	 " G,d,A,d,Q,d,BR , wx,dA,CS,dwx,wx,  d,DUTi, i,  d,wx,  d,  O,?*f"))]
  "(GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM)"
  "*
{
  switch( which_alternative ) 
    {
     case 0: return \"%r0=%r0-%r0;\";	/*avoid floating faults*/
     case 6: return \"%0=%Q1;\";
     case 17: return \"%b0=%1;\";
     case 19: return \"%0=%b1;\";
     default: return \"%0=%1;\";
    }
   RET;
}"
  [(set_attr
    "type"
    "dreg_zero,dreg_move,pm_move,pm_move,dm_move,dm_move,move,move,move,move,move,move,move,imm_move,imm_move,imm_move,imm_move,compute,compute,compute")])

(define_expand "movsf"
  [(set (match_operand:SF 0 "general_operand" "")
	(match_operand:SF 1 "general_operand"  ""))]
  ""
  "
{
   if (GET_CODE (operands[1]) == MEM
       && GET_CODE (operands[0]) == MEM)
     {
       rtx treg = gen_reg_rtx (SFmode);
       emit_move_insn (treg, operands[1]);
       emit_move_insn (operands[0], treg);
       DONE;
     }
}")



;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;PM and DM patterns ;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define_insn "tstpm"
  [(set (cc0)
        (match_operand:PM 0 "register_operand" "d"))]
  ""
  "%0=pass %0;"
  [(set_attr "type" "compute")
   (set_attr "mode" "CCSET")
   (set_attr "cc" "compare")]
)

(define_insn "tstdm"
  [(set (cc0)
        (match_operand:DM 0 "register_operand" "d"))]
  ""
  "%0=pass %0;"
  [(set_attr "type" "compute")
   (set_attr "mode" "CCSET")
   (set_attr "cc" "compare")]
)

(define_expand "movdm"
  [(set (match_operand:DM 0 "general_operand" "")
	(match_operand:DM 1 "general_operand" ""))]
  ""
  "{
     if (GET_CODE(operands[0]) == MEM 
         && (GET_CODE(operands[1]) == MEM || CONSTANT_P (operands[1])))
     {
         if( !reload_in_progress) {
            rtx reg = gen_reg_rtx (DMmode);
            emit_insn ( gen_rtx(SET,DMmode,reg,operands[1]));
            emit_insn ( gen_rtx(SET,DMmode,operands[0],reg));
            DONE;
         }
         else {
           abort();
         }
     }
}")



(define_insn ""
  [(set (match_operand:DM
	 0 "general_operand"
;;;;;;;;   0,  1,2, 3, 4,5,6,  7,   8,  9,  0,   1, 2,   3,    4, 5,6,7,8,   9,  0,              1,  2,  3,  4,  5,  6,  7, 8,9
	 "=d,dwx,d, d,*A,d,Q,dwx, dwx, wx,  d,  *B,*A,*CRS,  dwx, Q,R,A,B,*DUT,*DT, hjudwx*y*z*a*e,hju,?*f,?*f,  d,?*r,*AQ,TU,D")
	(match_operand:DM
	 1 "general_operand" 
	 " O,  P,d,*A, d,Q,d,  R,*Bwx,d*A,*CS, dwx,wx,   d,*DUTi, P,P,P,P,   d, wx, hjudwx*y*z*a*e,  i,  d,  O,?*f,?*r,  i, P,P"))]
   "GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM"
  "*
{
  switch( which_alternative ) 
    {
     case 0:  return \"%0=0;\";
     case 1:  return \"%0=%P1;\";
     case 7:  return \"%0=%Q1;\";

     case 16:
     case 15: return \"%0=%R1;\";

     case 17:
     case 18: return \"%0=%P1;\";
     case 23: return \"%b0=%1;\";
     case 25: return \"%0=%b1;\";
     case 28: return \"%0=%R1;\";
     case 29: return \"%0=%P1;\";
     default: return \"%0=%1;\";
    }
   RET;
}"
  [(set_attr
    "type"
    "dreg_zero,move,dreg_move,pm_move,pm_move,dm_move,dm_move,move,move,move,move,move,move,move,imm_move,dm_move,move,pm_move,move,imm_move,imm_move,move,misc,compute,compute,compute,compute,imm_move,imm_move,imm_move")])


(define_expand "movpm"
  [(set (match_operand:PM 0 "general_operand" "")
	(match_operand:PM 1 "general_operand" ""))]
  ""
  "{
     if (GET_CODE(operands[0]) == MEM 
         && (GET_CODE(operands[1]) == MEM || CONSTANT_P (operands[1])))
     {
         if( !reload_in_progress) {
            rtx reg = gen_reg_rtx (PMmode);
            emit_insn ( gen_rtx(SET,PMmode,reg,operands[1]));
            emit_insn ( gen_rtx(SET,PMmode,operands[0],reg));
            DONE;
         }
         else {
           abort();
         }
     }
}")


(define_insn ""
  [(set (match_operand:PM
	 0 "general_operand"
;  0,1,2,3,4,5,      6,      7,   8, 9, 0,    1,  2,   3, 4,   5,      6,7,8, 9,  0,    1,         2,  3,  4,  5,  6,  7, 8 
 "=d,d,d,A,d,Q,d*w*xyz,d*w*xyz,*w*x,yz, d,    B,  R,   A, Q,BCRS,d*w*xyz,A,B,AQ, UT,   DT,aeud*w*xyz,aeu,?*f,?*f,  d,?*r,DT")
	(match_operand:PM
	 1 "general_operand"
 " O,d,A,d,Q,d,     BR, *w*xyz,  dA,dQ,CS,d*w*x,dyz,*w*x,yz,   d,   DUTi,P,P, i,dyz,d*w*x,aeud*w*xyz,  i,  d,  O,?*f,?*r, P"))]
   "GET_CODE (operands[0]) != MEM || GET_CODE (operands[1]) != MEM"
  "*
{
  switch( which_alternative ) 
    {
     case 6:  return \"%0=%Q1;\";
     case 17:
     case 18:
	 return \"%0=%P1;\";     /* Use m5-7 with DAG2 */
     case 24: return \"%b0=%1;\";
     case 26: return \"%0=%b1;\";
     case 28: return \"%0=%R1;\";
     default: return \"%0=%1;\";
    }
   RET;
}"
; The following line matches with the alternatives below
;          0      1         2      3        4      5      6    7    8    9    10  11    12   13  14   15    16       17     18   19      20        21     
  [(set_attr
    "type"
    "dreg_zero,dreg_move,pm_move,pm_move,dm_move,dm_move,move,move,move,move,move,move,move,move,move,move,imm_move,pm_move,move,imm_move,imm_move,imm_move,move,misc,compute,compute,compute,move,imm_move")])

(define_insn ""
  [(set (match_operand:DM 0 "general_operand" "=r")
	(match_operand:SI 1 "general_operand" "r"))]
   "GET_CODE (operands[0])!=MEM || GET_CODE (operands[1])!=MEM"
  "%0=%1;")

(define_insn ""
  [(set (match_operand:PM 0 "general_operand" "=d")
	(match_operand:DM 1 "general_operand" "d"))]
   "GET_CODE (operands[0])!=MEM || GET_CODE (operands[1])!=MEM"
  "%0=%1; !! Warning -- conversion from DM to PM")

(define_insn ""
  [(set (match_operand:DM 0 "general_operand" "=d")
	(match_operand:PM 1 "general_operand" "d"))]
   "GET_CODE (operands[0])!=MEM || GET_CODE (operands[1])!=MEM"
  "%0=%1; !! Warning -- conversion from PM to DM")


(define_insn "addpm3"
;                                                            0 1 2  3 4  5  6  7  8
  [(set (match_operand:PM 0 "register_operand"            "=*y,y,y, d,d,*w,*w,*w")
	(plus:PM (match_operand:PM 1  "register_operand"   "%0,0,0, d,d, 0, 0, 0")
		  (match_operand:PM 2 "reg_or_imm_operand"  "P,z,i,dI,N,*x, P, i")))]
  ""
  "@
    modify(%0,%R2);
    modify(%0,%2);
    modify(%0,%2);
    %0=%1+%2;
    %0=%1-1;
    modify(%0,%2);
    modify(%0,%P2);
    modify(%0,%2);"
  [(set_attr "type" "move,move,misc,compute,compute,move,move,misc")])

(define_insn "adddm3" 
;                                                           0 1 2  3 4
  [(set (match_operand:DM 0 "register_operand"           "=*w,w,w, d,d")
	(plus:DM (match_operand:DM 1 "register_operand"   "%0,0,0, d,d")
		 (match_operand:DM 2 "reg_or_imm_operand" " P,x,i,dI,N")))]
  ""
  "@
    modify(%0,%P2);
    modify(%0,%2);
    modify(%0,%2);
    %0=%1+%2;
    %0=%1-1;"
  [(set_attr "type" "move,move,misc,compute,compute")])

(define_insn "subdm3"
;                                                            0  1 2 3 4 5  6
  [(set (match_operand:DM 0 "register_operand"            "=*w,*w,w,d,d,d,*d")
 	(minus:DM (match_operand:DM 1 "register_operand"  "  0, 0,0,d,d,c,*d")
 		  (match_operand:DM 2 "reg_or_imm_operand" " I, N,i,I,N,l,*d")))]
  ""
  "@
    modify(%0,m7);
    modify(%0,m6);
    modify(%0,-%2);
    %0=%1-%2;
    %0=%1-%2;
    %0=%1-%2;
    %0=%1-%2;"
    [(set_attr "type" "move,move,misc,compute,compute,compute,compute")])

(define_insn "subpm3"
  [(set (match_operand:PM 0 "register_operand"              "=*d,y,y,y,d,d,d")
	(minus:PM (match_operand:PM 1 "register_operand"    " *d,0,0,0,d,d,c")
		   (match_operand:PM 2 "reg_or_imm_operand" " *d,N,I,i,I,N,l")))]
  ""
  "@
    %0=%1-%2;
    modify(%0,m14);
    modify(%0,m15);
    modify(%0,-%2);
    %0=%1-%2;
    %0=%1+%2;
    %0=%1-%2;"
    [(set_attr "type" "compute,move,move,misc,compute,compute,compute")])


;;;; PM and DM are always compared as unsigned. ;;;;;;

(define_expand "cmpdm"
  [(set (cc0)
	(compare (match_operand:DM 0 "register_operand" "d")
		 (match_operand:DM 1 "register_operand" "d")))
   (use (match_operand:DM 2 "" ""))]
  "" 
  "
{
   switch(GET_CODE(operand2))
    {
        case LTU:
	case LEU:
	case GTU:
	case GEU:	
	     emit (gen_rtx (PARALLEL, VOIDmode,
				   gen_rtvec (2,
					     gen_rtx (SET, VOIDmode, gen_reg_rtx(DMmode), 
							  gen_rtx (MINUS, DMmode, operand0, 
									  operand1)),
					     gen_rtx (SET, VOIDmode, cc0_rtx, 
							   gen_rtx (COMPARE, VOIDmode, 
									     operand0, 
									     operand1)))));
	     DONE;
	case LT:
	case LE:
	case GT:
	case GE:
	case EQ:
	case NE:
	     emit_insn (gen_rtx (SET, VOIDmode, cc0_rtx, 
				   gen_rtx (COMPARE, VOIDmode, operand0, operand1)));
	     DONE;
	default:
		abort();
     }
}")

(define_insn ""
   [(parallel [(set (match_operand:DM 0 "register_operand" "=*d,d")
		   (minus:DM (match_operand:DM 1 "register_operand" "*d,c")
			     (match_operand:DM 2 "register_operand" "*d,l")))
	      (set (cc0)
		   (compare (match_dup 1)
			    (match_dup 2)))])]

  ""
  "%0=%1-%2;"
  [(set_attr "type" "compute,comp_alu_fix")
   (set_attr "mode" "CCSET")
   (set_attr "cc"   "compare")])

(define_insn ""
   [(set (cc0)
	 (compare (match_operand:DM 0 "register_operand"  "d")
		  (match_operand:DM 1 "register_operand"  "d")))]
  ""
  "comp(%0,%1);"
 [(set_attr "type" "compute")
  (set_attr "mode" "CCSET")
  (set_attr "cc" "compare")])

(define_expand "cmppm"
  [(set (cc0)
	(compare (match_operand:PM 0 "register_operand" "d")
		 (match_operand:PM 1 "register_operand" "d")))
   (use (match_operand:DM 2 "" ""))]
  "" 
  "
{
   switch(GET_CODE(operand2))
    {
        case LTU:
	case LEU:
	case GTU:
	case GEU:	
		emit (gen_rtx (PARALLEL, VOIDmode,
		   gen_rtvec (2,
		     gen_rtx (SET, VOIDmode, gen_reg_rtx(PMmode), 
	                gen_rtx (MINUS, PMmode, operand0, operand1)),
		     gen_rtx (SET, VOIDmode, cc0_rtx, 
				gen_rtx (COMPARE, VOIDmode, operand0, operand1)))));
		DONE;
	case LT:
	case LE:
	case GT:
	case GE:
	case EQ:
	case NE:
	     emit_insn (gen_rtx (SET, VOIDmode, cc0_rtx, 
				   gen_rtx (COMPARE, VOIDmode, operand0, operand1)));
	     DONE;
	default:
		abort();
     }
}")


(define_insn ""
   [(parallel [(set (match_operand:PM 0 "register_operand" "=*d,d")
		   (minus:PM (match_operand:PM 1 "register_operand" "*d,c")
			     (match_operand:PM 2 "register_operand" "*d,l")))
	      (set (cc0)
		   (compare (match_dup 1)
			    (match_dup 2)))])]

  ""
  "%0=%1-%2;"
  [(set_attr "type" "compute,comp_alu_fix")
   (set_attr "mode" "CCSET")
   (set_attr "cc"   "compare,compare")])

(define_insn ""
   [(set (cc0)
	 (compare (match_operand:PM 0 "register_operand"  "d")
		  (match_operand:PM 1 "register_operand"  "d")))]
  ""
  "comp(%0,%1);"
 [(set_attr "type" "compute")
  (set_attr "mode" "CCSET")
  (set_attr "cc" "compare")])


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
;               TRUNCATES and EXTENDS
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
(define_expand "truncsidm2"
  [(set (match_operand:DM 0 "general_operand" "")
	(match_operand:DM 1 "general_operand" ""))]
  ""
 "{
     rtx op1 = operands[1];
     switch(GET_CODE(op1)) 
        {
        case MEM:
        case CONST: 
          {
          rtx new = copy_rtx(operands[1]);
          GET_MODE(new) = DMmode;
          emit_move_insn(operands[0], new);
          DONE;
          }
	case CONST_INT:
          break;
        default:
          operands[1] = force_reg(DMmode, operands[1]);
        }
  }"
)


(define_expand "truncsipm2"
  [(set (match_operand:PM 0 "general_operand" "")
        (match_operand:PM 1 "general_operand" ""))]
  ""
 "{
     rtx op1 = operands[1];
     switch(GET_CODE(op1)) 
        {
        case MEM:
        case CONST: 
         {
          rtx new = copy_rtx(operands[1]);
          GET_MODE(new) = PMmode;
          emit_move_insn(operands[0], new);
	  DONE;
	  }
	case CONST_INT:
	  break;
	default:
	  operands[1] = force_reg(PMmode, operands[1]);
       }
  }"
)

;;
;;; There is a silly reason for sign- (as opposed to zero-) extending
;;; from integer to pointers: the difference between pointers in gcc
;;; is still a pointer (not an integer!!), but when converted to
;;; integer it must be signed, i.e. (p1 - p2 ) = -(p2 - p1).
;;;

(define_expand "extendpmsi"
  [(set (match_operand:SI 0 "general_operand" "")
	(match_operand:SI 1 "general_operand" ""))]
  ""
  "{
     switch(GET_CODE(operands[1])) 
	{
        case MEM:
        case CONST: 
            {
                rtx new = copy_rtx(operands[1]);
                GET_MODE(new) = SImode;
                emit_move_insn(operands[0], new);
            }
            DONE;
            break;
	case CONST_INT:
	    break;
        default:
            operands[1] = force_reg(SImode, operands[1]);
        }
  }"
)

(define_expand "extenddmsi"
  [(set (match_operand:SI 0 "general_operand" "")
	(match_operand:SI 1 "general_operand" ""))]
  ""
 "{
     switch(GET_CODE(operands[1])) 
	{
        case MEM:
        case CONST: 
            {
                rtx new = copy_rtx(operands[1]);
                GET_MODE(new) = SImode;
                emit_move_insn(operands[0], new);
            }
            DONE;
            break;
	case CONST_INT:
	    break;
        default:
            operands[1] = force_reg(SImode, operands[1]);
        }
  }"
)

(define_expand "truncdmpm2"
  [(set (match_operand:PM 0 "general_operand" "")
	(match_operand:PM 1 "general_operand" ""))]
  ""
 "{
     rtx op1 = operands[1];

     switch(GET_CODE(op1)) 
       {
        case MEM:
        case CONST: 
          {
          rtx new = copy_rtx(operands[1]);
          GET_MODE(new) = PMmode;
          emit_move_insn(operands[0], new);
	  DONE;
	  }
	case CONST_INT:
          break;
     default:
       operands[1] = force_reg(PMmode, operands[1]);
    }
  }"
)

(define_expand "extendpmdm"
  [(set (match_operand:DM 0 "general_operand" "")
	(match_operand:DM 1 "general_operand" ""))]
  ""
  "{
     rtx op1 = operands[1];

     switch(GET_CODE(op1)) 
        {
        case MEM:
        case CONST: 
          {
          rtx new = copy_rtx(operands[1]);
          GET_MODE(new) = DMmode;
          emit_move_insn(operands[0], new);
	  DONE;
          }
	  /* Fall THRU*/
	case CONST_INT:
	  break;
     default:
       operands[1] = force_reg(DMmode, operands[1]);
    }
  }"
)

; Multi Function Insn Combiner

;; Combiner seems to ignore  commutativity spec ('%'), so we need to
;; provide all the patterns.

(define_insn "multiply_and_increment"
  [(set (match_operand:SI 0 "mr_operand" "+f")
	(plus:SI (match_dup 0)
		 (mult:SI (match_operand:SI 1 "datareg_operand" "d")
			  (match_operand:SI 2 "datareg_operand" "d"))))]
  ""
  "%0=%0+%1*%2 (ssi);"
  [(set_attr "type" "compute")
    (set_attr "operator" "mac")
  ])


(define_insn ""
  [(set (match_operand:SI 0 "mr_operand" "+f")
	(plus:SI  (mult:SI (match_operand:SI 1 "datareg_operand" "d")
			   (match_operand:SI 2 "datareg_operand" "d"))
		  (match_dup 0)))]
  ""
  "%0=%0+%1*%2 (ssi);"
  [(set_attr "type" "compute")
    (set_attr "operator" "mac")
  ])



(define_insn "multiply_and_increment_r"
  [(set (match_operand:SI 0 "datreg_or_mr_operand" "=f,d") 
	(plus:SI (match_operand:SI 1 "mr_operand" "0,f")
		 (mult:SI (match_operand:SI 2 "datareg_operand" "d,d")
			  (match_operand:SI 3 "datareg_operand" "d,d"))))]
  ""
  "%0=%1+%2*%3 (ssi);"
  [(set_attr "type" "compute")]
)

(define_insn ""
  [(set (match_operand:SI 0 "datreg_or_mr_operand" "=f,d")
	(plus:SI (mult:SI (match_operand:SI 2 "datareg_operand" "d,d")
			  (match_operand:SI 3 "datareg_operand" "d,d"))
		 (match_operand:SI 1 "mr_operand" "0,f")))]
  ""
  "%0=%1+%2*%3 (ssi);"
  [(set_attr "type" "compute")]
)


;;;;;;;;;;;;;;;;;;;;;; MULTIPLY AND DECREMENT ;;;;;;;;;;;;;;;;;;;;;;


(define_insn "multiply_and_decrement"
  [(set (match_operand:SI 0 "mr_operand" "+f")
	(minus:SI (match_dup 0)
		 (mult:SI (match_operand:SI 1 "datareg_operand" "d")
			  (match_operand:SI 2 "datareg_operand" "d"))))
    ]
  ""
  "%0=%0-%1*%2 (ssi);"
  [(set_attr "type" "compute")])


(define_insn "multiply_and_decrement_r"
  [(set (match_operand:SI 0 "datreg_or_mr_operand" "=f,d") 
	(minus:SI (match_operand:SI 1 "mr_operand" "0,f")
		 (mult:SI (match_operand:SI 2 "datareg_operand" "d,d")
			  (match_operand:SI 3 "datareg_operand" "d,d"))))
    ]
  ""
  "%0=%1-%2*%3 (ssi);"
  [(set_attr "type" "compute,compute")])

(define_insn ""
   [(parallel [(set (match_operand:SF 0 "datareg_operand" "=d") 
		    (mult:SF (match_operand:SF 1 "datareg_operand" "k")
			     (match_operand:SF 2 "datareg_operand" "b")))
	       (set (match_operand:SF 3 "datareg_operand" "=d")
		    (minus:SF (match_operand:SF 4 "datareg_operand" "c")
			      (match_operand:SF 5 "datareg_operand"  "l")))])]
 ""
 "%0=%1*%2, %3=%4-%5;"
  [(set_attr "type" "compute")])

(define_insn ""
   [(parallel [(set (match_operand:SF 0 "datareg_operand" "=d") 
		    (mult:SF (match_operand:SF 1 "datareg_operand" "k")
			     (match_operand:SF 2 "datareg_operand" "b")))
	       (set (match_operand:SF 3 "datareg_operand" "=d")
		    (plus:SF (match_operand:SF 4 "datareg_operand" "c")
			    (match_operand:SF 5 "datareg_operand"  "l")))])]
 ""
 "%0=%1*%2, %3=%4+%5;"
  [(set_attr "type" "compute")])

(define_insn ""
   [(parallel [(set (match_operand:SF 0 "datareg_operand" "=d") 
		    (mult:SF (match_operand:SF 1 "datareg_operand" "k")
			     (match_operand:SF 2 "datareg_operand" "b")))
	       (set (match_operand:SF 3 "datareg_operand" "=d")
		    (abs:SF (match_operand:SF 4 "datareg_operand" "c")))])]
 ""
 "%0=%1*%2, %3=abs %4;"
  [(set_attr "type" "compute")])

(define_insn ""
   [(parallel [(set (match_operand:SF 0 "datareg_operand" "=d") 
		    (mult:SF (match_operand:SF 1 "datareg_operand" "k")
			     (match_operand:SF 2 "datareg_operand" "b")))
	       (set (match_operand:SF 3 "datareg_operand" "=d")
		    (smin:SF (match_operand:SF 4 "datareg_operand" "c")
			     (match_operand:SF 5 "datareg_operand"  "l")))])]
 ""
 "%0=%1*%2, %3=min(%4,%5);"
  [(set_attr "type" "compute")])

(define_insn ""
   [(parallel [(set (match_operand:SF 0 "datareg_operand" "=d") 
		    (mult:SF (match_operand:SF 1 "datareg_operand" "k")
			     (match_operand:SF 2 "datareg_operand" "b")))
	       (set (match_operand:SF 3 "datareg_operand" "=d")
		    (smax:SF (match_operand:SF 4 "datareg_operand" "c")
			     (match_operand:SF 5 "datareg_operand"  "l")))])]
 ""
 "%0=%1*%2, %3=max(%4,%5);"
  [(set_attr "type" "compute")])


;;  ....................
;;
;;  Increment/Decrement
;;
;;  ....................

(define_insn "dual_add_subtract"
  [(set (match_operand:SI 0 "datareg_operand"         "=*d,d")
	(plus:SI (match_operand:SI 1 "datareg_operand" "*d,c")
		 (match_operand:SI 2 "datareg_operand" "*d,l")))

   (set (match_operand:SI 3 "datareg_operand" "=*d,d")
	(minus:SI (match_dup 1)
		  (match_dup 2)))]
  ""
  "%0=%1+%2, %3=%1-%2;"
  [(set_attr "type" "compute,comp_alu_fix")])

(define_insn "Increment_Data_Reg"
  [(set (match_operand:SI 0 "register_operand" "=d,*w")	
	(plus:SI (match_operand:SI 1 "register_operand" "d,0")
	        (const_int 1)))]
  ""
  "@
    %0=%1+1;
    modify(%0,m6);"
  [(set_attr "type" "compute,move")])

(define_insn "Negative_Increment_Data_Reg"
  [(set (match_operand:SI 0 "register_operand" "=d,*w")
	(plus:SI (match_operand:SI 1 "register_operand" "d,0")
		 (const_int -1)))]
  ""
  "@
    %0=%1-1;
    modify(%0,m7);"
  [(set_attr "type" "compute,move")])

(define_insn "Decrement_Data_Reg"
  [(set (match_operand:SI 0 "register_operand" "=d,*w")
	(minus:SI (match_operand:SI 1 "datareg_operand" "d,0")
		  (const_int 1)))]
  ""
  "@
    %0=%1-1;
    modify(%0,m7);"
  [(set_attr "type" "compute,move")])

;
;  absolute value
;
(define_insn ""
  [(set (match_operand:SF 0 "datareg_operand" "=d")
	(abs:SF
	 (plus:SF (match_operand:SF 1 "datareg_operand" "%d")
		  (match_operand:SF 2 "datareg_operand" "d"))))]
  ""
  "%0=abs(%1+%2);"
  [(set_attr "type" "compute")
   (set_attr "cc" "sets")
   (set_attr "mode" "SF")])

(define_insn ""
  [(set (match_operand:SF 0 "datareg_operand" "=d")
	(abs:SF
	 (minus:SF (match_operand:SF 1 "datareg_operand" "d")
		   (match_operand:SF 2 "datareg_operand" "d"))))]
  ""
  "%0=abs(%1-%2);"
  [(set_attr "type" "compute")
   (set_attr "cc" "sets")
   (set_attr "mode" "SF")])

   
(define_insn "abssi2"
  [(set (match_operand:SI 0 "datareg_operand" "=d")
	(abs:SI (match_operand:SI 1 "datareg_operand" "d")))]
  ""
  "%0=abs %1;"
  [(set_attr "type" "compute")
   (set_attr "cc" "sets")
  ])

   
(define_insn "absdm2"
  [(set (match_operand:DM 0 "datareg_operand" "=d")
	(abs:DM (match_operand:DM 1 "datareg_operand" "d")))]
  ""
  "%0=abs %1;"
  [(set_attr "type" "compute")
   (set_attr "cc" "sets")
  ])

(define_insn "abspm2"
  [(set (match_operand:PM 0 "datareg_operand" "=d")
	(abs:PM (match_operand:PM 1 "datareg_operand" "d")))]
  ""
  "%0=abs %1;"
  [(set_attr "type" "compute")
   (set_attr "cc" "sets")
  ])


(define_insn "abssf2"
  [(set (match_operand:SF 0 "datareg_operand"        "=*d,d")
	(abs:SF (match_operand:SF 1 "datareg_operand" "*d,c")))]
  ""
  "%0=abs %1;"
  [(set_attr "type" "compute,comp_alu_float")
   (set_attr "cc" "sets")
   (set_attr "mode" "SF")])

(define_expand "absdf2"
  [(set (subreg:SI (match_operand:DF 0 "register_operand" "") 0)
	(zero_extract:SI (subreg:SI (match_operand:DF 1 "register_operand" "") 0)
			(const_int 31)
			(const_int 1)))
   (set (subreg:SI (match_dup 0) 1)
	(subreg:SI (match_dup 1) 1))]
  ""
  "")

(define_insn "smaxsi3"
  [(set (match_operand:SI 0 "datareg_operand" "=d")
	(smax:SI (match_operand:SI 1 "datareg_operand" "d")
		 (match_operand:SI 2 "datareg_operand" "d")))]
  ""
  "%0=max(%1,%2);"
  [(set_attr "type" "compute")])

(define_insn "maxsf3"
  [(set (match_operand:SF 0 "datareg_operand" "=*d,d")
	(smax:SF (match_operand:SF 1 "datareg_operand" "*d,c")
		 (match_operand:SF 2 "datareg_operand" "*d,l")))]
  ""
  "%0=max(%1,%2);"
  [(set_attr "type" "compute,comp_alu_float")
   (set_attr "mode" "SF")])

(define_insn "sminsi3"
  [(set (match_operand:SI 0 "datareg_operand" "=d")
	(smin:SI (match_operand:SI 1 "datareg_operand" "d")
		 (match_operand:SI 2 "datareg_operand" "d")))]
  ""
  "%0=min(%1,%2);"
  [(set_attr "type" "compute")])

(define_insn "minsf3"
  [(set (match_operand:SF 0 "datareg_operand" "=*d,d")
	(smin:SF (match_operand:SF 1 "datareg_operand" "*d,c")
		 (match_operand:SF 2 "datareg_operand" "*d,l")))]
  ""
  "%0=min(%1,%2);"
  [(set_attr "type" "compute,comp_alu_float")
   (set_attr "mode" "SF")])



;;  ....................
;;
;;  Add instructions
;;
;;  ....................


;;;  Try r8-11,r12-15 pairs if possible.
;;;

(define_insn "addsi3"
;                                                          0  1 2 3  4  5  6
  [(set (match_operand:SI 0 "register_operand"           "=d, d,d,d,*w,*w,*w")
	(plus:SI (match_operand:SI 1 "register_operand"  "%c, d,d,d, 0, 0, 0")
		 (match_operand:SI 2 "nonmemory_operand"  "l, d,N,I, P, x, i")))]
  ""
  "@
   %0=%1+%2;
   %0=%1+%2;
   %0=%1-1;
   %0=%1+%2;
   modify(%0,%P2);
   modify(%0,%2);
   modify(%0,%2);"
  [(set_attr "type" "comp_alu_fix,compute,compute,compute,move,move,misc")]
)


(define_insn "adddf3"
  [(set (match_operand:DF 0 "datareg_operand" "=*d,d")
	(plus:DF (match_operand:DF 1 "datareg_operand" "%*d,c")
		 (match_operand:DF 2 "datareg_operand"  "*d,l")))]
  "DOUBLE_IS_32"
  "%0=%1+%2;"
  [(set_attr "type" "compute,comp_alu_float")])

(define_insn "addsf3"
  [(set (match_operand:SF 0 "datareg_operand"          "=d,*d")
 	(plus:SF (match_operand:SF 1 "datareg_operand" "%c,*d")
 		 (match_operand:SF 2 "datareg_operand"  "l,*d")))]
  ""
  "%0=%1+%2;"
  [(set_attr "type" "comp_alu_float,compute")
   (set_attr "mode" "SF")])

;;;
;;; This is explicitly checked for in expr.c 
;;; I thinks its okay.  Hel we strip out extra code.
;;;
(define_insn "avgsi3"
  [(set (match_operand:SI 0 "general_operand" "=d,*d")
	(div:SI
 	   (plus:SI (match_operand:SI 1 "datareg_operand" "%c,*d")
 		    (match_operand:SI 2 "datareg_operand"  "l,*d"))
	   (const_int 2)))]
  ""
  "%0=(%1+%2)/2;"
  [(set_attr "type" "compute,compute")])

(define_insn "avgsf3"
  [(set (match_operand:SF 0 "datareg_operand" "=d,*d")
	(div:SF
 	   (plus:SF (match_operand:SF 1 "datareg_operand" "%c,*d")
 		    (match_operand:SF 2 "datareg_operand"  "l,*d"))
	   (const_int 2)))]
  ""
  "%0=(%1+%2)/2;"
  [(set_attr "type" "comp_alu_float,compute")])
	
;;
;;  ....................
;;
;;  Subtract instructions
;;
;;  ....................  

(define_insn "subsi3"
   [(set (match_operand:SI 0 "register_operand"             "=d,d,d,d,*w,*w, w")
	 (minus:SI (match_operand:SI 1 "register_operand"   " c,d,d,d, 0, 0, 0")
		   (match_operand:SI 2 "nonmemory_operand"  " l,d,I,N, N, I, i")))]
  ""
  "@
   %0=%1-%2;
   %0=%1-%2;
   %0=%1-1;
   %0=%1+1;
   modify(%0,m6);
   modify(%0,m7);
   modify(%0,-%2);"

  [(set_attr "type" "comp_alu_fix,compute,compute,compute,move,move,misc")])


(define_insn "subsf3"
  [(set (match_operand:SF 0 "datareg_operand" "=d,*d")
 	(minus:SF (match_operand:SF 1 "datareg_operand" "c,*d")
 		  (match_operand:SF 2 "datareg_operand" "l,*d")))]
  ""
  "%0=%1-%2;"
  [(set_attr "type" "comp_alu_float,compute")
   (set_attr "mode" "SF")])



;;
;;  ....................
;;
;;  Divide instructions
;;
;;  ....................
;;
;;  The situation for divide is even worse than multiply.
;;  The 21020 has no divide instructions. GCC will
;;  generate the appropriate library calls.
;;

(define_insn ""
  [(parallel [(set (match_operand:SF 0 "datareg_operand" "=d")
	       	   (unspec:SF [(match_operand:SF 1 "datareg_operand" "d")
			       (match_operand:SI 2 "datareg_operand" "d")] 0))
	      (use (match_dup 1))
  	      (use (match_dup 2))])]
 ""
 "%0=scalb %1 by %2;"
  [(set_attr "type" "compute")])

(define_insn ""
  [(set (match_operand:SF 0 "datareg_operand" "=d")
	   (unspec:SF [(match_operand:SF 1 "datareg_operand" "d")] 1))]
 ""
 "%0=recips %1;"
  [(set_attr "type" "compute")])

(define_insn ""
  [(set (match_operand:SF 0 "datareg_operand" "=d")
	(unspec:SF [(match_operand:SF 1 "datareg_operand" "d")] 2))]
  ""
  "%0=rsqrts %1;"
  [(set_attr "type" "compute")])

(define_expand "modsi3"
 [(set  (match_operand:SI 0 "datareg_operand" "")
	(mod:SI (match_operand:SI 1 "datareg_operand" "")
    		(match_operand:SI 2 "immediate_operand" "")))]
 ""
 "
{
  unsigned int mask;
  int iv;
  rtx reg;

  if (GET_CODE (operands[2]) != CONST_INT) FAIL;

  /* FORCE A MODSI3 */
  FAIL;  /* This needs work and the code in expmed is getting killed by flow!! */

  iv = exact_log2(INTVAL(operands[2]));
  if ( iv > 0 ) {
    rtx label;
    mask = ~0;
    mask <<= iv;
    reg = gen_reg_rtx (SImode);
    label = gen_label_rtx ();
    emit_insn (gen_rtx (SET, SImode, reg, gen_rtx(CONST_INT,VOIDmode,mask)));
    emit_insn (gen_rtx (SET, SImode, operands[0],
		        gen_rtx(AND,SImode,operands[1],reg)));    
    emit_cmp_insn (operands[1], const0_rtx, GE, 0, SImode, 0, 0);
    emit_jump_insn (gen_bge (label));
    emit_insn (gen_rtx (SET, SImode, operands[0], gen_rtx( NEG,SImode, operands[0])));
    emit_label (label);
    DONE;
  }

  FAIL;
}")

(define_expand "divsf3"
 [(set  (match_operand:SF 0 "datareg_operand" "=d")
	(div:SF (match_operand:SF 1 "datareg_operand" "d")
    		(match_operand:SF 2 "nonmemory_operand" "d")))
  (use (match_dup 3))
  (use (match_dup 4))
  (use (match_dup 5))]
 "" 
 "
{

    rtx subreg = NULL_RTX;

    if (CONSTANT_P(operands[2]))
    {
	REAL_VALUE_TYPE rval;
	unsigned int ip;
	REAL_VALUE_TYPE fp;
	int log;

	REAL_VALUE_FROM_CONST_DOUBLE(rval, operands[2]);
	ip  = (unsigned int) rval;
	fp  = ip - rval;
	log = exact_log2(ip);
	if (fp == 0.0 && log >= 0)
	{
	    rtx             scale = gen_reg_rtx(SImode);

	    emit_insn(gen_rtx(SET, VOIDmode, scale, gen_rtx(CONST_INT, VOIDmode, -log)));
	    emit_insn(gen_rtx(PARALLEL, VOIDmode,
			      gen_rtvec(3,
					gen_rtx(SET, SFmode, operands[0],
					gen_rtx(UNSPEC, SFmode, gen_rtvec(2,
						   operands[1], scale), 0)),
					gen_rtx(USE, VOIDmode, operands[1]),
					gen_rtx(USE, VOIDmode, scale))));
	    DONE;
	}
    }

    if (KEEP_CODE_SMALL)
       FAIL;

    /* It seems that subreg's screw up if the result is to a subreg 
       don't ask me why but they do so lets just copy. */
    if (GET_CODE (operands[0]) == SUBREG)
    {
         subreg = operands[0];
         operands[0] = gen_reg_rtx(SFmode);
    }

    operands[3] = gen_reg_rtx(SFmode);
    operands[4] = gen_reg_rtx(SFmode);

    operands[5] = gen_reg_rtx(SFmode);
    /*
     * Comments apply to below expand:
f2   * 0 is f0 result
     * 1 is f0 numerator
f5   * 2 is f12 denominator
f8   * 3 is f7 
f8   * 4 is f11
f12  * 5
     */
    emit_insn(gen_rtx(SET, SFmode, operands[4],
		      CONST_DOUBLE_FROM_REAL_VALUE(dconst2, SFmode)));
    
    if(!REG_P(operands[2]))
      {
	rtx temp=gen_reg_rtx(SFmode);
	emit_insn(gen_rtx(SET,SFmode,temp,operands[2]));
	operands[2]=temp;
      }

    emit_insn(gen_rtx(SET, VOIDmode, operands[0], 
					gen_rtx(UNSPEC, SFmode,
						gen_rtvec(1,operands[2]), 1)));

    emit_insn(gen_rtx(SET, VOIDmode, operands[5], 
		      gen_rtx(MULT, SFmode, operands[0], operands[2])));

    emit_insn(gen_rtx(PARALLEL, VOIDmode,
		      gen_rtvec(2, 
				gen_rtx(SET, VOIDmode, operands[3], 
					gen_rtx(MULT, SFmode, operands[0],operands[1])), 
				gen_rtx(SET, VOIDmode, operands[0], 
					gen_rtx(MINUS, SFmode, operands[4],operands[5])))));

    emit_insn(gen_rtx(SET, VOIDmode, operands[5],
		      gen_rtx(MULT, SFmode, operands[0], operands[5])));

    emit_insn(gen_rtx(PARALLEL, VOIDmode, 
		      gen_rtvec(2,
				gen_rtx(SET, VOIDmode, operands[3], 
					gen_rtx(MULT, SFmode, operands[0], operands[3])),
				gen_rtx(SET, VOIDmode, operands[0], 
					gen_rtx(MINUS, SFmode,operands[4], operands[5])))));

    emit_insn(gen_rtx(SET, VOIDmode, operands[5], 
		      gen_rtx(MULT, SFmode, operands[0], operands[5])));

    emit_insn(gen_rtx(PARALLEL, VOIDmode, 
		      gen_rtvec(2,
				gen_rtx(SET, VOIDmode, operands[3], 
					gen_rtx(MULT, SFmode, operands[0], operands[3])),
				gen_rtx(SET, VOIDmode, operands[0], 
					gen_rtx(MINUS, SFmode, operands[4], operands[5])))));

/*    We used to have this one emit_insn() instead of the last four, but
      it didn't give good enough results.

  emit_insn(gen_rtx(SET, VOIDmode, operands[0], 
		      gen_rtx(MULT, SFmode, operands[0], operands[3])));

*/
    emit_insn(gen_rtx(SET, VOIDmode, operands[3], 
		      gen_rtx(MULT, SFmode, operands[0], operands[3])));

    emit_insn(gen_rtx(SET, VOIDmode, operands[0], 
		      gen_rtx(MINUS, SFmode, operands[0], operands[5])));

    emit_insn(gen_rtx(SET, VOIDmode, operands[0], 
		      gen_rtx(MULT, SFmode, operands[0], operands[3])));

    emit_insn(gen_rtx(SET, VOIDmode, operands[0], 
		      gen_rtx(PLUS, SFmode, operands[0], operands[3])));

    if (subreg)
       emit_move_insn (subreg, operands[0]);

    DONE;
}")


;;; Inline SQRT

(define_expand "sqrtsf2"
  [(set  (match_operand:SF 0 "datareg_operand" "=d")
	 (sqrt:SF (match_operand:SF 1 "datareg_operand" "d")))
   (use (match_dup 2))
   (use (match_dup 3))
   (use (match_dup 4))]
  "!(DONT_INLINE_SQRT||KEEP_CODE_SMALL)"
  "
{
    operands[2] = gen_reg_rtx(SFmode);
    operands[3] = gen_reg_rtx(SFmode);
    operands[4] = gen_reg_rtx(SFmode);

    /*
     * Comments apply to below expand:
     * 0 is f4  result
     * 1 is f0  input
     * 2 is f1  0.5
     * 3 is f8  3.0
     * 4 is f12 
     */
    emit_move_insn(operands[2], CONST_DOUBLE_FROM_REAL_VALUE(REAL_VALUE_ATOF(\"0.5\"), SFmode));
    emit_move_insn(operands[3], CONST_DOUBLE_FROM_REAL_VALUE(REAL_VALUE_ATOF(\"3.0\"), SFmode));
    
    if(!REG_P(operands[1]))
      {
	rtx temp=gen_reg_rtx(SFmode);
	emit_move_insn(temp,operands[1]);
	operands[1]=temp;
      }

    emit_insn (gen_rtx (SET, VOIDmode, operands[0],
			gen_rtx (UNSPEC, SFmode,
				 gen_rtvec (1,operands[1]), 2)));
    emit_insn (gen_rtx (SET, SFmode, operands[4],
			gen_rtx (MULT, SFmode, operands[0], operands[0])));
    emit_insn (gen_rtx (SET, SFmode, operands[4],
			gen_rtx (MULT, SFmode, operands[4], operands[1])));
    emit_insn (gen_rtx (PARALLEL, VOIDmode,
			gen_rtvec(2,
				  gen_rtx (SET, VOIDmode, operands[0],
					   gen_rtx (MULT, SFmode, operands[2], operands[0])),
				  gen_rtx (SET, VOIDmode, operands[4], 
					   gen_rtx (MINUS, SFmode, operands[3], operands[4])))));
    emit_insn (gen_rtx (SET, SFmode, operands[0],
			gen_rtx (MULT, SFmode, operands[0], operands[4])));
    emit_insn (gen_rtx (SET, SFmode, operands[4],
			gen_rtx (MULT, SFmode, operands[0], operands[0])));
    emit_insn (gen_rtx (SET, SFmode, operands[4],
			gen_rtx (MULT, SFmode, operands[4], operands[1])));
    emit_insn (gen_rtx (PARALLEL, VOIDmode,
			gen_rtvec(2,
				  gen_rtx (SET, VOIDmode, operands[0],
					   gen_rtx (MULT, SFmode, operands[2], operands[0])),
				  gen_rtx (SET, VOIDmode, operands[4], 
					   gen_rtx (MINUS, SFmode, operands[3], operands[4])))));
    emit_insn (gen_rtx (SET, SFmode, operands[0],
			gen_rtx (MULT, SFmode, operands[0], operands[4])));
    emit_insn (gen_rtx (SET, SFmode, operands[4],
			gen_rtx (MULT, SFmode, operands[0], operands[0])));
    emit_insn (gen_rtx (SET, SFmode, operands[4],
			gen_rtx (MULT, SFmode, operands[4], operands[1])));
    emit_insn (gen_rtx (PARALLEL, VOIDmode,
			gen_rtvec(2,
				  gen_rtx (SET, VOIDmode, operands[0],
					   gen_rtx (MULT, SFmode, operands[2], operands[0])),
				  gen_rtx (SET, VOIDmode, operands[4], 
					   gen_rtx (MINUS, SFmode, operands[3], operands[4])))));
    emit_insn (gen_rtx (SET, SFmode, operands[0],
			gen_rtx (MULT, SFmode, operands[0], operands[4])));
    emit_insn (gen_rtx (SET, SFmode, operands[0],
			gen_rtx (MULT, SFmode, operands[0], operands[1])));
    DONE;
}")


;;
;;  ....................
;;
;;  Multiply instructions
;;
;;  ....................

; GCC will generate library calls for the mixed signed
; and unsigned fixed point cases.
;        

(define_insn "mulsi3"
  [(set (match_operand:SI 0 "datareg_operand"          "=d")
	(mult:SI (match_operand:SI 1 "datareg_operand" " d")
		 (match_operand:SI 2 "datareg_operand" " d")))]
  ""
  "%0=%1*%2 (ssi);"
  [(set_attr "type" "compute")])

(define_insn "umulsi3"
  [(set (match_operand:SI 0 "datareg_operand"          "=d")
	(umult:SI (match_operand:SI 1 "datareg_operand" "d")
		  (match_operand:SI 2 "datareg_operand" "d")))]
  ""
  "%0=%1*%2 (uui);"
  [(set_attr "type" "compute")])

(define_insn "muldf3"
  [(set (match_operand:DF 0 "datareg_operand" "=d")
	(mult:DF (match_operand:DF 1 "datareg_operand" "%d")
		 (match_operand:DF 2 "datareg_operand" "d")))]
  "DOUBLE_IS_32"
  "%0=%1*%2;"
  [(set_attr "type" "compute")])


(define_insn "mulsf3"
  [(set (match_operand:SF 0 "datareg_operand" "=d,*d")
 	(mult:SF (match_operand:SF 1 "datareg_operand" "k,*d")
 		 (match_operand:SF 2 "datareg_operand" "b,*d")))]
  ""
  "%0=%1*%2;"
  [(set_attr "type" "comp_mult_float,compute")])


(define_insn "fr_smulsi3"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(unspec
	 [(mult:SI (match_operand:SI 1 "register_operand" "%d")
		   (match_operand:SI 2 "register_operand" "d"))]
	 6))]
  ""
  "%0=%1*%2 (SSFR);"
  [(set_attr "type" "comp_mult_fix")])

;;;;

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
	(fix:SI 
	 (mult:SF
	  (match_operand:SF 1 "register_operand" "d")
	  (match_operand:SI 2 "register_operand" "d"))))]
  ""
  "%0=FIX %1 BY %2;")

(define_expand "fract_float_sf"
  [(set (match_operand:SI 0 "" "")
	(fix:SI 
	 (mult:SF
	  (match_operand:SF 1 "" "")
	  (match_operand:SI 2 "" ""))))

   (use (match_dup 3))]
  ""
  "{
     operands[3] = gen_reg_rtx (SImode);

     emit_insn (gen_negsi2 (operands[3], force_reg (SImode, operands[2])));

     emit_move_insn (operands[0], 
                     gen_rtx (FIX, SImode, 
                            gen_rtx (MULT, SFmode,
                                     force_reg (SFmode, operands[1])),
                                     force_reg (SImode, operands[3])));
     DONE;
   }")


(define_insn ""
  [(set (match_operand:SF 0 "register_operand" "=d")
	(mult:SF
	 (float:SF 
	  (match_operand:SI 1 "register_operand" "d"))
	 (match_operand:SI 2  "register_operand" "d")))]
  ""
  "%0=FLOAT %1 BY %2;")

(define_expand "float_fract_sf"

  [(set (match_operand:SF 0 "" "=d")
	(mult:SF
	 (float:SF 
	  (match_operand:SI 1 "" "d"))
 	  (match_operand:SI 2 "" "")))

   (use (match_dup 3))]

  ""
  "{
     operands[3] = gen_reg_rtx (SImode);

     emit_insn (gen_negsi2 (operands[3], force_reg (SImode, operands[2])));

     emit_insn (gen_mulsf3 (operands[0], 
                            gen_rtx (FLOAT, SFmode, force_reg (SImode, operands[1])),
                            force_reg (SImode, operands[3])));
     DONE;
   }")

;;
;;  ....................
;;
;;  Negate instructions
;;  ....................
;;

(define_insn "negsi2"
  [(set (match_operand:SI 0 "datareg_operand" "=d")
	(neg:SI (match_operand:SI 1 "datareg_operand" "d")))]
  ""
  "%0= -%1;"
  [(set_attr "type" "compute")
   (set_attr "cc" "sets")])

(define_insn "negdm2"
  [(set (match_operand:DM 0 "datareg_operand" "=d")
	(neg:DM (match_operand:DM 1 "datareg_operand" "d")))]
  ""
  "%0= -%1;"
  [(set_attr "type" "compute")
   (set_attr "cc" "sets")])

(define_insn "negpm2"
  [(set (match_operand:PM 0 "datareg_operand" "=d")
	(neg:PM (match_operand:PM 1 "datareg_operand" "d")))]
  ""
  "%0= -%1;"
  [(set_attr "type" "compute")
   (set_attr "cc" "sets")])

(define_insn "negsf2"
  [(set (match_operand:SF 0 "datareg_operand" "=d")
	(neg:SF (match_operand:SF 1 "datareg_operand" "d")))]
  ""
  "%0= -%1;"
  [(set_attr "type" "compute")
   (set_attr "cc" "sets")])

(define_insn ""
  [(set (match_operand:DF 0 "datareg_operand" "=d")
	(neg:DF (match_operand:DF 1 "datareg_operand" "d")))]
  "DOUBLE_IS_32"
  "%0= -%1;"
  [(set_attr "type" "compute")
   (set_attr "cc" "sets")])

;;
;; To negate a double just xor the top word with 0x80000000.
;;
(define_expand "negdf2"
  [(set (subreg:SI (match_operand:DF 0 "register_operand" "") 0)
	(xor:SI (subreg:SI (match_operand:DF 1 "register_operand" "") 0)
		(match_dup 2)
	))
   (set (subreg:SI (match_dup 0) 1)
	(subreg:SI (match_dup 1) 1))]
  ""
  "{
     if (DOUBLE_IS_32) {
        emit_insn(gen_rtx (SET, DFmode, operands[0], gen_rtx(NEG, DFmode, operands[1])));
        DONE;
     }
     operands[2] = GEN_INT ( 0x80000000 );
   }")

;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;

(define_insn "andsi3"
  [(set (match_operand:SI 0 "datareg_operand" "=d")
	(and:SI (match_operand:SI 1 "datareg_operand" "%d")
		(match_operand:SI 2 "datareg_operand" "d")))]
  ""
  "%0=%1 and %2;"
  [(set_attr "type" "compute")
   (set_attr "cc" "sets")])

;;
;;  ....................
;;
;;  Bitwise Or instructions
;;  ....................
;;

(define_insn "iorsi3"
  [(set (match_operand:SI 0 "datareg_operand" "=d")
	(ior:SI (match_operand:SI 1 "datareg_operand" "%d")
		(match_operand:SI 2 "datareg_operand" "d")))]
  ""
  "%0=%1 or %2;"
  [(set_attr "type" "compute")
   (set_attr "cc" "sets")])

(define_insn "iordm3"
  [(set (match_operand:DM 0 "datareg_operand" "=d")
	(ior:DM (match_operand:DM 1 "datareg_operand" "%d")
		(match_operand:DM 2 "datareg_operand" "d")))]
  ""
  "%0=%1 or %2;"
  [(set_attr "type" "compute")
   (set_attr "cc" "sets")])

(define_insn "iorpm3"
  [(set (match_operand:PM 0 "datareg_operand" "=d")
	(ior:PM (match_operand:PM 1 "datareg_operand" "%d")
		(match_operand:PM 2 "datareg_operand" "d")))]
  ""
  "%0=%1 or %2;"
  [(set_attr "type" "compute")
   (set_attr "cc" "sets")])

;;
;;  ....................
;;
;;  Bitwise Xor instructions
;;  ....................
;;

(define_insn "xorsi3"
  [(set (match_operand:SI 0 "datareg_operand" "=d")
	(xor:SI (match_operand:SI 1 "datareg_operand" "%d")
		(match_operand:SI 2 "datareg_operand" "d")))]
  ""
  "%0=%1 xor %2;"
  [(set_attr "type" "compute")
   (set_attr "cc" "sets")])

; flip a single bit.
(define_insn ""
  [(set (match_operand:SI 0 "datareg_operand" "=d")
	(xor:SI (match_operand:SI 1 "datareg_operand" "%d")
		(match_operand 2 "immediate_operand" "i")
	))]
 "((unsigned int)exact_log2(INTVAL(operands[2])) <= 31)"	;; [0..31]
 "*
{
  operands[2] = gen_rtx (CONST_INT, VOIDmode, exact_log2(INTVAL(operands[2])));
  return \"%0=btgl %1 by %2;\";
}"
 [(set_attr "type" "shiftimm")])

;;  ....................
;;
;;  One's complement instructions
;;  For now we'll let GCC generate library calls for
;;  char.
;;
;;  ....................
;;

(define_insn "one_cmplsi2"
  [(set (match_operand:SI 0 "datareg_operand" "=d")
	(not:SI (match_operand:SI 1 "datareg_operand" "d")))]
  ""
  "%0=not %1;"
  [(set_attr "type" "compute")
   (set_attr "cc" "sets")])


;; Put tstsi first among test isns so it matches a CONST_INT operand

(define_insn "tstsi"
  [(set (cc0)
        (match_operand:SI 0 "register_operand" "d"))]
  ""
  "%0=pass %0;"
  [(set_attr "type" "compute")
   (set_attr "mode" "CCSET")
   (set_attr "cc" "compare")])


(define_insn "tstsf"
  [(set (cc0)
        (match_operand:SF 0 "register_operand" "d"))]
  ""
  "%0=pass %0;"
  [(set_attr "type" "compute")
   (set_attr "mode" "CCSET")
   (set_attr "cc" "compare")])

;;
;;  ....................
;;
;;          COMPARISONS
;;
;;  ....................

;;- Order is significant here
;;- because there are untyped
;;- comparisons generated by
;;- the optimizer
;;- (set (cc0)
;;-      (compare (const_int 2)
;;-           (const_int 1)))



;;  rn=fext ra by 0:31;	! clear sign bit to deal with -0
;;  rn=rn or rb;        ! check for zero exp+mantissa
;;  if eq jump(pc,2), else rn=pass ra;	! if not all zeroes, then use the sign-bit
;;  if eq rn=rn+1;      ! Deal with positive denorm by forcing nonzero result

(define_expand "tstdf"
  [(set (subreg:SI (match_dup 1) 0)
	(zero_extract:SI (subreg:SI (match_operand:DF 0 "register_operand" "d") 0)
			 (const_int 31)
			 (const_int 1))		;; start with big-endian bits
    )
   (parallel [(set (cc0)
		   (unspec:SI [(match_dup 1)
			    (subreg:SI (match_dup 0) 0)
			    (subreg:SI (match_dup 0) 1)]
			   5))
	      (clobber (match_dup 1))])]
 ""
 "
{
 operands[1]= gen_reg_rtx(SImode);
  
 if(GET_CODE(operands[0])==SUBREG)
   if(GET_MODE(SUBREG_REG(operands[0]))==DImode)
       operands[0]=SUBREG_REG(operands[0]);
   else
     abort(); /* what else would we apply a (subreg:DF x) to ? */
}")

(define_expand "tstcsi"
  [(set (subreg:SI (match_dup 1) 0)
	(abs:SI (subreg:SI (match_operand:CSI 0 "register_operand" "") 0)))
   (parallel [(set (cc0)
		   (unspec [(match_dup 1)
			    (subreg:SI (match_dup 0) 0)
			    (subreg:SI (match_dup 0) 1)]
			   5))
	     (clobber (match_dup 1))])]
 ""
 "
{
 operands[1]= gen_reg_rtx(SImode);
  
 if(GET_CODE(operands[0])==SUBREG)
   if(GET_MODE (SUBREG_REG(operands[0])) == DImode)
       operands[0] = SUBREG_REG(operands[0]);
   else
     abort(); /* what else would we apply a (subreg:DF x) to ? */
}")

(define_expand "tstsc"
  [(set (subreg:SF (match_dup 1) 0)
	(abs:SF (subreg:SF (match_operand:SC 0 "register_operand" "") 0)))
   (parallel [(set (cc0)
		   (unspec [(match_dup 1)
			    (subreg:SI (match_dup 0) 0)
			    (subreg:SI (match_dup 0) 1)]
			   5))
	     (clobber (match_dup 1))])]
 ""
 "
{
 operands[1]= gen_reg_rtx(SImode);
  
 if(GET_CODE(operands[0])==SUBREG)
   if(GET_MODE (SUBREG_REG(operands[0])) == DImode)
       operands[0] = SUBREG_REG(operands[0]);
   else
     abort(); /* what else would we apply a (subreg:DF x) to ? */
}")

(define_expand "tstdc"
  [(set (subreg:SF (match_dup 1) 0)
	(abs:SF (subreg:SF (match_operand:SC 0 "register_operand" "") 0)))
   (parallel [(set (cc0)
		   (unspec [(match_dup 1)
			    (subreg:SI (match_dup 0) 0)
			    (subreg:SI (match_dup 0) 1)]
			   5))
	     (clobber (match_dup 1))])]
 ""
 "
{
 fprintf (stderr, \"unimplemented tstdc!!!\");
 debug_rtx (operands[0]);
 abort(); /* what else would we apply a (subreg:DF x) to ? */
}")

(define_expand "cmpdf"
 [(set (cc0)
       (compare:DF (match_operand:DF 0 "register_operand" "")
		   (match_operand:DF 1 "register_operand" "")))
  (use (match_dup 2))]
 ""
 "
{
 operands[2] = expand_binop(DFmode,sub_optab,operands[0],operands[1],0,0,OPTAB_LIB);
 emit_insn(GEN_FCN(CODE_FOR_tstdf)(operands[2]));
 DONE;
}")


(define_insn "cmpcsi"
 [(set (cc0)
       (compare:CSI (match_operand:CSI 0 "register_operand" "d")
	            (match_operand:CSI 1 "register_operand" "d")))]
 ""
 "comp (%u0, %u1);\;if eq comp (%b0, %b1);"
 [(set_attr "length" "2")
  (set_attr "mode" "CCSET")
  (set_attr "cc" "compare")])

(define_insn "cmpsc"
 [(set (cc0)
       (compare:SC (match_operand:SC 0 "register_operand" "d")
		   (match_operand:SC 1 "register_operand" "d")))]
 ""
 "comp (%u0, %u1);\;if eq comp (%b0, %b1);"
 [(set_attr "length" "2")
  (set_attr "mode" "CCSET")
  (set_attr "cc" "compare")])

(define_expand "cmpdc"
 [(set (cc0)
       (compare:DC (match_operand:DC 0 "register_operand" "")
	           (match_operand:DC 1 "register_operand" "")))]
 ""
 "
{
 abort ();
 DONE;
}")

(define_insn ""
  [(parallel [(set (cc0)
		   (unspec:SI [(match_operand:SI 0 "general_operand" "=&d")
			    (match_operand:SI 1 "general_operand"  "d")
			    (match_operand:SI 2 "general_operand"  "d")]
			   5))
	      (clobber (match_dup 0))])]
  "ADSP210Z3u"
  "%0=%0 or %2;\; if eq jump(pc,2), else %0=pass %1;\;if eq %0=%0+1;"
  [(set_attr "length" "3")]
)

;; For 21020, no if jump, else compute
;;
(define_insn ""
  [(parallel [(set (cc0)
		   (unspec:SI [(match_operand:SI 0 "general_operand" "=&d")
			    (match_operand:SI 1 "general_operand"  "d")
			    (match_operand:SI 2 "general_operand"  "d")]
			   5))
	      (clobber (match_dup 0))])]
  "!ADSP210Z3u"
  "%0=%0 or %2;\; if eq jump(pc,3);\;%0=pass %1;\;if eq %0=%0+1;"
  [(set_attr "length" "4")]
)


(define_expand "cmpsi"
 [(set (cc0)
   (compare (match_operand:SI 0 "register_operand" "d")
    (match_operand:SI 1 "register_operand" "d")))
  (use (match_operand:SI 2 "" ""))]
 ""
 "
{
  switch(GET_CODE(operand2))
    {
    case LTU:
    case LEU:
    case GTU:
    case GEU:	
      emit (gen_rtx (PARALLEL, VOIDmode,
		     gen_rtvec (2,
				gen_rtx (SET, VOIDmode, gen_reg_rtx(SImode), 
					 gen_rtx (MINUS, SImode, operand0, 
						  operand1)),
				gen_rtx (SET, VOIDmode, cc0_rtx, 
					 gen_rtx (COMPARE, VOIDmode, 
						  operand0, 
						  operand1)))));
      DONE;
      break;
    case LT:
    case LE:
    case GT:
    case GE:
    case EQ:
    case NE:
      emit_insn (gen_rtx (SET, VOIDmode, cc0_rtx, 
			  gen_rtx (COMPARE, VOIDmode, operand0, operand1)));
      DONE;
      break;	
    default:
      abort();
    }
}")
	
;  I specifically removed all references to r2 in the machine description.
;  Please do *not* put any in without consulting with me.  Thanks, josh */

(define_insn ""
  [(set (cc0)
	(compare (match_operand:SI 0 "register_operand" "d,d")
		 (match_operand:SI 1 "register_operand" "d,O")))]
  ""
  "@
   comp(%0,%1);
   %0=pass %0;"
 [(set_attr "type" "compute")
  (set_attr "mode" "CCSET")
  (set_attr "cc" "compare")])

(define_insn ""
   [(parallel [(set (match_operand:SI 0 "register_operand" "=*d,d")
		   (minus:SI (match_operand:SI 1 "register_operand" "*d,c")
			     (match_operand:SI 2 "register_operand" "*d,l")))
	      (set (cc0)
		   (compare (match_dup  1)
			     (match_dup 2)))])]
  ""
  "%0=%1-%2;"
 [(set_attr "type" "compute,comp_alu_fix")
  (set_attr "mode" "CCSET")
  (set_attr "cc" "compare,compare")])

(define_insn "cmpsf"
  [(set (cc0)
	(compare (match_operand:SF 0 "register_operand" "d,d")
	         (match_operand:SF 1 "register_operand" "d,O")))]
  ""
  "@
   comp(%0,%1);
   %0=pass %0;"
  [(set_attr "type" "compute")
   (set_attr "mode" "CCSET")
   (set_attr "cc" "compare")])

; -------------------- md.ctl ----------------
;
;   %? -- is the db for CALLS to setup for the called routine
;   %! -- is the db for branches.
;   %^ -- is the number of instructions to skip for an unsigned branch
;         it is used to skip the delayed branch fields.
; 

;; Try to match some of the simple
;; -- if cond do this
;; If we get some of this right then

(define_expand "beq"
  [(set (pc)
	(if_then_else (eq (cc0) (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		    (pc)))]
  "" "")
(define_expand "bne"
  [(set (pc)
	(if_then_else (ne (cc0) (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		    (pc)))]
  "" "")
(define_expand "bgt"
  [(set (pc)
	(if_then_else (gt (cc0) (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		    (pc)))]
  "" "")
(define_expand "blt"
  [(set (pc)
	(if_then_else (lt (cc0) (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		    (pc)))]
  "" "")
(define_expand "bge"
  [(set (pc)
	(if_then_else (ge (cc0) (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		    (pc)))]
  "" "")
(define_expand "ble"
  [(set (pc)
	(if_then_else (le (cc0) (const_int 0)) 
		      (label_ref (match_operand 0 "" ""))
		    (pc)))]
  "" "")
;;;
;;;
;;;-----------------UNSIGNED COMPARISONS...
;;;
;;; After deciding that the 21k compiler i.e. CC21k was wrong GAS/MMH fixed this
;;; to include the case of equality.
;;;
(define_expand "bgtu"
  [(set (pc)
	(if_then_else (gtu (cc0) (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		    (pc)))]
  "" "")
(define_expand "bltu"
  [(set (pc)
	(if_then_else (ltu (cc0) (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		    (pc)))]
  "" "")
(define_expand "bgeu"
  [(set (pc)
	(if_then_else (geu (cc0) (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		    (pc)))]
  "" "")
(define_expand "bleu"
  [(set (pc)
	(if_then_else (leu (cc0) (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		    (pc)))]
  "" "")

;;;
;;; Scc
;;;

(define_insn "seq"
  [(set (match_operand:SI 0 "general_operand" "=r") (eq:SI (cc0) (const_int 0)))]
  ""
  "*
   if (!shift_or_mult_cc_p (EQ))
     return 0;  /* need a test */
   return \"%0=m5;\;if %- %0=m6;\";
  "
  [(set_attr "length" "2")]
)

(define_insn "sne"
  [(set (match_operand:SI 0 "general_operand" "=r") (ne:SI (cc0) (const_int 0)))]
  ""
  "*
   if (!shift_or_mult_cc_p (NE))
     return 0;  /* need a test */
   return \"%0=m5;\;if %~ %0=m6;\";
  "
  [(set_attr "length" "2")]
)
(define_insn "sgt"
  [(set (match_operand:SI 0 "general_operand" "=r") (gt:SI (cc0) (const_int 0)))]
  ""
  "*
   if (!shift_or_mult_cc_p (GT))
     return 0;  /* need a test */
   return \"%0=m5;\;if gt %0=m6;\";
  "
  [(set_attr "length" "2")]
)
(define_insn "slt"
  [(set (match_operand:SI 0 "general_operand" "=r") (lt:SI (cc0) (const_int 0)))]
  ""
  "*
   if (!shift_or_mult_cc_p (LT))
     return 0;  /* need a test */
   return \"%0=m5;\;if lt %0=m6;\";
  "
  [(set_attr "length" "2")]
)
(define_insn "sge"
  [(set (match_operand:SI 0 "general_operand" "=r") (ge:SI (cc0) (const_int 0)))]
  ""
  "*
   if (!shift_or_mult_cc_p (GE))
     return 0;  /* need a test */
   return \"%0=m5;\;if ge %0=m6;\";
  "
  [(set_attr "length" "2")]
)
(define_insn "sle"
  [(set (match_operand:SI 0 "general_operand" "=r") (le:SI (cc0) (const_int 0)))]
  ""
  "*
   if (!shift_or_mult_cc_p (LE))
     return 0;  /* need a test */
   return \"%0=m5;\;if le %0=m6;\";
  "
  [(set_attr "length" "2")]
)

(define_insn "sgtu"
  [(set (match_operand:SI 0 "general_operand" "=r") (gtu:SI (cc0) (const_int 0)))]
  ""
  "*
   if (!shift_or_mult_cc_p (GTU))
     return 0;  /* need a test */
   return \"%0=m6;\;if eq %0=m5;\;if not ac %0=m5;\";
  "
  [(set_attr "length" "3")]
)

(define_insn "sltu"
  [(set (match_operand:SI 0 "general_operand" "=r") (ltu:SI (cc0) (const_int 0)))]
  ""
  "*
   if (!shift_or_mult_cc_p (LTU))
     return 0;  /* need a test */
   return \"%0=m6;\;if ac %0=m5;\;if eq %0=m5;\";
  "
  [(set_attr "length" "3")]
)

(define_insn "sgeu"
  [(set (match_operand:SI 0 "general_operand" "=r") (geu:SI (cc0) (const_int 0)))]
  ""
  "*
   if (!shift_or_mult_cc_p (GEU))
     return 0;  /* need a test */
   return \"%0=m5;\;if ac %0=m6;\;if eq %0=m6;\";
  "
  [(set_attr "length" "3")]
)

(define_insn "sleu"
  [(set (match_operand:SI 0 "general_operand" "=r") (leu:SI (cc0) (const_int 0)))]
  ""
  "*
   if (!shift_or_mult_cc_p (LEU))
     return 0;  /* need a test */
   return \"%0=m5;\;if not ac %0=m6;\;if eq %0=m6;\";
  "
  [(set_attr "length" "3")]
)


;;; doloop jumps are in front of the rest because they
;;; should be checked first, so that other patterns do not have
;;; to check whether the jump is that of a doloop.

(define_insn ""
  [(set (pc)
	(if_then_else
	 (match_operator 0 "comparison_operator"
			 [(match_operand 1 "doloop_cc0_p" "")
			  (const_int 0)])
	 (label_ref (match_operand 0 "" ""))
	 (pc)))]
  "doloop_jump_p(insn)"
  "*
	if (tight_doloop_end_p(insn))
          return \"nop;\";
	if (continued_doloop_p(insn))
          return \"nop;\";
	else
	  return \"\";
	"
  [(set_attr "type" "doloop_jump")])


(define_insn ""
  [(set (pc)
	(if_then_else
	 (match_operator 0 "comparison_operator"
			 [(match_operand 1 "doloop_cc0_p" "")
			  (const_int 0)])
	 (pc)
	 (label_ref (match_operand 0 "" ""))
	))]
  "doloop_jump_p(insn)"
  "*
	if (tight_doloop_end_p(insn))
          return \" NOP; !! Tight (Reversed) Loop Jump Was Here \";
	else
          return \"      !!  (Reversed) Loop Jump Was Here \";
	"
  [(set_attr "type" "doloop_jump")])


;;;
;;; INSNS
;;;
;;; Note that we removed double jumps by zapping the condition codes
;;; so that we can fill delay slots.
;;;
;;;	LTU == NOT C AND NOT Z
;;;	GTU == C AND NOT Z
;;;	GEU == C OR Z
;;;	LEU == Z OR NOT C

(define_insn ""
  [(set (pc)
	(if_then_else (gtu (cc0) (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		    (pc)))]
  ""
  "*
   if (!shift_or_mult_cc_p (GTU))
     return 0;
   return \"if eq comp(r0,r0);\;if ac jump (pc, %l0)%!;\";
  "
  [(set_attr "type" "branch")
   (set_attr "length" "2")]
)

(define_insn ""
  [(set (pc)
	(if_then_else (leu (cc0) (const_int 0))
		      (pc)
		    (label_ref (match_operand 0 "" ""))))]
  ""
  "*
   if (!shift_or_mult_cc_p (LEU))
     return 0;
   return \"if eq comp(r0,r0);\;if ac jump (pc, %l0)%!;\";
  "
  [(set_attr "type" "branch")
   (set_attr "length" "2")]
)

(define_insn ""
  [(set (pc)
	(if_then_else (leu (cc0) (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		    (pc)))]
  ""
  "*
   if (!shift_or_mult_cc_p (LEU))
     return 0;
   return \"if not ac comp(r0,r0);\; if eq jump (pc, %l0)%!;\";
  "
  [(set_attr "type" "branch")
   (set_attr "length" "2")]
)

(define_insn ""
  [(set (pc)
	(if_then_else (gtu (cc0) (const_int 0))
		      (pc)
 		    (label_ref (match_operand 0 "" ""))))]
  ""
  "*
   if (!shift_or_mult_cc_p (GTU))
     return 0;
   return \"if not ac comp(r0,r0);\; if eq jump (pc, %l0)%!;\";
  "
  [(set_attr "type" "branch")
   (set_attr "length" "2")]
)

(define_insn ""
  [(set (pc)
	(if_then_else (ltu (cc0) (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		    (pc)))]
  ""
  "*
   if (!shift_or_mult_cc_p (LTU))
     return 0;
   return \"if ac comp(r0,r0);\; if ne jump (pc, %l0)%!;\";
  "
  [(set_attr "type" "branch")
   (set_attr "length" "2")]
)

(define_insn ""
  [(set (pc)
	(if_then_else (geu (cc0) (const_int 0))
		      (pc)
		    (label_ref (match_operand 0 "" ""))))]
  ""
  "*
   if (!shift_or_mult_cc_p (GEU))
     return 0;
   return \"if ac comp(r0,r0);\;if ne jump (pc, %l0)%!;\";
  "
  [(set_attr "type" "branch")
   (set_attr "length" "2")]
)

(define_insn ""
  [(set (pc)
	(if_then_else (geu (cc0) (const_int 0))
		      (label_ref (match_operand 0 "" ""))
		    (pc)))]
  ""
  "*
   if (!shift_or_mult_cc_p (GEU))
     return 0;
   return \"if ac comp(r0,r0);\; if eq jump (pc, %l0)%!;\";
  "
  [(set_attr "type" "branch")
   (set_attr "length" "2")]
)

(define_insn ""
  [(set (pc)
	(if_then_else (ltu (cc0) (const_int 0))
		      (pc)
		    (label_ref (match_operand 0 "" ""))))]
  ""
  "*
   if (!shift_or_mult_cc_p (LTU))
     return 0;
   return \"if ac comp(r0,r0);\; if eq jump (pc, %l0)%!;\";
  "
  [(set_attr "type" "branch")
   (set_attr "length" "2")]
)


;; Define both directions of branch and return.

;; jumps at the end of doloop should not produce any assembler
;; code, but should do some useful checking instead.


;;  SZ or MS flag for conditional branches
(define_insn ""
  [(set (pc)
	(if_then_else (match_operator 1 "comparison_operator"
				      [(cc0) (const_int 0)])
		      (label_ref (match_operand 0 "" ""))
		      (pc)))]
  ""
  "*
  if ( !shift_or_mult_cc_p (GET_CODE (operands[1])))
    return 0;
  else
    return \"if %j1 jump (pc, %l0) %!;\";
  "
  [(set_attr "type" "branch")])

;; SZ or MS flag for reverse conditional branch
(define_insn ""
  [(set (pc)
	(if_then_else (match_operator 1 "signed_comparison_operator"
				[(cc0) (const_int 0)])
		      (pc)
		      (label_ref (match_operand 0 "" ""))))]
  ""
  "*
  if ( !shift_or_mult_cc_p (GET_CODE (operands[1])))
    return 0;
  else
    return \"if %J1 jump (pc, %l0) %!;\";
  "
  [(set_attr "type" "branch")])

;;
;; Unconditional and other jump instructions
;;
;; Branches that are indirect have two forms.
;; the first is the trival case just jump indirect
;; the second is with a pcrel stub.
;;;
;;; lab: rreg=PC;
;;;      rreg=address-rreg
;;;      mreg=lab;
;;;      ireg=rreg;
;;;      jump (mreg,ireg) (db);
;;;
;;;  operands[4] = gen_label_rtx();
;;;  return \"%L4%3=PC;\n\t;%3=%0-%3;\n\t%1=%4;\n\t%2=%3;\n\tjump (%1,%2) %!;\";
;;;
;;; The reader will notice that I have used the define_expand to add extra scratch
;;; register usage to these indirect jumps so there is below two insn's for each indirect
;;; jump.  1. the non-pcrel
;;;        2. the pcrel version.
;;;

(define_insn "jump"
  [(set (pc)
	(label_ref (match_operand 0 "" "")))]
  ""
  "jump (pc, %l0) %!;"
  [(set_attr "type" "branch")])

;;; Table jumps.

(define_insn ""
  [(set (pc) 
	(mem:PM 
	 (plus:PM (match_operand:PM 0 "register_operand" "y")
		  (match_operand:PM 1 "register_operand" "z"))))
   (use (label_ref:PM (match_operand:PM 2 "" "")))]
  ""
  "jump (%1,%0); %&"
  [(set_attr "type" "tablejump")
   (set_attr "length" "3")])

(define_insn ""
  [(set (pc) 
	(mem:PM (match_operand:PM 0 "register_operand" "y")))
   (use (label_ref:PM (match_operand:PM 2 "" "")))]
  ""
  "jump (m13,%0); %&"
  [(set_attr "type" "tablejump")
   (set_attr "length" "3")])

(define_insn ""
  [(set (pc) 
	(mem:PM 
	 (plus:PM (match_operand:PM 0 "register_operand" "d")
		  (match_operand:PM 1 "register_operand" "&y"))))
   (use (label_ref:PM (match_operand:PM 2 "" "")))
   (clobber (match_operand:PM 3  "register_operand" "z"))
   (clobber (match_operand:PM 4  "register_operand" "y"))
   (clobber (match_operand:SI 5  "register_operand" "d"))]
  ""
  "*operands[6] = gen_label_rtx();
   return \"%L6%5=PC;\;%5=%0-%5;\;modify(%1,%6);\;%3=%5;\;jump (%3,%1);\; %&\";"
  [(set_attr "type" "tablejump")
   (set_attr "length" "7")])


(define_insn ""
  [(set (pc) 
	(match_operand:PM 0 "immediate_operand" "i"))
   (use (label_ref:PM (match_operand:PM 1 "" "")))]
  ""
  "jump (m13,%0); %&"
  [(set_attr "type" "tablejump")
   (set_attr "length" "3")])

(define_insn ""
  [(set (pc) 
	(match_operand:PM 0 "immediate_operand" "i"))
   (use (label_ref:PM (match_operand:PM 1 "" "")))
   (clobber (match_operand:PM 2  "register_operand" "z"))
   (clobber (match_operand:PM 3  "register_operand" "y"))
   (clobber (match_operand:SI 4  "register_operand" "d"))]
  "0"
  "*operands[6] = gen_label_rtx();
   return \"%L6%4=PC;\;modify(%2, -%0);\;%3=-%6;\;jump (%3,%2);\; %&\";"
  [(set_attr "type" "tablejump")
   (set_attr "length" "6")])


(define_insn ""
  [(set (pc) 
	(mem:PM (match_operand:PM 0 "register_operand" "d")))
   (use (label_ref:PM (match_operand:PM 1 "" "")))
   (clobber (match_operand:PM 2  "register_operand" "z"))
   (clobber (match_operand:PM 3  "register_operand" "y"))
   (clobber (match_operand:SI 4  "register_operand" "d"))]
  ""
  "*operands[5] = gen_label_rtx();
   return \"%L5%4=PC;\;%4=%0-%4;\;%2=%5;\;%3=%4;\;jump (%2,%3);\; %&\";"
  [(set_attr "type" "tablejump")
   (set_attr "length" "7")])


(define_expand "tablejump"
  [(parallel [(set (pc) 
	          (mem:PM (match_operand:PM 0 "register_operand" "y")))
              (use (label_ref:PM (match_operand:PM 1 "" "")))])]
  ""
  "
     if (PCREL_ONLY)
        {
          emit_jump_insn 
	    (gen_rtx (PARALLEL, VOIDmode,
		      gen_rtvec (5,
			         gen_rtx (SET, VOIDmode, pc_rtx, 
                                          gen_rtx (MEM, PMmode, operand0)),
		                 gen_rtx (USE, VOIDmode, 
                                          gen_rtx (LABEL_REF, PMmode, operand1)),
                                 gen_rtx (CLOBBER, VOIDmode, gen_reg_rtx (PMmode)),
                                 gen_rtx (CLOBBER, VOIDmode, gen_reg_rtx (PMmode)),
                                 gen_rtx (CLOBBER, VOIDmode, gen_reg_rtx (SImode))
                                 )));
	     DONE;
	}")




;;; Indirect jumps
(define_insn ""
  [(set (pc) 
	(match_operand:PM 0 "register_operand" "y"))]
  ""
  "jump (m13,%0) %!;"
  [(set_attr "type" "branch")])

(define_insn ""
  [(set (pc) 
	(subreg:DM (match_operand:PM 0 "register_operand" "y") 0))]
  ""
  "jump (m13,%0) %!;"
  [(set_attr "type" "branch")])

(define_insn ""
  [(set (pc) 
	(match_operand:PM 0 "register_operand" "d"))
   (clobber (match_operand:PM 1  "register_operand" "z"))
   (clobber (match_operand:PM 2  "register_operand" "y"))
   (clobber (match_operand:SI 3  "register_operand" "d"))]
  ""
  "*
{
  operands[4] = gen_label_rtx();
  return \"%L4%3=PC;\;%3=%0-%3;\;%1=%4;\;%2=%3;\;jump (%1,%2) %!;\;\";
}"
  [(set_attr "type" "branch")
   (set_attr "length" "5" )])

(define_expand "indirect_jump"
  [(set (pc) 
	(match_operand:PM 0 "register_operand" "&y"))]
  ""
  "{
     if (PCREL_ONLY)
        {
          emit_jump_insn 
	    (gen_rtx (PARALLEL, VOIDmode,
		      gen_rtvec (4,
				 gen_rtx (SET, VOIDmode, PC,
					  operands[0]),
                                 gen_rtx (CLOBBER, VOIDmode, gen_reg_rtx (PMmode)),
                                 gen_rtx (CLOBBER, VOIDmode, gen_reg_rtx (PMmode)),
                                 gen_rtx (CLOBBER, VOIDmode, gen_reg_rtx (SImode))
                                 )));
	     DONE;
	}
   }")

;; Subroutine calls (without return value)


(define_insn ""
  [(set (match_operand 0 "register_operand" "=d")
	(call (mem:PM (match_operand:PM 1 "register_operand" "bcl"))
	      (match_operand 2 "general_operand" "g")))]
  "PCREL_ONLY"
  "*jjb_output_indirect_call(operands[1], insn); RET;"
  [(set_attr "type" "call")])

(define_insn ""
  [(call (mem:PM (match_operand:PM 0 "register_operand" "bcl"))
	 (match_operand 1 "general_operand" "g"))]
  "PCREL_ONLY"
  "*jjb_output_indirect_call (operands[0], insn); RET;"
  [(set_attr "type" "call")])

(define_insn ""
  [(set (match_operand 0 "register_operand" "=d")
	(call (mem:PM (match_operand:PM 1 "register_operand" "y"))
	      (match_operand 2 "general_operand" "g")))]
  ""
  "*jjb_output_indirect_call(operands[1], insn); RET;"
  [(set_attr "type" "call")])

(define_insn ""
  [(call (mem:PM (match_operand:PM 0 "register_operand" "y"))
	 (match_operand 1 "general_operand" "g"))]
  ""
  "*jjb_output_indirect_call (operands[0], insn); RET;"
  [(set_attr "type" "call")])

(define_insn ""
  [(set (match_operand 0 "register_operand" "=d")
	(call (match_operand:PM 1 "memory_operand" "")
	      (match_operand 2 "general_operand" "g")))]
  ""
  "*jjb_output_call (operands[1], insn); RET;"
  [(set_attr "type" "call")])

(define_insn ""
  [(call (match_operand:PM 0 "memory_operand" "")
	      (match_operand 1 "general_operand" "g"))]
  ""
  "*jjb_output_call (operands[0], insn); RET;"
  [(set_attr "type" "call")])

(define_expand "call"
  [(call (match_operand:PM 0 "memory_operand" "mi")
	 (match_operand 1 "general_operand" "g"))]
  ""
  "{
     if (GET_CODE (operands[0]) == MEM
	 && REG_P (XEXP (operands[0], 0))
	 && GET_MODE (XEXP (operands[0], 0)) != DEFAULT_CODE_Pmode)
     {
      rtx insn,reg;
      reg = gen_reg_rtx (DEFAULT_CODE_Pmode); 
      insn = emit_move_insn (reg, XEXP (operands[0],0));
      operands[0] = gen_rtx (MEM, DEFAULT_CODE_Pmode, reg);
     }
  }"
)
 
;; Call subroutine, returning value in operand 0
;; (which must be a hard register).

(define_expand "call_value"
  [(set (match_operand 0 "register_operand" "=d")
	(call (match_operand:PM 1 "memory_operand" "")
	      (match_operand 2 "general_operand" "g")))]
  ""
  "
{
  if (GET_CODE (operands[1])==MEM 
      && REG_P (XEXP (operands[1],0))
      && GET_MODE (XEXP (operands[1],0)) != DEFAULT_CODE_Pmode) 
    {
      rtx insn,reg;
      reg = gen_reg_rtx (DEFAULT_CODE_Pmode); 
      insn = emit_move_insn (reg, XEXP (operands[1],0));
      operands[1] = gen_rtx (MEM, DEFAULT_CODE_Pmode, reg);
    }
}")


(define_insn "nop"
  [(const_int 0)]
  ""
  "nop;"
  [(set_attr "cc" "unchanged")
   (set_attr "type" "misc")])

;;
;; Conversions between fixed point and floating point

;;
;;- floating point conversions
;;

(define_insn "floatsisf2"
  [(set (match_operand:SF 0 "register_operand" "=d")
	(float:SF (match_operand:SI 1 "register_operand" "d")))]
  ""
  "%0=float %1;"
  [(set_attr "type" "compute")])


(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
	(fix:SI (match_operand:SF 1 "register_operand" "d")))]
  "!TRUNC_060_BUG && ADSP210Z3u"
  "%0=TRUNC %1;"
  [(set_attr "type" "compute")])
;; "comp_alu_float" changed because of 1830 which reveals that B-81 makes no claims 
;;                  about me.


(define_insn ""
  [(parallel [(set (match_operand:SI 0 "register_operand" "=&d")
		   (fix:SI (match_operand:SF 1 "register_operand" "d")))
	      (clobber (match_operand:SI 2 "register_operand" "d"))])]
  ""
  "%0=0xff800000;\;%2=logb %1;\;%2=-%2;\;%0=ashift %0 by %2;\;%0=%r1 and %0;\;%0=fix %f0;"
  [(set_attr "length" "6")])

(define_expand "fix_truncsfsi2"
  [(parallel [(set (match_operand:SI 0 "register_operand" "")
		   (fix:SI (match_operand:SF 1 "register_operand" "d")))
	      (clobber (match_dup 2))])]
  ""
  "
{
  if (!TRUNC_060_BUG && ADSP210Z3u)
    {
       emit_insn (gen_rtx (SET, SImode, operands[0],
				gen_rtx (FIX, SImode, operands[1], operands[2])));
       DONE;
    }
  operands[2]=gen_reg_rtx(SImode);
}
")

(define_expand "fixuns_truncsfsi2"
  [(parallel [(set (match_operand:SI 0 "register_operand" "")
		   (fix:SI (match_operand:SF 1 "register_operand" "d")))
	      (clobber (match_dup 2))])]
  ""
  "
{
  if (!TRUNC_060_BUG && ADSP210Z3u)
    {
       emit_insn (gen_rtx (SET, SImode, operands[0],
				gen_rtx (FIX, SImode, operands[1], operands[2])));
       DONE;
    }
  operands[2]=gen_reg_rtx(SImode);
}
")
	
;(define_insn "fix_truncsfsi2"
;  [(set (match_operand:SI 0 "register_operand" "=&d")
;	(fix:SI (match_operand:SF 1 "register_operand" "d")))]
;  ""
;  "BIT SET MODE1 0x8000;\; %f0=abs %1;\;%0=fix %f0;\;BIT CLR MODE1 0x8000;\;%1=pass %1;\;if lt %0=-%0;"
;  [(set_attr "length" "6")])  


;(define_insn "fixuns_truncsfsi2"
;  [(set (match_operand:SI 0 "register_operand" "=&d")
;	(unsigned_fix:SI (match_operand:SF 1 "register_operand" "d")))]
;   ""
;   "BIT SET MODE1 0x8000;\;%f0=abs %1;\;%0=fix %f0;\;BIT CLR MODE1 0x8000;\;%1=pass %1;\;if lt %0=-%0; "
;   [(set_attr "length" "6")])

;;
;; Sign extension instructions
;;
;;
;; ...........................
;;
;; Zero Extension instructions
;;
;; ...........................
;;
;;  ....................
;;
;;  And instructions
;;  For now we'll let GCC generate library calls for
;;  char.
;;
;;  ....................
;;

;; Rn = BCLR Rx BY Ry
;;
;;  Rx = Rx & ~(1 << Ry)
;;
;;  a = 1 << Ry
;;  b = not a
;;  rx = rx and b
;;
(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
	(and:SI (match_operand:SI 1 "register_operand" "%d")
		(not:SI (ashift:SI (const_int 1)
				   (match_operand:SI 2 "register_operand" "d")))))]
  ""
  "%0=bclr %1 by %2;"
  [(set_attr "type" "compute")
   (set_attr "cc" "shift")
  ])

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
	(and:SI (match_operand:SI 1 "register_operand" "%d")
		(not:SI (lshift:SI (const_int 1)
				   (match_operand:SI 2 "register_operand" "d")))))]
  ""
  "%0=bclr %1 by %2;"
  [(set_attr "type" "compute")
   (set_attr "cc" "shift")
  ])


;;
;; Rn = BSET Rx BY Ry
;;    
;;  Rx = Rx | (1 << Ry)   
;;
(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
	(ior:SI (match_operand:SI 1 "register_operand" "d")
		(ashift:SI (match_operand:SI 2 "" "")
			   (match_operand:SI 3 "register_operand" "d"))))]
  "is_constant_1p(operands[2],insn)"
  "%0=bset %1 by %3;"
  [(set_attr "type" "compute")
   (set_attr "cc" "shift")
  ])


(define_insn""
  [(set (match_operand:SI 0 "register_operand" "=d,d")
	(ior:SI (match_operand:SI 1 "register_operand" "d,d")
		(lshift:SI (match_operand:SI 2 "" "")
			   (match_operand:SI 3 "nonmemory_operand" "d,L"))))]
  "is_constant_1p(operands[2],insn)"
  "%0=bset %1 by %3;"
  [(set_attr "type" "compute,shiftimm")
   (set_attr "cc" "shift")
  ])


;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; Rn = Rn OR LSHIFT Rx BY Ry
;; Rn = Rn OR ASHIFT Rx BY Ry
;;
;;   (set (reg:SI a) (lshift:SI (reg:SI Rx) (reg:SI Ry)))
;;
;;   (set (reg:SI Rn) (or:SI (reg:SI Rn) (reg:SI a)))
;;
;;   ---
;;   (set (reg:SI Rn)
;;        (or:SI (reg:SI Rn)
;;               (lshift:SI (reg:SI Rx) (reg:SI Ry))))
(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d,d")
	(ior:SI (lshift:SI (match_operand:SI 1 "register_operand" "d,d")
			   (match_operand:SI 2 "nonmemory_operand" "d,L"))
		(match_dup 0)))]
  ""
  "%0=%0 or lshift %1 by %2;"
  [(set_attr "type" "compute,shiftimm")
   (set_attr "cc" "shift")
  ])


(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d,d")
	(ior:SI (ashift:SI (match_operand:SI 1 "register_operand" "d,d")
			   (match_operand:SI 2 "nonmemory_operand" "d,L"))
		(match_dup 0)))]
  ""
  "%0=%0 or ashift %1 by %2;"
  [(set_attr "type" "compute,shiftimm")
   (set_attr "cc" "shift")
  ])


;;
;;  ....................
;;
;;  Arithmetic shift instructions
;;  For now we'll let GCC generate library calls for
;;  char.
;;
;;  ....................
;;

;; We can use L (any 8-bit constant) because
;; the  shift instructions only the bottom 8 bits of
;; the immediate

(define_insn "ashlsi3"
  [(set (match_operand:SI 0 "register_operand" "=d,d")
	(ashift:SI (match_operand:SI 1 "register_operand" "d,d")
		   (match_operand:SI 2 "nonmemory_operand" "d,L")))]
  ""
  "%0=ashift %1 by %2;"
  [(set_attr "type" "compute,shiftimm")
   (set_attr "cc" "shift")
  ])

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d,d")
	(ashiftrt:SI (match_operand:SI 1 "register_operand" "d,d")
		     (neg:SI (match_operand:SI 2 "nonmemory_operand" "d,L"))))]
  ""
  "%0=ashift %1 by %2;"
  [(set_attr "type" "compute,shiftimm")
   (set_attr "cc" "shift")
  ])


(define_expand "ashrsi3"
  [(set (match_operand:SI 0 "register_operand" "")
	(ashiftrt:SI (match_operand:SI 1 "register_operand" "")
		   (neg:SI (match_operand:SI 2 "nonmemory_operand" ""))))]
  ""
  "
{
   rtx x = operands[2];
   if( GET_CODE(x) != CONST_INT )
      emit_insn (gen_rtx (SET, SImode, operands[2] = gen_reg_rtx(SImode),
 	         gen_rtx (NEG, SImode, x)));
   else
	operands[2] = gen_rtx(CONST_INT, SImode, -INTVAL(x));
}")

					       

;;- logical shift instructions


(define_insn "lshldm3"
  [(set (match_operand:DM 0 "register_operand" "=d,d")
	(lshift:DM (match_operand:DM 1 "register_operand" "d,d")
		   (match_operand:DM 2 "nonmemory_operand" "d,L")))]
  ""
  "%0=lshift %1 by %2;"
  [(set_attr "type" "compute,shiftimm")
   (set_attr "cc" "shift")
  ])

(define_insn "lshlpm3"
  [(set (match_operand:PM 0 "register_operand" "=d,d")
	(lshift:PM (match_operand:PM 1 "register_operand" "d,d")
		   (match_operand:PM 2 "nonmemory_operand" "d,L")))]
  ""
  "%0=lshift %1 by %2;"
  [(set_attr "type" "compute,shiftimm")
   (set_attr "cc" "shift")
  ])

(define_insn "lshlsi3"
  [(set (match_operand:SI 0 "register_operand" "=d,d")
	(lshift:SI (match_operand:SI 1 "register_operand" "d,d")
		   (match_operand:SI 2 "nonmemory_operand" "d,L")))]
  ""
  "%0=lshift %1 by %2;"
  [(set_attr "type" "compute,shiftimm")
   (set_attr "cc" "shift")
  ])

(define_insn ""
  [(set (match_operand:DM 0 "register_operand" "=d,d")
	(lshiftrt:DM (match_operand:DM 1 "register_operand" "d,d")
		     (neg:DM (match_operand:DM 2 "nonmemory_operand" "d,L"))))]
  ""
  "%0=lshift %1 by %2;"
  [(set_attr "type" "compute,shiftimm")
   (set_attr "cc" "shift")
  ])

(define_insn ""
  [(set (match_operand:PM 0 "register_operand" "=d,d")
	(lshiftrt:PM (match_operand:PM 1 "register_operand" "d,d")
		   (neg:PM (match_operand:PM 2 "nonmemory_operand" "d,L"))))]
  ""
  "%0=lshift %1 by %2;"
  [(set_attr "type" "compute,shiftimm")
   (set_attr "cc" "shift")
  ])

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d,d")
	(lshiftrt:SI (match_operand:SI 1 "register_operand" "d,d")
		     (neg:SI (match_operand:SI 2 "nonmemory_operand" "d,L"))))]
  ""
  "%0=lshift %1 by %2;"
  [(set_attr "type" "compute,shiftimm")
   (set_attr "cc" "shift")
  ])

(define_expand "lshrsi3"
  [(set (match_operand:SI 0 "register_operand" "")
	(lshiftrt:SI (match_operand:SI 1 "register_operand" "")
		     (neg:SI (match_operand:SI 2 "nonmemory_operand" ""))))]
  ""
  "
{
   rtx x = operands[2];
   if( GET_CODE(x) != CONST_INT )
      emit_insn (gen_rtx (SET, SImode, operands[2] = gen_reg_rtx(SImode),
 	         gen_rtx (NEG, SImode, x)));
   else
	operands[2] = gen_rtx(CONST_INT, SImode, -INTVAL(x));
}")

(define_expand "lshrdm3"
  [(set (match_operand:DM 0 "register_operand" "")
	(lshiftrt:DM (match_operand:DM 1 "register_operand" "")
		     (neg:DM (match_operand:DM 2 "nonmemory_operand" ""))))]
  ""
  "
{
   rtx x = operands[2];
   if( GET_CODE(x) != CONST_INT )
      emit_insn (gen_rtx (SET, DMmode, operands[2] = gen_reg_rtx(DMmode),
 	         gen_rtx (NEG, DMmode, x)));
   else
	operands[2] = gen_rtx(CONST_INT, DMmode, -INTVAL(x));
}")

(define_expand "lshrpm3"
  [(set (match_operand:PM 0 "register_operand" "")
	(lshiftrt:PM (match_operand:PM 1 "register_operand" "")
		     (neg:PM (match_operand:PM 2 "nonmemory_operand" ""))))]
  ""
  "
{
   rtx x = operands[2];
   if( GET_CODE(x) != CONST_INT )
      emit_insn (gen_rtx (SET, PMmode, operands[2] = gen_reg_rtx(PMmode),
 	         gen_rtx (NEG, PMmode, x)));
   else
	operands[2] = gen_rtx(CONST_INT, PMmode, -INTVAL(x));
}")

;; Rn = ROT Rx BY Ry
;;   (set (reg:SI Rn) 
;;	(rotate:SI (reg:SI Rx) (reg:SI Ry)))

(define_insn "rotlsi3"
  [(set (match_operand:SI 0 "register_operand" "=d,d")
	(rotate:SI (match_operand:SI 1 "register_operand" "d,d")
		   (match_operand:SI 2 "nonmemory_operand" "d,L")))]
  ""
  "%0=rot %1 by %2;"
  [(set_attr "type" "compute,shiftimm")
   (set_attr "cc" "shift")
  ])

(define_expand "rotrsi3"
  [(set (match_operand:SI 0 "register_operand" "")
	(rotate:SI (match_operand:SI 1 "register_operand" "")
		   (match_operand:SI 2 "nonmemory_operand" "")))]
  ""
  "
{
   rtx x = operands[2];
   if( GET_CODE(x) != CONST_INT )
      emit_insn (gen_rtx (SET, SImode, operands[2] = gen_reg_rtx(SImode),
 	         gen_rtx (NEG, SImode, x)));
   else
	operands[2] = gen_rtx(CONST_INT, SImode, -INTVAL(x));
}")

;;;
;;;  Bit Fields.
;;;
;;;
;;;  For us the 21k instruction is a little confusing and it doesn't really follow
;;;  appropriate logic for our needs.  What needs to be done:
;;;  Well I belive firmly that we want to follow the BIG ENDIAN rules.
;;;  So that a field that has this decl would map as such
;;;    
;;;  struct {
;;;    int a : 1;               word32+0     [a| b |           ]
;;;    int b : 3;               word32+1     [  c  |d|         ]
;;;    int   : 0;
;;;    int c : 5;
;;;    int d : 1;
;;; }   
;;;
;;;  So the position of the field is mapped from left to right not right to left therefore.
;;;
;;;  pos21k :: 32 - position + size
;;;
(define_expand "extv"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(sign_extract:SI (match_operand:SI 1 "register_operand"  "d") ; location
			 (match_operand:SI 2 "immediate_operand" "")    ; size
			 (match_operand:SI 3 "immediate_operand" "")))] ; position
  ""
  "
  if (INTVAL(operands[2]) > 32
      || (INTVAL (operands[2]) + INTVAL (operands[3])) > 32
      || INTVAL (operands[3]) > 31)
     FAIL;
  if (INTVAL (operands[2]) == 32 && INTVAL (operands[3]) == 0)
    {
	emit_move_insn (operands[0], operands[1]);
	DONE;
    }
")


(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
	(sign_extract:SI (match_operand:SI 1 "register_operand"  "d")    ; location
			 (match_operand:SI 2 "immediate_operand" "")    ; size
			 (match_operand:SI 3 "immediate_operand" "")))] ; position
  ""
  "*
{
  operands[3] = gen_rtx (CONST_INT, SImode, 32 - INTVAL(operands[3]) - INTVAL(operands[2]));
  return \"%0=fext %1 by %3:%2 (se);\";
}"
  [(set_attr "type" "shiftimm")])

(define_expand "extzv"
  [(set (match_operand:SI 0 "register_operand" "=d")
	(zero_extract:SI (match_operand:SI 1 "register_operand"  "d") ; location
			 (match_operand:SI 2 "immediate_operand" "")    ; size
			 (match_operand:SI 3 "immediate_operand" "")))] ; position
  ""
  "
  if (INTVAL(operands[2]) > 32
      || (INTVAL (operands[2]) + INTVAL (operands[3])) > 32
      || INTVAL (operands[3]) > 31)
     FAIL;
  if (INTVAL (operands[2]) == 32 && INTVAL (operands[3]) == 0)
    {
      emit_move_insn (operands[0], operands[1]);
      DONE;
    }

")

(define_insn ""
  [(set (match_operand:SI 0 "register_operand" "=d")
	(zero_extract:SI (match_operand:SI 1 "register_operand"  "d")    ; location
			 (match_operand:SI 2 "immediate_operand" "")    ; size
			 (match_operand:SI 3 "immediate_operand" "")))] ; position
  ""
  "*
  operands[3] = gen_rtx (CONST_INT, SImode, 32 - INTVAL(operands[3]) - INTVAL(operands[2]));
  return \"%0=fext %1 by %3:%2;\";"
  [(set_attr "type" "shiftimm")])


;;;
;;; on the 21000 the Rx = OR Rx FDEP Ry BY bit:len
;;; instruction has one minor flaw for HLL's it forgets that when using
;;; bitfields we need to actually set the field to the new value.
;;; The 21000 actual just or's the new value into the field.  So let's put on
;;; our boots and just zero it out ourselves.
;;; 
;;; Well I guess I need a comment on this code. (gas and I) spent about
;;; 15 minutes figuring out what I meant.
;;;
;;;     size
;;;   2      -1  which gives all 1's for the field in which we want to
;;;   	 deposit to.
;;;
;;; Then we just shift it up by the bit position.  The negation of this
;;;   causes a mask to be generated which is all 1's except for in the
;;;   field which is all zeros.  |000000000001111100000000000...|
;;;
(define_expand "insv"
  [(set (match_dup 4) (match_dup 5))
   (set (match_dup 4)
	(and:SI (match_operand:SI 0 "register_operand" "d")
		(match_dup 4)))
   (set (zero_extract:SI (match_dup 4)
			 (match_operand:SI 1 "immediate_operand" "")  ; size
			 (match_operand:SI 2 "immediate_operand" "")) ; pos
	(match_operand:SI 3 "register_operand" "d"))
   (set (match_dup 0) (match_dup 4))]
  ""
"
{
  int and_mask;
  int real_pos = 32 - INTVAL(operands[2]) - INTVAL(operands[1]);

  if (INTVAL(operands[1]) > 32
      || (INTVAL (operands[1]) + INTVAL (operands[2])) > 32
      || INTVAL (operands[2]) > 31)
       FAIL;

  and_mask = ~(((1 << INTVAL (operands[1])) -1) << real_pos);
  operands[4] = gen_reg_rtx (SImode);
  operands[5] = gen_rtx (CONST_INT, SImode, and_mask);
}")


(define_insn ""
 [(set (zero_extract:SI (match_operand:SI 0 "register_operand"  "+d")  ; loc
			(match_operand:SI 1 "immediate_operand" "")  ; siz
			(match_operand:SI 2 "immediate_operand" "")) ; pos
   (match_operand:SI 3 "register_operand" "d"))]
 ""
 "*
  operands[2] = gen_rtx (CONST_INT, SImode, 32 - INTVAL(operands[2]) - INTVAL(operands[1]));
  return \"%0=%0 or fdep %3 by %2:%1;\";"
 [(set_attr "type" "shiftimm")])

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
; Special case fixups for reloading an index register from a stack temp
; with post increment/decrement.
; This PROBABLY can be better done in the RELOAD define_expand, avoiding
; the cost of peepholing for this particular sequence

;	r4=dm(-3,i6); 	!!  235 movsi-1/5
;	i2=r4; 	!!  237 movsi-1/10
;	f0=dm(i2,m5); 	!!  25 subdi3+1/2
;	modify(i2,m0); 	!!  239 Increment_Index_Reg
;	r4=i2; 	!!  241 movsi-1/10
;	dm(-3,i6)=r4; 	!!  243 movsi-1/7
;--->
;	r4=dm(-3,i6); 	!!  235 movsi-1/5
;	i2=r4; 	!!  237 movsi-1/10
;	f0=dm(i2,m0); 	!!  25 subdi3+1/2
;	r4=i2; 	!!  241 movsi-1/10
;	dm(-3,i6)=r4; 	!!  243 movsi-1/7
; 
(define_peephole
 [(set (match_operand:SF 0 "register_operand" "")
       (mem:SF (match_operand:SI 1 "register_operand" "")))
  (set (match_dup 1)
       (plus:SI (match_dup 1)
                (match_operand:SI 2 "nonmemory_operand" "")))]
 "(GET_CODE (operands[2]) == REG
   || (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 32 && INTVAL (operands[2])>=-32))"
 "%0=dm(%1,%2);")

(define_peephole
 [(set (match_operand:SI 0 "register_operand" "")
       (mem:SI (match_operand:SI 1 "register_operand" "")))
  (set (match_dup 1)
       (plus:SI (match_dup 1)
                (match_operand:SI 2 "nonmemory_operand" "")))]
 "(GET_CODE (operands[2]) == REG
   || (GET_CODE (operands[2]) == CONST_INT && INTVAL (operands[2]) < 32 && INTVAL (operands[2])>=-32))"
  "%0=dm(%1,%2);")

;;;
;;; PARALLELIZER
;;; The following defines machine specific peephole optimizations for
;;; the 21K

;;; We Recognize DOLOOPS HERE BECAUSE if we dont the Peepholer doesn't
;;; do as good a job.

(define_peephole
  [(set (match_operand:DM 0 "" "")
	(plus:DM (match_dup 0)
		 (const_int 0)))]
  ""
  "!! deleted dummy modify "
  )

(define_peephole
  [(set (match_operand:PM 0 "" "")
	(plus:PM (match_dup 0)
		(const_int 0)))]
  ""
  "!! deleted dummy modify "
  )

;;
;; Stupid Pipeliner for simple s+=a[i]*b[i]
;;
(define_peephole
  [(unspec_volatile [(match_operand:SI 0 "dreg_or_const_operand" "")	;; loop counter
		     (match_operand 1 "" "")	                ;; start label
		     (match_operand 2 "" "")	                ;; end label
		     (const_int:SI 1)]		     
		     3)

   (set (match_operand:SI 3 "register_operand" "")
	(match_operand:SI 4 "postmodifiable_memory_operand" ""))

   (set (match_operand:SI 5 "register_operand" "")
	(match_operand:SI 6 "postmodifiable_memory_operand" ""))

   (set (match_operand:SI 7 "register_operand" "")
	(plus:SI (mult:SI (match_dup 3) (match_dup 5))
		 (match_dup 7)))

   (set (pc)
	(if_then_else (match_operand 8 "" "")
		      (match_dup 1)
		      (pc)))]
   "GUAREENTED_2ITERATIONS || CONSTANT_P(operands[0])"
   "*
{
   int constant_limit_p = CONSTANT_P (operands[0]);
   int opposite_banks_p = opposite_banks(operands[4],operands[6]);

   if (opposite_banks_p 
       && GET_MODE (XEXP (operands[4],0)) == PMmode) {

#define SWAP_rtx(a,b) { rtx c = (a); a = b; b = c; }

     SWAP_rtx (operands[3],operands[5]);
     SWAP_rtx (operands[4],operands[6]);

#undef SWAP_rtx

   }
   
   if (constant_limit_p)
      operands[0] = gen_rtx (CONST_INT,VOIDmode, INTVAL(operands[0])-1);

   if (opposite_banks_p)
      if(!constant_limit_p)
         output_asm_insn (\"%0=%0-1, %3=%4, %5=%6;\",operands);
      else
         output_asm_insn (\"%3=%4, %5=%6;\",operands);
   else
      if(!constant_limit_p)
         output_asm_insn (\"%0=%0-1, %3=%4;\;%5=%6;\",operands);
      else
         output_asm_insn (\"%3=%4;\;%5=%6;\",operands);

   if(opposite_banks_p)
     output_asm_insn (\"lcntr = %0%D0 do (pc,1) until lce;\",operands);
   else
     output_asm_insn (\"lcntr = %0%D0 do (pc,2) until lce;\",operands);

   if (opposite_banks_p)
     output_asm_insn (\"%7=%7+%3*%5(ssi), %3=%4, %5=%6;\",operands);
   else
     output_asm_insn (\"%7=%7+%3*%5(ssi), %3=%4;\;%5=%6;\",operands);

   output_asm_insn (\"%7=%7+%3*%5(ssi);\",operands);
   RET;
}")


;;
;;
;; This is the floating point dot product.
;; next 2 patterns::::
;;
(define_peephole
  [(unspec_volatile [(match_operand 0 "dreg_or_const_operand" "")	;; loop counter
		     (match_operand 1 "" "")	                ;; start label
		     (match_operand 2 "" "")	                ;; end label
		     (match_operand 3 "immediate_operand" "i")]	;; depth
		     3)

   (set (match_operand:SF 4 "register30_operand" "")
	(match_operand:SF 5 "postmodifiable_memory_operand" ""))

   (set (match_operand:SF 6 "register74_operand" "")
	(match_operand:SF 7 "postmodifiable_memory_operand" ""))


   (set (match_operand:SF 8 "register118_operand" "")
	(mult:SF (match_dup 4) (match_dup 6)))

   (set (match_operand:SF 9 "register1512_operand" "")
	(plus:SF (match_dup 9) (match_dup 8)))

   (set (pc)
	(if_then_else (match_operand 10 "" "")
		      (match_dup 1)          ;; label_ref top of loop
		      (pc)))]

   "GUAREENTED_2ITERATIONS || CONSTANT_P (operands[0])"
   "*
{
   int constant_limit_p = CONSTANT_P (operands[0]);
   int opposite_banks_p = opposite_banks (operands[5], operands[7]);

   if (constant_limit_p)
      operands[0] = gen_rtx (CONST_INT,VOIDmode, INTVAL (operands[0])-2);

   if (opposite_banks_p 
       && GET_MODE (XEXP (operands[5],0)) == PMmode) {

#define SWAP_rtx(a,b) { rtx c = (a); a = b; b = c; }

     SWAP_rtx (operands[4],operands[6]);
     SWAP_rtx (operands[5],operands[7]);

#undef SWAP_rtx

   }

   if (opposite_banks_p)
      if(!constant_limit_p) {
         output_asm_insn (\"%0=%0-1, %6=%7;\",operands);
         output_asm_insn (\"%0=%0-1, %4=%5;\",operands);
      } else
         output_asm_insn (\"%4=%5, %6=%7;\",operands);
   else
      if(!constant_limit_p) {
         output_asm_insn (\"%0=%0-1, %6=%7;\",operands);
         output_asm_insn (\"%0=%0-1, %4=%5;\",operands);
      } else
         output_asm_insn (\"%4=%5;\;%6=%7;\", operands);

   if (opposite_banks_p) {
     output_asm_insn (\"%8=%4*%6, %4=%5, %6=%7;\", operands);
     output_asm_insn (\"lcntr = %0%D0 do (pc,1) until lce;!!float dot\",operands);
   } else {
     output_asm_insn (\"%8=%4*%6, %4=%5;\;%6=%7;\", operands);      
     output_asm_insn (\"lcntr = %0%D0 do (pc,2) until lce;!!float dot\",operands);
   }

   if (opposite_banks_p)
     output_asm_insn (\"%8=%4*%6 , %9=%8+%9, %4=%5, %6=%7;\",operands);
   else
     output_asm_insn (\"%8=%4*%6 , %9=%8+%9, %4=%5;\;%6=%7;\",operands);


   output_asm_insn (\"\;%8=%4*%6, %9=%8+%9;\;%9=%8+%9;\",operands);
		    
   RET;
}")

(define_peephole
  [(unspec_volatile [(match_operand 0 "dreg_or_const_operand" "")	;; loop counter
		     (match_operand 1 "" "")	                ;; start label
		     (match_operand 2 "" "")	                ;; end label
		     (match_operand 3 "immediate_operand" "i")]	;; depth
		     3)

   (set (match_operand:SF 4 "register30_operand" "")
	(match_operand:SF 5 "postmodifiable_memory_operand" ""))

   (set (match_operand:SF 6 "register74_operand" "")
	(match_operand:SF 7 "postmodifiable_memory_operand" ""))


   (set (match_operand:SF 8 "register1512_operand" "")
	(mult:SF (match_dup 4) (match_dup 6)))

   (set (match_operand:SF 9 "register118_operand" "")
	(plus:SF (match_dup 9) (match_dup 8)))

   (set (pc)
	(if_then_else (match_operand 10 "" "")
		      (match_dup 1)          ;; label_ref top of loop
		      (pc)))]

   "GUAREENTED_2ITERATIONS || CONSTANT_P (operands[0])"
   "*
{
   int constant_limit_p = CONSTANT_P (operands[0]);
   int opposite_banks_p = opposite_banks (operands[5], operands[7]);

   if (constant_limit_p)
      operands[0] = gen_rtx (CONST_INT,VOIDmode, INTVAL (operands[0])-2);

   if (opposite_banks_p 
       && GET_MODE (XEXP (operands[5],0)) == PMmode) {

#define SWAP_rtx(a,b) { rtx c = (a); a = b; b = c; }

     SWAP_rtx (operands[4],operands[6]);
     SWAP_rtx (operands[5],operands[7]);

#undef SWAP_rtx

   }

   if (opposite_banks_p)
      if(!constant_limit_p) {
         output_asm_insn (\"%0=%0-1, %6=%7;\",operands);
         output_asm_insn (\"%0=%0-1, %4=%5;\",operands);
      } else
         output_asm_insn (\"%4=%5, %6=%7;\",operands);
   else
      if(!constant_limit_p) {
         output_asm_insn (\"%0=%0-1, %6=%7;\",operands);
         output_asm_insn (\"%0=%0-1, %4=%5;\",operands);
      } else
         output_asm_insn (\"%4=%5;\;%6=%7;\", operands);

   if (opposite_banks_p) {
     output_asm_insn (\"%8=%4*%6, %4=%5, %6=%7;\", operands);
     output_asm_insn (\"lcntr = %0%D0 do (pc,1) until lce;!!float dot\",operands);
   } else {
     output_asm_insn (\"%8=%4*%6, %4=%5;\;%6=%7;\", operands);      
     output_asm_insn (\"lcntr = %0%D0 do (pc,2) until lce;!!float dot\",operands);
   }

   if (opposite_banks_p)
     output_asm_insn (\"%8=%4*%6 , %9=%9+%8, %4=%5, %6=%7;\",operands);
   else
     output_asm_insn (\"%8=%4*%6 , %9=%9+%8, %4=%5;\;%6=%7;\",operands);


   output_asm_insn (\"\;%8=%4*%6, %9=%9+%8;\;%9=%9+%8;\",operands);
		    
   RET;
}")


;-------------------------------------




(define_peephole
  [(unspec_volatile [(match_operand:SI 0 "dreg_or_const_operand" "")	;; loop counter
		     (match_operand 1 "" "")	                ;; start label
		     (match_operand 2 "" "")	                ;; end label
		     (const_int:SI 1)]		     
		     3)

   (set (match_operand 3 "register_operand" "")
	(match_operand 4 "postmodifiable_memory_operand" ""))

   (set (match_operand 5 "register_operand" "")
	(match_operand 6 "postmodifiable_memory_operand" ""))

   (set (match_operand 7 "register_operand" "")
	(match_operator 8 "compute_binaryop"
			[(match_dup 3) (match_dup 5)]))
   
   (set (match_operand 9 "postmodifiable_memory_operand" "")
	(match_dup 7))

   (set (pc)
	(if_then_else (match_operand 10 "" "")
		      (match_dup 1)
		      (pc)))]

  "!(reg_equal_p (operands[7], operands[3])
        || reg_equal_p ( operands[7], operands[5]))"

   "*
{
   int constant_limit_p   = CONSTANT_P (operands[0]);
   int opposite_banks_p   = opposite_banks (operands[4], operands[6]);
   enum machine_mode mode = GET_MODE (operands[7]);

   operands[10] = gen_label_rtx ();

   if (opposite_banks_p 
       && GET_MODE (XEXP (operands[4], 0)) == PMmode) {

#define SWAP_rtx(a,b) { rtx c = (a); a = b; b = c; }

     SWAP_rtx (operands[3], operands[5]);
     SWAP_rtx (operands[4], operands[6]);

#undef SWAP_rtx

   }
   
   if (constant_limit_p)
      operands[0] = gen_rtx (CONST_INT,VOIDmode, INTVAL(operands[0])-1);

   if (opposite_banks_p)
      if(!constant_limit_p)
         output_asm_insn (\"%0=%0-1, %3=%4, %5=%6;\;if lt jump (pc, %10);\",operands);
      else
         output_asm_insn (\"%3=%4, %5=%6;\",operands);
   else
      if(!constant_limit_p)
         output_asm_insn (\"%0=%0-1, %3=%4;\;%5=%6;\;if lt jump (pc, %10);\",operands);
      else
         output_asm_insn (\"%3=%4;\;%5=%6;\",operands);

   
   if(opposite_banks_p)
     output_asm_insn (\"lcntr = %0%D0 do (pc,2) until lce;\",operands);
   else
     output_asm_insn (\"lcntr = %0%D0 do (pc,3) until lce;\",operands);

   
   if (infix_21k_operatorp (operands[8], mode))
     if (opposite_banks_p)
       output_asm_insn (\"%7=%3%z8%5%m8, %3=%4, %5=%6;\;%9=%7;\",operands);
     else
       if (opposite_banks (operands[9], operands[4]))
	 output_asm_insn (\"%7=%3%z8%5%m8, %9=%7,%3=%4;\;%5=%6;\",operands);
       else if (opposite_banks (operands[9], operands[5]))
	 output_asm_insn (\"%7=%3%z8%5%m8, %3=%4;\;%9=%7, %5=%6;\",operands);
       else
	 output_asm_insn (\"%7=%3%z8%5%m8, %3=%4;\;%5=%6;\;%9=%7;\",operands);

   output_asm_insn (\"%L10%7=%3%z8%5%m8;\;%9=%7;\",operands);
   RET;
}")

(define_peephole
  [(unspec_volatile [(match_operand:SI 0 "dreg_or_const_operand" "");; loop counter
		     (match_operand 1 "" "")	                ;; start label
		     (match_operand 2 "" "")	                ;; end label
		     (const_int:SI 1)]		     
		     3)

   (set (match_operand 3 "register_operand" "")
	(match_operand 4 "postmodifiable_memory_operand" ""))

   (set (match_operand 5 "register_operand" "")
	(match_operand 6 "postmodifiable_memory_operand" ""))

   (set (match_operand 7 "register_operand" "")
	(match_operator 8 "compute_binaryop"
			[(match_dup 5) (match_dup 3)]))
   
   (set (match_operand 9 "postmodifiable_memory_operand" "")
	(match_dup 7))

   (set (pc)
	(if_then_else (match_operand 10 "" "")
		      (match_dup 1)
		      (pc)))]

  "!(reg_equal_p (operands[7], operands[3]) 
        || reg_equal_p ( operands[7], operands[5]))"
   "*
{
   int constant_limit_p   = CONSTANT_P (operands[0]);
   int opposite_banks_p   = opposite_banks (operands[4], operands[6]);
   enum machine_mode mode = GET_MODE (operands[7]);

   /*
    * We don't use operand 10 so I'm just going to overwrite it mmh..... 
    * this should be ok.
    */
   operands[10] = gen_label_rtx();

   if (opposite_banks_p 
       && GET_MODE (XEXP (operands[4], 0)) == PMmode) {

#define SWAP_rtx(a,b) { rtx c = (a); a = b; b = c; }

     SWAP_rtx (operands[3], operands[5]);
     SWAP_rtx (operands[4], operands[6]);

#undef SWAP_rtx

   }
   
   if (constant_limit_p)
      operands[0] = gen_rtx (CONST_INT,VOIDmode, INTVAL(operands[0])-1);

   if (opposite_banks_p)
      if(!constant_limit_p)
         output_asm_insn (\"%0=%0-1, %3=%4, %5=%6;\;if lt jump (pc, %10);\",operands);
      else
         output_asm_insn (\"%3=%4, %5=%6;\",operands);
   else
      if(!constant_limit_p)
         output_asm_insn (\"%0=%0-1, %3=%4;\;%5=%6;\;if lt jump (pc, %10);\",operands);
      else
         output_asm_insn (\"%3=%4;\;%5=%6;\",operands);

   if(opposite_banks_p)
     output_asm_insn (\"lcntr = %0%D0 do (pc,2) until lce;\",operands);
   else
     output_asm_insn (\"lcntr = %0%D0 do (pc,3) until lce;\",operands);

   if (infix_21k_operatorp (operands[8], mode))
     if (opposite_banks_p)
       output_asm_insn (\"%7=%5%z8%3%m8, %3=%4, %5=%6;\;%9=%7;\",operands);
     else
       if (opposite_banks (operands[9], operands[4]))
	 output_asm_insn (\"%7=%5%z8%3%m8, %9=%7,%3=%4;\;%5=%6;\",operands);
       else if (opposite_banks (operands[9], operands[5]))
	 output_asm_insn (\"%7=%5%z8%3%m8, %3=%4;\;%9=%7, %5=%6;\",operands);
       else
	 output_asm_insn (\"%7=%5%z8%3%m8, %3=%4;\;%5=%6;\;%9=%7;\",operands);
			  
   output_asm_insn (\"%L10%7=%5%z8%3%m8;\;%9=%7;\",operands);
   RET;
}")



;;
;; Simple reduction of a vector..
;;
(define_peephole
  [(unspec_volatile [(match_operand:SI 0 "dreg_or_const_operand" "");; loop counter
		     (match_operand 1 "" "")	                ;; start label
		     (match_operand 2 "" "")	                ;; end label
		     (const_int:SI 1)]		     
		     3)

   (set (match_operand 3 "register_operand" "")
	(match_operand 4 "postmodifiable_memory_operand" ""))

   (set (match_operand 5 "register_operand" "")
	(match_operator 6 "compute_binaryop"
			[(match_dup 5) (match_dup 3)]))
   
   (set (pc)
	(if_then_else (match_operand 7 "" "")
		      (match_dup 1)
		      (pc)))]
   ""
   "*
{
   int constant_limit_p   = CONSTANT_P (operands[0]);
   enum machine_mode mode = GET_MODE (operands[7]);

   operands[8] = gen_label_rtx ();

   if (constant_limit_p)
     operands[0] = gen_rtx (CONST_INT, VOIDmode, INTVAL (operands[0])-1);


   if(!constant_limit_p)
     output_asm_insn (\"%0=%0-1, %3=%4;\;if le jump (pc, %8);\", operands);
   else
     output_asm_insn (\"%3=%4;\",operands);
   
   output_asm_insn (\"lcntr = %0%D0 do (pc,1) until lce;\", operands);

   if (infix_21k_operatorp (operands[6], mode))
     output_asm_insn (\"%5=%5%z6%3%m6, %3=%4;%L8\;%5=%5%z6%3%m6;\",operands);
   else
   output_asm_insn (\"%5=%z6(%5,%3), %3=%4;%L8\;%5=%z6(%5,%3);\",operands);

   RET;
}")

;;;;;==================================================================
;;;;;  Peephole parallelizer
;;;;;==================================================================


;
; Look for: swap
;
;    rA=rB;
;    rB=rC;
;    rC=rA;  && last use of rA	=>	rB=PASS rC,rC=rB;
;
(define_peephole
  [(set (match_operand 0 "datareg_operand" "") (match_operand 1 "datareg_operand" ""))
   (set (match_dup 1) (match_operand 2 "datareg_operand" ""))
   (set (match_dup 2) (match_dup 0))]
  "dead_or_set_p (insn, operands[0])"
  "%1=pass %2, %2=%1;"
  [(set_attr "length" "1")
   (set_attr "cc" "clobber")
   (set_attr "type" "misc")]
)

;
;  rA=rB;
;  rC=rA;  !Last use of rA	=>	rC=rB;
;
(define_peephole
 [(set	(match_operand 0 "ureg_operand" "")
	(match_operand 1 "ureg_operand" ""))
  (set	(match_operand 2 "ureg_operand" "")
	(match_dup 0))]
  "dead_or_set_p (insn, operands[0])"
  "%2=%1;"
  [(set_attr "length" "1")
   (set_attr "cc" "clobber")]
)

;
;  rA=rB;
;  rC=rA;              =>       rC=pass rB,rA=rB;
(define_peephole
 [(set (match_operand 0 "ureg_operand"    "")
       (match_operand 1 "datareg_operand" ""))
  (set (match_operand 2 "datareg_operand" "") (match_dup 0))
 ]
 ""
 "%2=pass %1,%0=%1;"
 [(set_attr "length" "1")
  (set_attr "cc" "sets")]
)

(define_peephole	;;; Any 5 insns
  [(match_operand 0 "" "")
   (match_operand 1 "" "")
   (match_operand 2 "" "")
   (match_operand 3 "" "")
   (match_operand 4 "" "")]
  "peep_parallelizeable_5(1)"
  "*
  {
    dump_parallel(5);
    return \" \";
  }"
  [(set_attr "length" "1")]
)
(define_peephole	;;; Any 4 insns
  [(match_operand 0 "" "")
   (match_operand 1 "" "")
   (match_operand 2 "" "")
   (match_operand 3 "" "")]
  "peep_parallelizeable_4(1)"
  "*
  {
    dump_parallel(4);
    return \" \";
  }"
  [(set_attr "length" "1")]
)

(define_peephole	;;; Any 3 insns
  [(match_operand 0 "" "")
   (match_operand 1 "" "")
   (match_operand 2 "" "")]
  "peep_parallelizeable_3(1)"
  "*
  {
    dump_parallel(3);
    return \" \";
  }"
  [(set_attr "length" "1")]
)

(define_peephole	;;; Any 2 insns
  [(match_operand 0 "" "")
   (match_operand 1 "" "")]
  "peep_parallelizeable_2(1)"
  "*
  {
    dump_parallel(2);
    return \" \";
  }"
  [(set_attr "length" "1")]
)

;;
;; Beware of conditional write to MEMORY
;;
;; Fold conditional branch around a simple assignment into
;; a conditional assignment instruction, ala:
;;
;;	if cond jump (label);
;;	dst=src;		=>	if not cond dst=src;
;;  label:
;;

(define_peephole 
  [(set (pc)
        (if_then_else (match_operator 5 "signed_comparison_operator"
			                [(cc0) (const_int 0)])
		      (match_operand 0 "" "")
		      (pc)))

   (set (match_operand 1 "parallel_move_or_register_operand" "")
	(match_operand 2 "parallel_move_or_register_or_lit_operand" ""))

   (set (match_operand 3 "datareg_operand" "")
	(match_operand 4 "datareg_operand" ""))]

  "next_nonnote_insn (insn) == XEXP (operands[0], 0)
   && legit_parallel_move_insn (peep_insn[1], peep_insn[0])
   && (!JDWRITE || GET_CODE (operands[1]) != MEM)
   && !reg_equal_p (operands[1], operands[3])
   && !reg_equal_p (operands[1], operands[4])"

  "*
   if (dag_source(operands[1], DMmode))
	return \"if %J5 %3=pass %4, %1=%R2;\";
   else
	return \"if %J5 %3=pass %4, %1=%P2;\";
  "
  [(set_attr "length" "1")]
)


(define_peephole 
  [(set (pc)
        (if_then_else (match_operator 5 "signed_comparison_operator"
			                [(cc0) (const_int 0)])
		      (match_operand 0 "" "")
		      (pc)))

   (set (match_operand 1 "datareg_operand" "")
	(match_operand 2 "datareg_operand" ""))

   (set (match_operand 3 "parallel_move_or_register_operand" "")
	(match_operand 4 "parallel_move_or_register_or_lit_operand" ""))]

  "next_nonnote_insn (insn) == XEXP (operands[0], 0)
   && legit_parallel_move_insn (peep_insn[2], peep_insn[0])
   && (!JDWRITE || GET_CODE (operands[3]) != MEM)
   && !reg_equal_p (operands[1], operands[3])
   && !reg_equal_p (operands[1], operands[4])"

  "*
   if (dag_source(operands[3], DMmode))
	return \"if %J5 %1=pass %2, %3=%R4;\";
   else
	return \"if %J5 %1=pass %2, %3=%P4;\";
  "
  [(set_attr "length" "1")]
)

(define_peephole 
  [(set (pc)
        (if_then_else (match_operator 5 "signed_comparison_operator"
			                [(cc0) (const_int 0)])
		      (match_operand 0 "" "")
		      (pc)))

   (set (match_operand 1 "parallel_move_or_register_operand" "")
	(match_operand 2 "parallel_move_or_register_or_lit_operand" ""))

   (set (match_operand 3 "parallel_move_or_register_operand" "")
	(match_operand 4 "parallel_move_or_register_or_lit_operand" ""))]

  "next_nonnote_insn (insn) == XEXP (operands[0], 0)
   && legit_parallel_move_insn (peep_insn[1], peep_insn[0])
   && legit_parallel_move_insn (peep_insn[2], peep_insn[0])
   && (!JDWRITE || (GET_CODE (operands[1]) != MEM 
                    && GET_CODE (operands[3]) != MEM))"
  "*
   if (dag_source(operands[1], DMmode))
	if (dag_source(operands[3], DMmode))
		return \"if %J5 %1=%R2;\;if %J5 %3=%R4; !dub1\";
	else
		return \"if %J5 %1=%R2;\;if %J5 %3=%P4; !dub2\";
   else
	if (dag_source(operands[3], DMmode))
		return \"if %J5 %1=%P2;\;if %J5 %3=%R4; !dub3\";
	else
		return \"if %J5 %1=%P2;\;if %J5 %3=%P4; !dub4\";
  "
  [(set_attr "length" "2")]
)

(define_peephole 
  [(set (pc)
        (if_then_else (match_operator 3 "signed_comparison_operator"
			                [(cc0) (const_int 0)])
		      (match_operand 0 "" "")
		      (pc)))

   (set (match_operand 1 "parallel_move_or_register_operand" "")
	(match_operand 2 "parallel_move_or_register_or_lit_operand" ""))]

  "(!JDWRITE || GET_CODE (operands[1]) != MEM)
   && ( !indexed_by_lit6 (operands[1], VOIDmode)
	 || datareg_operand (operands[2],VOIDmode))
   && next_nonnote_insn (insn) == XEXP (operands[0], 0)"

  "*
   if (dag_source(operands[1], DMmode))
	return \"if %J3 %1=%R2;\";
   else
	return \"if %J3 %1=%P2;\";"
)

;
; Look for:
;
;    r4=r0;
;    r4=pass r4;	->	r4=pass r0;

(define_peephole
  [(set (match_operand 0 "datareg_operand" "")
	(match_operand 1 "datareg_operand" ""))
   (set (cc0) (match_dup 0))]
  ""
  "%0=pass %1;"
  [(set_attr "mode" "CCSET")
   (set_attr "length" "1")]
)
