#include <stdio.h>
#include <string.h>
#include "app.h"
#include "a_out.h"
#include "symbol.h"
#include "codegen.h"
#include "action.h"
#include "expr.h"
#include "fileio.h"
#include "reg.h"
#include "lexical.h"
#include "ilnode.h"
#include "opcodes.h"
#include "tempio.h"
#include "assemble.h"
#include "error.h"
#include "pass1.h"
#include "ieee.h"
#include "str.h"
#include "main.h"
#include "addressing.h"
#include "listing.h"

#include "section_fp.h"
#include "make_ilnode_fp.h"

#ifdef TRUE
#undef TRUE
#endif

#define  ADD_IDENTIFIER(name, value, section_number, type, length)      (symbol_lookup( name ) ? symbol_lookup(name) : symbol_insert( name, value, section_number, type, length))

ILNODE  ilnode;
ILNODE  *il = &ilnode;
int     init_processing = FALSE;
int     file_init_processing = FALSE;
long    num_initializers = 0l;
long    value = 0l;
char    temp_ident_name[BUFSIZ];
SYMBOL *current_symbol = NULL;
SYMBOL *defined_symbol = NULL;
int     octal_value = 0, increment = 0;
short   Debug_symbol_definition = FALSE;
extern short File_directive_needed;
extern char coff_name[];
extern short Z3;
# define ENDSEG 257
# define EXTERN 258
# define FILENAME 259
# define GLOBAL 260
# define GCC_COMPILED 261
# define NEWPAGE 262
# define PORT 263
# define PRECISION 264
# define ROUND_NEAREST 265
# define ROUND_ZERO 266
# define ROUND_PLUS 267
# define ROUND_MINUS 268
# define SEGMENT 269
# define VAR 270
# define DEF 271
# define VAL 272
# define SCL 273
# define TYPE 274
# define ENDEF 275
# define BF 276
# define EOS 277
# define SIZE 278
# define DIM 279
# define TAG 280
# define EF 281
# define BB 282
# define EB 283
# define LINE 284
# define LN 285
# define FILEDEF 286
# define ABS 287
# define AC 288
# define ACT 289
# define AND 290
# define ASHIFT 291
# define AV 292
# define BCLR 293
# define BIT 294
# define BITREV 295
# define BSET 296
# define BTGL 297
# define BTST 298
# define BY 299
# define CA 300
# define CACHE 301
# define CALL 302
# define CARRY 303
# define CH 304
# define CL 305
# define CLIP 306
# define CLR 307
# define CODE 308
# define COMP 309
# define COPYSIGN 310
# define COS 311
# define DB 312
# define DEC 313
# define DELAY 314
# define DM 315
# define DMDATA 316
# define DO 317
# define ECE 318
# define ELSE 319
# define EQ 320
# define EX 321
# define EXP 322
# define EXP2 323
# define FDEP 324
# define FEXT 325
# define FIX 326
# define FLAG0_IN 327
# define FLAG1_IN 328
# define FLAG2_IN 329
# define FLAG3_IN 330
# define FLOAT 331
# define FMERG 332
# define FOREVER 333
# define GE 334
# define GT 335
# define IDLE 336
# define IF 337
# define INC 338
# define JUMP 339
# define LA 340
# define LCE 341
# define LCNTR 342
# define LE 343
# define LEFTO 344
# define LEFTZ 345
# define LENGTH 346
# define LOAD 347
# define LOG2 348
# define LOGB 349
# define LOOP 350
# define LSHIFT 351
# define LT 352
# define MANT 353
# define MAX 354
# define MIN 355
# define MOD 356
# define MODIFY 357
# define MS 358
# define MULTIPLIER_MODIFIER 359
# define MV 360
# define NE 361
# define NEW_LINE 362
# define NOFZ 363
# define NOFO 364
# define NOP 365
# define NOPSPECIAL 366
# define NOT 367
# define NU 368
# define OR 369
# define P20 370
# define P24 371
# define P32 372
# define P40 373
# define PACK 374
# define PASS 375
# define PM 376
# define PMDATA 377
# define POP 378
# define PUSH 379
# define READ 380
# define RECIPS 381
# define RND 382
# define ROT 383
# define RS 384
# define RSQRTS 385
# define RTI 386
# define RTS 387
# define SAT 388
# define SCALB 389
# define SET 390
# define SE 391
# define SIN 392
# define SQR 393
# define STEP 394
# define STS 395
# define PCSTK 396
# define SV 397
# define SZ 398
# define ST 399
# define TF 400
# define TGL 401
# define TRUE 402
# define TST 403
# define UNPACK 404
# define UNTIL 405
# define WITH 406
# define XOR 407
# define DATA_REGISTER 408
# define FLOATING_REGISTER 409
# define INDEX_REGISTER 410
# define MODIFY_REGISTER 411
# define LENGTH_REGISTER 412
# define BASE_REGISTER 413
# define SYSTEM_REGISTER 414
# define CACHE_REGISTER 415
# define TEST_REGISTER 416
# define MISC_REGISTER 417
# define PC 418
# define FR 419
# define MRF 420
# define MRB 421
# define MR0F 422
# define MR1F 423
# define MR2F 424
# define MR0B 425
# define MR1B 426
# define MR2B 427
# define SHP 428
# define SHF 429
# define BM 430
# define CJUMP 431
# define EMUIDLE 432
# define FPACK 433
# define FUNPACK 434
# define NBM 435
# define RFRAME 436
# define FLUSH 437
# define TRUNC 438
# define IDLE16 439
# define LEFT_SHIFT 440
# define RIGHT_SHIFT 441
# define FRACTIONAL 442
# define IDENTIFIER 443
# define INT_CONST 444
# define HEX40_CONST 445
# define REAL 446
# define UNARY 447
#define yyclearin yychar = -1
#define yyerrok yyerrflag = 0
extern int yychar;
extern short yyerrflag;
#ifndef YYMAXDEPTH
#define YYMAXDEPTH 150
#endif
YYSTYPE yylval, yyval;
# define YYERRCODE 256
short yyexca[] ={
-1, 1,
	0, -1,
	-2, 0,
-1, 94,
	256, 270,
	59, 270,
	-2, 661,
-1, 243,
	256, 268,
	59, 268,
	-2, 661,
-1, 255,
	256, 265,
	59, 265,
	-2, 661,
-1, 258,
	256, 269,
	59, 269,
	-2, 661,
-1, 393,
	256, 263,
	59, 263,
	-2, 661,
-1, 395,
	256, 267,
	59, 267,
	-2, 661,
-1, 441,
	44, 436,
	-2, 167,
-1, 442,
	44, 437,
	-2, 168,
-1, 499,
	44, 435,
	-2, 148,
-1, 501,
	44, 438,
	-2, 147,
-1, 547,
	44, 625,
	-2, 626,
-1, 600,
	259, 70,
	-2, 66,
	};
# define YYNPROD 662
# define YYLAST 3396
short yyact[]={

 432, 893,1076, 419,  97, 934,  97, 118, 935,1038,
 424, 890, 158, 113, 104, 377, 104, 202,  98, 289,
 355, 588,1273, 192,1082, 116, 194, 769, 193,  92,
 598, 375, 365, 364, 371, 349, 344, 369, 367, 924,
 342, 340, 423, 341, 777, 343, 117, 201, 117, 776,
 379, 363, 127, 605, 157, 384,1164, 382, 366, 754,
 126, 753, 422, 681, 682, 749, 115, 748, 115, 892,
 330, 327, 165, 665, 162, 328, 125, 161, 239,1129,
 887, 276, 325,1010,1002, 265, 894, 329, 246, 326,
 900, 899, 346, 192, 518, 517, 194, 427, 193,1077,
1078,1079,1080, 772, 515, 514,1015, 241, 428, 195,
 156, 155, 607, 328, 325, 128, 154, 201,1139, 130,
 329, 124, 345,1136, 435,1050, 172, 326, 894, 313,
 238,1254, 248, 433, 123, 438, 142, 428, 235, 201,
 841, 838, 330, 840, 102, 349, 101, 314, 318, 327,
 342, 340, 839, 341, 234, 343, 129, 349, 344, 169,
 321, 434, 342, 340, 275, 341,1140, 343, 842, 427,
1138, 590,1049, 606, 250, 277, 589, 278, 837, 195,
1147, 279, 134,1145, 349, 344,1137,1135, 284, 342,
 340, 274, 341, 249, 343,1048, 273,1294,1293, 233,
1292,1291,1167, 245, 244,1077,1078,1079,1080,1150,
1149, 174, 232,1148, 346,1131,1130,1128,1127,1126,
1125,1124, 237,1123, 236, 159, 160, 161, 162, 164,
 163, 165,1122, 166, 167, 168, 173, 170, 171, 175,
 176, 177, 178, 179, 180, 181, 182,1121, 373, 374,
 889, 888, 415, 886, 425, 885, 669, 670, 668, 671,
 884, 421, 246, 883, 882, 447, 881, 495, 496, 497,
 498, 499, 501, 503, 112, 442, 880, 446, 879, 420,
 878, 416, 111, 877, 876, 494, 521, 875, 521, 526,
 874, 105, 825, 520, 406, 524, 669, 670, 541, 671,
 592, 596, 939, 100, 414, 593, 594, 595, 504, 505,
 361, 519, 411, 523, 404, 122, 137,  99,   4, 445,
 316, 252, 376, 191,1085,  42, 775,  94, 410,  93,
  91, 525, 552, 553, 554, 555, 556, 557, 562, 567,
 568, 546, 551,1277,1276,1275, 349, 344,1219, 522,
 587, 342, 340,1218, 341,1217, 343,1089,1088,1087,
 349, 344,1051, 968, 192, 342, 340, 194, 341, 193,
1326, 561, 566, 409, 967, 444, 443, 966, 834, 781,
 780, 493, 779, 733,1325, 190, 408, 732, 201, 617,
 619, 620, 625, 231, 162, 656, 413, 648, 412, 246,
 635, 636, 622, 346, 446, 243, 647, 242, 240, 452,
 646, 451, 644, 643, 642, 641, 600, 346, 618, 645,
 604, 354, 400, 399, 391, 198, 196, 197, 200, 199,
 390, 654, 389, 345, 653, 370, 368, 385, 348, 347,
 339, 616, 337, 261, 336, 335, 445, 345, 362, 613,
 195, 320, 334, 333, 332, 331, 204, 272, 685, 686,
 687, 688, 690, 691, 271, 612, 694, 695, 696, 697,
 698, 699, 700, 701, 702, 703, 704, 705, 706, 707,
 708, 709, 710, 711, 712, 713, 714, 715, 716, 717,
 718, 719, 720, 270, 203, 198, 196, 197, 200, 199,
 542, 269, 444, 443, 672, 268, 544, 549, 493, 267,
 611, 266, 865, 264, 667, 204, 204, 198, 196, 197,
 200, 199,  43, 610, 675, 356, 426, 188, 204,1255,
 103,1246, 103, 615, 192, 614, 624, 194, 623, 193,
 263, 380, 735,1074, 672, 349, 344, 756, 348, 347,
 342, 340, 387, 341,1235, 343, 453, 513, 201,1005,
 348, 347, 392,1017, 675,1018, 516, 407, 450, 751,
1006, 752, 759, 761, 762, 763, 764, 765, 350, 351,
 352, 353, 449, 673, 544, 549, 723, 348, 347, 262,
 722, 350, 506, 507, 508, 509, 510,1321, 372, 372,
 372, 349, 346, 746, 247, 747, 342,1191, 666, 768,
1190, 343,  78,1295,  78, 770, 679, 677, 680, 678,
 195, 674,1278, 969, 315, 319,1189, 686, 687,1188,
 654, 192, 345, 785, 194,1171, 193, 322,1172, 521,
 805, 521, 809, 810, 813, 499, 793, 826, 808, 829,
 246,1216,1215,1213, 622, 201, 446, 836, 828, 372,
 372, 674, 998, 257, 792, 997, 807, 260,1211, 806,
 847, 848, 851, 853, 854, 858, 859,1083, 861, 862,
 863, 864, 796, 255, 258,1193, 230, 846, 397, 398,
 871, 349, 804, 872, 873, 860, 342, 340, 445, 341,
 801, 343, 794, 350, 609, 850, 852, 789, 790, 547,
 547, 996, 994,1143, 995, 993, 800, 195, 991,1141,
 257, 992, 372, 372, 394, 569, 577, 578, 579, 580,
 581, 582, 583, 584, 585, 586, 990, 987, 662, 989,
 988, 661, 359, 828,1133, 898, 910, 911, 912, 348,
 347, 915, 916, 917, 444, 443, 920, 921, 922, 923,
 493, 799, 660, 348, 347, 659, 198, 196, 197, 200,
 199, 372, 658, 493, 798, 657,1132,1096, 417, 950,
 952, 953, 956, 133, 803,1094, 802,1091, 812, 246,
 811, 441, 622, 257, 446,1086,1020, 256,1019,1000,
 986, 927, 928, 929, 930, 931, 982, 981, 951, 965,
 940, 964, 963, 961, 959, 970, 971, 972, 973, 974,
 975, 976, 977, 978, 979, 980, 735, 957, 933, 845,
 843, 949, 393, 395, 654, 836, 445, 985, 833, 946,
 832, 791, 349, 344, 350, 351, 788, 342, 340,1004,
 341, 786,1256, 778, 755, 945,1007,1008,1009, 743,
 405, 742, 741, 739, 738, 431, 737, 736, 437, 731,
 730,1016, 729, 676, 664,1021,1022,1023,1024,1025,
1027,1029,1031,1033,1035,1037,1039,1042,1043,1045,
1047, 655, 444, 443, 640, 639,1041, 638, 493, 346,
 944, 260, 603, 602, 161, 162, 599, 597, 591, 253,
 388, 288, 896, 943, 287, 247, 286, 285, 621, 283,
 902, 282, 251, 948, 906, 947, 955,1075, 954, 345,
 870,1070,1069,1067,1066,1014, 198, 196, 197, 200,
 199, 669, 670,1084, 671,1013,1012,1011, 348, 347,
 750, 493, 745,1331,1330, 797,1313,1312,1300,1272,
 654,1072,1073,1093, 521,1109, 521,1113,1114,1117,
 854,1098,1269,1112, 896, 246,1250, 204,1249, 622,
 205, 446,1248, 194,1247, 193,1232,1231,1230,1097,
1229,1111,1228,1227,1110,1173,1170, 608,1157,1156,
1071,1064, 162, 630, 201, 632,1063,1100,1062, 359,
1061,1060,1152,1153,1154,1155,1059,1108,1158,1159,
1160,1161,1144, 445,1058,1105,1057,1099,1056,1055,
1151,1054,1053, 198, 196, 197, 200, 199, 651, 652,
1146,1104,1052, 932, 767, 663, 766, 744, 740, 925,
1162,1163,1174,1165,1166, 891, 372, 372,1168,1169,
 866,1257, 758, 693, 511, 512, 195,1183,1184, 317,
1185,1186, 194, 692, 193,1187, 650, 649, 403, 444,
 443, 545,1192, 402, 401, 493,1103,1203,1205,1206,
1209, 257, 358, 201, 942, 357, 338, 246, 324,1102,
 622, 323, 446, 281, 280,1194,   7, 543, 548,1107,
 153,1106, 184,1116, 152,1115,1204, 151, 150,1220,
1221,1222,1027,1029,1031,1033,1035,1037,1039,1042,
1223,1045,1047, 121, 654,   6, 120,1226,  64,1202,
  63, 183,  13, 580, 445,  62, 926,1199, 189,1237,
1239,1241, 185, 186, 187, 195,  61, 936,  60,  59,
1240, 372,  58,1198, 906, 902, 417,  57,1253,  56,
 441,  55,  54,  53, 827,  52,  51,1252,1258,1260,
1261,1262,1263,1264,  50, 543, 548, 637, 254, 672,
  90,1270,1271,  89,  88, 867, 868, 869,  87,  86,
 444, 443,  85,1274,  84,  83, 493,  82,1197, 675,
  81,  80, 654,  79,  77,1280, 521, 521,1286,1287,
1290,1196,  76,1283,1285,  75, 259,  74,  73,  49,
 622,1201, 446,1200,1208,  48,1207, 782, 784,  47,
 787,1282,1284,  46,  45, 348, 347,  44, 795,  19,
  18,  17,1297,1298,  16,  15,1301,1302,1303,  14,
 827, 913, 914, 383, 835, 381, 918, 919, 673, 601,
1296,1040,1040, 844, 445, 773,1315,1316,1319, 937,
1101,1299, 771,  29,  28,  27,  26,  25, 622,  24,
 446,  23,1237,1239,1241,1253, 526,  22,1304,1322,
1306,1307,1308,1309,1310, 247, 674,  21, 621,1311,
  20,  40,1314,  39,  38,1259,  37,  36,  35,  34,
  33,  32, 526, 936,  31,1327,1328,1329,  30,  12,
 444, 443, 445,  11,  10,   9,   5,   3,   2,   1,
 139,1323,1324, 138, 141, 140, 448, 135, 136, 132,
 131, 774, 500, 502, 721, 386, 938, 360, 378,   0,
1003, 827,   0,   0,1289,   0,1288,   0, 349, 344,
1332,1333,   0, 342, 340,   0, 341,   0,1081,   0,
   0,   0, 198, 196, 197, 200, 199, 941, 444, 443,
 528, 372, 958,   0, 529, 960,   0, 962,   0,   0,
   0,   0,1195,   0,   0,   0, 550,   0,   0,   0,
   0, 192,   0,   0, 194,   0, 193,   0,   0,   0,
 539,   0,1318,1065,1317, 346,   0,   0,1068, 534,
 535, 536, 537, 830, 831, 201,   0,1175, 169,   0,
   0, 983, 984, 527,   0,   0,   0,   0,   0,   0,
   0,   0, 999,   0,1001, 345,   0,   0, 349, 344,
 531,   0, 530, 342, 340,   0, 341, 580, 757,   0,
 396, 198, 196, 197, 200, 199,   0,   0,   0,   0,
   0,   0, 429,   0, 550, 436,   0,   0, 439, 169,
 440, 417,   0,   0,   0, 441,   0, 195,   0, 532,
 533,   0, 538,   0, 159, 160, 161, 162, 164, 163,
 165,   0, 166, 167, 168, 346, 683, 684,   0,   0,
 901,   0, 904, 905,   0,   0, 908, 909,   0,   0,
   0,   0, 540,   0,   0,   0,1040,   0,   0,   0,
   0,   0,   0, 458,   0, 345, 194,   0, 459,   0,
1251,   0,1119,1040, 248, 159, 160, 161, 162, 164,
 163, 165,   0, 166, 167, 168,1090, 201,1092,   0,
1095,   0,   0,   0,   0,   0,   0,   0,   0,   0,
 936, 169,   0,   0,   0,1120,   0,   0, 724, 725,
 726, 727, 728,   0,   0,1134, 250,   0,   0,   0,
   0,   0,   0, 169,   0,   0,   0,   0,   0,1142,
   0,   0,1118, 247,   0, 249, 621, 169,   0,   0,
 628, 372, 631, 734, 633, 634,   0,   0,   0, 195,
   0,   0, 372,   0,   0,   0,   0, 428,   0,   0,
   0,   0, 580,   0,   0,1305,   0, 159, 160, 161,
 162, 164, 163, 165,   0, 166, 167, 168,   0,   0,
1182,   0,   0,   0, 169,1242,1243,1244,1245, 159,
 160, 161, 162, 164, 163, 165,   0, 166, 167, 168,
   0,   0,1181, 159, 160, 161, 162, 164, 163, 165,
   0, 166, 167, 168,1178,   0,1265,1266,1267,1268,
1210,   0,   0,1212,   0,1214,   0,   0,   0,   0,
   0,   0, 580, 169,   0,   0,   0,   0,   0,1179,
   0,   0,   0,   0,  72,   0,   0,1176,   0,   0,
 159, 160, 161, 162, 164, 163, 165,  42, 166, 167,
 168,1224,1225,   0,   0,   0, 441,   0,   0,   0,
1233,   0,1234,   0,   0,   0,   0,   0,   0,   0,
 760,   0,   0,1180,1177,   0,   0,   0,   0,   0,
   0, 348, 347,   0,   0,   0,   0,   0,   0, 159,
 160, 161, 162, 164, 163, 165,   0, 166, 167, 168,
 460,   0,   0,   0, 477,   0, 479,   0,   0, 480,
 481,   0,   0, 145, 621,   0,   0, 146, 147, 465,
   0, 895, 897, 198, 196, 197, 200, 199, 143, 903,
1279,   0,1281, 907,   0, 487,   0, 482, 483, 469,
 169,   0,   0,   0, 470, 484,   0,   0,   0,   0,
   0,   0,   0,   0,   0, 169,   0, 489, 488,   0,
   0,   0, 466,   0, 476,   0, 468, 464, 463,   0,
   0, 348, 347,   0, 427,   0, 490, 491,   0, 626,
 462,   0,   0,   0, 627,   0,   0, 485, 461, 144,
   0,   0,   0,   0, 471, 457, 478,1320, 472,   0,
   0, 456, 467,   0,   0,   0, 159, 160, 161, 162,
 164, 163, 165,   0, 166, 167, 168, 486,   0,   0,
   0, 159, 160, 161, 162, 164, 163, 165,   0, 166,
 167, 168, 492, 454, 455, 175, 176, 177, 178, 179,
 180, 181, 182,   0,  43,   0, 474, 473,   0,   0,
   0, 475,   0,   0,   0, 198, 196, 197, 200, 199,
   0,   0,   0,   0,   0,   0, 856,   0,   0,   0,
   0,1026,1028,1030,1032,1034,1036,   0,   0,   0,
1044,1046, 108, 110,   0,   0, 128,   0, 145,   0,
 130,   0, 146, 147,   0,   0,   0, 172,   0, 857,
   0,   0,   0, 143,   0, 142,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0, 169,   0,   0,
   0,   0,   0, 626,  67, 119, 855, 129, 627,   0,
 169,   0,   0,   0,   0, 107,   0,   0,   0,   0,
   0,   0,   0,   0,   0, 109,   0,   0,   0,   0,
   8,   0,   0,  65,  66,   0,   0,   0, 689,   0,
   0,   0,   0,   0, 144,   0, 149, 148, 106,   0,
   0,   0, 169,   0,  96,  95,   0,   0,   0,   0,
   0,   0, 174, 159, 160, 161, 162, 164, 163, 165,
   0, 166, 167, 168,   0,   0, 159, 160, 161, 162,
 164, 163, 165,   0, 166, 167, 168, 173, 170, 171,
 175, 176, 177, 178, 179, 180, 181, 182,   0,  70,
  69,   0,   0,   0,  68, 114, 460,  71,   0,   0,
 815,  41, 817,   0,   0, 818, 819,   0, 159, 160,
 161, 162, 164, 163, 165, 465, 166, 167, 168,   0,
   0,   0,   0,   0, 248,   0,   0,   0,   0,   0,
   0, 487,   0, 820, 821, 469,   0, 626,   0,   0,
 470, 822, 627,   0,   0,   0,   0,   0,   0,   0,
   0, 169,   0, 489, 488,   0,   0,   0, 466,   0,
 814,   0, 468, 464, 463,   0,   0,   0,   0,   0,
   0,   0, 490, 491,   0,   0, 462,   0,   0,   0,
   0,   0,   0, 823, 461, 249,   0,   0,   0,   0,
 471, 457, 816,   0, 472,   0,   0, 456, 467,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
1236,1238,   0, 824,   0,   0,   0, 159, 160, 161,
 162, 164, 163, 165,   0, 166, 167, 168, 492, 454,
 455, 175, 176, 177, 178, 179, 180, 181, 182,   0,
 460,   0, 474, 473, 477,   0, 479, 475,   0, 480,
 481,   0,   0,   0,   0,   0,   0,   0,   0, 465,
   0,   0,   0,   0,   0,   0,   0,   0, 248,   0,
   0,   0,   0,   0,   0, 487,   0, 482, 483, 469,
   0, 626,   0,   0, 470, 484, 627,   0,   0,   0,
   0,   0,   0,   0,   0, 169,   0, 489, 488,   0,
   0,   0, 466,   0, 476,   0, 468, 464, 463,   0,
   0,   0,   0,   0,   0,   0, 490, 491,   0,   0,
 462,   0,   0,   0,   0,   0,   0, 485, 461, 249,
 169,   0,   0,   0, 471, 457, 478,   0, 472,   0,
   0, 456, 467,   0, 192,   0,   0, 194,   0, 193,
   0,   0,   0,   0,   0,   0,   0, 486,   0,   0,
   0, 159, 160, 161, 162, 164, 163, 165, 201, 166,
 167, 168, 492, 454, 455, 175, 176, 177, 178, 179,
 180, 181, 182,   0, 460,   0, 474, 473, 815,   0,
 817, 475,   0, 818, 819,   0, 159, 160, 161, 162,
 164, 163, 165, 465, 166, 167, 168,   0,   0,   0,
   0,   0, 428,   0,   0,   0,   0,   0,   0, 487,
   0, 820, 821, 469,   0,   0,   0,   0, 470, 822,
 195,   0,   0,   0,   0,   0,   0,   0,   0, 169,
   0, 489, 488,   0,   0,   0, 466,   0, 814,   0,
 468, 464, 463, 192,   0,   0, 194,   0, 193,   0,
 490, 491,   0,   0, 462, 192,   0,   0, 194,   0,
 193, 823, 461,   0,   0,   0,   0, 201, 471, 457,
 816,   0, 472,   0,   0, 456, 467,   0,   0, 201,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0, 824,   0,   0,   0, 159, 160, 161, 162, 164,
 163, 165,   0, 166, 167, 168, 492, 454, 455, 175,
 176, 177, 178, 179, 180, 181, 182,   0, 460,   0,
 474, 473, 815,   0, 817, 475,   0, 818, 819, 195,
   0,   0,   0,   0,   0, 192,   0, 465, 194,   0,
 193, 195,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0, 487,   0, 820, 821, 469,   0, 201,
   0,   0, 470, 822,   0,   0,   0,   0,   0,   0,
   0,   0,   0, 169,   0, 489, 488,   0,   0,   0,
 466,   0, 814,   0, 468, 464, 463, 192,   0,   0,
 194,   0, 193,   0, 490, 491,   0,   0, 462,   0,
   0,   0,   0,   0,   0, 823, 461,   0,   0,   0,
   0, 201, 471, 457, 816,   0, 472,   0,   0, 456,
 467, 195,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0, 824, 169,   0,   0, 159,
 160, 161, 162, 164, 163, 165,   0, 166, 167, 168,
 492, 454, 455, 175, 176, 177, 178, 179, 180, 181,
 182,   0,   0,   0, 474, 473,   0, 248,   0, 475,
   0,   0,   0, 195,   0,   0, 565,   0,   0,   0,
   0,   0, 564,   0,   0,   0, 428,   0,   0,   0,
   0,   0, 576,   0, 169,   0,   0,   0,   0,   0,
   0,   0, 159, 160, 161, 162, 164, 163, 165,   0,
 166, 167, 168, 169, 575, 563,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0, 572,   0, 249,   0,
   0,   0,   0,   0, 783,   0, 198, 196, 197, 200,
 199,   0,   0,   0,   0, 169,   0, 427,   0,   0,
   0, 573,   0,   0,   0,   0,   0, 169,   0, 570,
 159, 160, 161, 162, 164, 163, 165,   0, 166, 167,
 168,   0,   0,   0,   0,   0,   0,   0,   0, 159,
 160, 161, 162, 164, 163, 165,   0, 166, 167, 168,
   0,   0,   0,   0,   0, 574, 571, 560, 849,   0,
   0,   0,   0, 559,   0,   0,   0,   0,   0,   0,
   0, 159, 160, 161, 162, 164, 163, 165,   0, 166,
 167, 168,   0, 159, 160, 161, 162, 164, 163, 165,
   0, 166, 167, 168,   0, 558,   0, 169,   0,   0,
   0,   0,   0,   0,   0, 198, 196, 197, 200, 199,
   0,   0,   0,   0,   0,   0, 418, 198, 196, 197,
 200, 199,   0,   0,   0,   0,   0, 172,   0,   0,
   0,   0,   0, 248,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0, 169,
   0,   0,   0,   0,   0,   0,   0,   0,   0, 418,
 169,   0,   0, 159, 160, 161, 162, 164, 163, 165,
 172, 166, 167, 168,   0, 250, 428,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0, 249,   0,   0, 198, 196, 197,
 200, 199,   0, 169,   0,   0,   0,   0,   0,   0,
   0,   0, 174,   0,   0, 159, 160, 161, 162, 164,
 163, 165,   0, 166, 167, 168, 159, 160, 161, 162,
 164, 163, 165,   0, 166, 167, 168, 173, 170, 171,
 175, 176, 177, 178, 179, 180, 181, 182, 418, 198,
 196, 197, 200, 199,   0, 174,   0,   0,   0, 172,
   0,   0,   0,   0,   0,   0,   0,   0,   0, 159,
 160, 161, 162, 164, 163, 165,   0, 166, 167, 168,
 173, 170, 171, 175, 176, 177, 178, 179, 180, 181,
 182, 418, 169,   0,   0,   0,   0,   0,   0,   0,
   0,   0, 172,   0,   0,   0,   0,   0,   0,   0,
 229, 222, 629, 219, 220, 221, 218, 223, 224, 225,
 227, 226, 228, 217, 207, 211, 212, 213, 215,   0,
   0, 208, 209, 210,   0, 169, 418, 214, 216, 206,
   0,   0,   0,   0, 174,   0,   0, 172,   0,   0,
   0,   0,   0,   0,   0,   0,   0, 430, 159, 160,
 161, 162, 164, 163, 165,   0, 166, 167, 168, 173,
 170, 171, 175, 176, 177, 178, 179, 180, 181, 182,
 169, 418,   0,   0,   0,   0,   0, 174,   0,   0,
   0,   0, 172,   0,   0,   0,   0,   0,   0,   0,
   0, 159, 160, 161, 162, 164, 163, 165,   0, 166,
 167, 168, 173, 170, 171, 175, 176, 177, 178, 179,
 180, 181, 182,   0,   0, 169,   0,   0,   0,   0,
   0,   0, 174,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0, 159, 160, 161, 162,
 164, 163, 165,   0, 166, 167, 168, 173, 170, 171,
 175, 176, 177, 178, 179, 180, 181, 182,   0,   0,
   0,   0,   0,   0,   0,   0,   0, 174,   0,   0,
   0,   0,   0, 293,   0,   0,   0, 294,   0,   0,
   0, 159, 160, 161, 162, 164, 163, 165,   0, 166,
 167, 168, 173, 170, 171, 175, 176, 177, 178, 179,
 180, 181, 182, 304,   0, 290,   0,   0,   0,   0,
   0,   0, 299, 300, 301, 302,   0,   0, 311, 308,
 309,   0,   0,   0,   0,   0, 305,   0, 292,   0,
   0,   0,   0,   0,   0,   0,   0, 291,   0,   0,
   0,   0,   0, 296,   0, 295, 307,   0,   0,   0,
   0,   0, 306,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0, 297, 298,   0, 303,   0, 310,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0, 312 };
short yypact[]={

-1000,-1000,  62,1678,-1000,1678,-1000,-1000,-1000, 266,
 266, 266,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000, 469,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,  53,-1000,-1000,-1000,
 940,-1000,2823,-1000,-1000,-1000,-1000,-183, 878,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000, 865,-1000, 753, 623,1051,1051, 452,-320, 450,
 448, 444, 440, 432, 403, 396,-105,-110,-226,1064,
1063, 877, 875,-1000,-113, 873, 872, 870, 867,2965,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,1147,1029,
1029,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000, 940,1061,1058,-1000,-1000,-1000,-268,-275,
-1000,-1000,-1000,-1000, 394, 393, 392, 391, 384,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
 383, 381,1056, 379,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
 508,-1000,  53,  53,  53,  53,-1000,-1000, -25,-1000,
-1000,  75,1055,1052, 508, 324,  51,   5,-411,-412,
-385,  -8,  53,  53,  53,-1000,-413,-393,-393,-386,
-1000,-1000,-388, 376,-1000,-1000,-1000,-1000, 505,-1000,
 866,-1000,-1000,-1000,-1000,-1000, 371, 369,-1000, 363,
 865,-1000, 680, 623,1051,1051, 362, 361,1044,1043,
1038,2588,-1000,2401,-1000, 857,2808,-179, 857,2853,
-184, 857,-1000, 857,1503,2965,1147,1147,1147,1147,
2577,2577,1147,  53,  53,-342,-342,-342,-342,-342,
-333,-333,-274,-284,-1000,1488,-178,1488,1147,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,1102,-1000,-1000,-1000,
-1000,-1000,-1000,  -1,-1000,-1000,-1000, 591,-1000,-1000,
-1000,-1000,-1000, 494, 494,-1000,-1000,-1000,-1000,-1000,
-1000,1147,1147,1147,1147,1147,2445,2324,1147,2433,
  53,  53,  53,  53,  53,  53,  53,  53,  53,  53,
 309,-1000,-1000,-1000,-1000,-425,-1000,-136,-141, 864,
-1000,-1000,-1000,  24,-1000, 863,-1000,-1000,-1000,-414,
-1000,-1000, 508,-1000,-1000,-1000, 862,-1000, 355,-1000,
 862, 859,-1000, 858,-1000,  53,-390,-203,2588,1147,
1147,1973,-1000, 857,2763, 857,2853, 857, 857,1147,
1147, 494, 494,-333, 853, 851, 850,-1000,-1000,-1000,
-1000,-1000, 354, 353,-1000, 352,-1000, 351,1147,-1000,
-1000,-1000,-1000,-1000, 349, 345, 336,1037,1036,2853,
2631, 847, 334, 731, 721, 697,2853, 830,-1000,2853,
2853,-1000,-1000,-1000,-1000,-1000,-1000, 214, 829,-1000,
-1000,-1000,-1000,-1000, 574, 573,-357,1096,2577,2577,
2008,1147,1147,1033,1023,1147,1147,1147,1147,1147,
1147,1147,1147,1147,1147,1147,1147,1147,1147,1147,
1147,1147,1147,1147,1147,1147,1147,1147,1147,1147,
1147,1147, 546,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,  53,  53,  53,  53,
  53, 828, 826, 825,-306,-308,-1000,-236,-237,-1000,
-1000, 326,-1000,-1000,-1000,-1000, 322,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,2577, 823, 822, 820, 819,1007, 508, 818, 817,
 815,1006,-1000,-1000,-1000,-1000,-1000, 910, 560,-353,
-355,-1000, 908, 526,-360,-362,-1000, 810, 500,1421,
1022,1720,1147,1147,1147,1147,1147, 564, 564,-1000,
-1000, 108, 120, 147, 654, 654,-1000,-1000,-1000,1005,
1003,  53,-1000,-1000,-1000,-1000,-1000,-417,-1000,-393,
-259, 235,-394,-399,-1000,-1000,-1000,-1000, 809,-1000,
-1000,-1000,-1000,-1000, 321, 319,-1000, 318,-1000,-1000,
-1000,-1000,-1000,-1000,-1000, 899,1147,1147,2720,2631,
 807,2853, 802,2853,2853,-1000,-1000, 797,1488,2588,
1488,1147,1147,1829,1147,  -7,1147,-207,1147,-333,
-333, 796, 794,-1000, 317,2853,2261,-162,-1000,-160,
-1000,-172,-1000, 786,2853,-1000, 785,-1000,-181,1147,
2525,2577,1147,1665,1147,1147,-181,1147,1147,1147,
1147,1020,1020,1020,1020,-1000, 887,-1000,-1000,1147,
-1000,-1000,1147,1147,  -9,-1000, -12,-1000, -15, -16,
-1000,-1000,-1000,-1000, -19, -21, -23, -33, -35, -36,
 -39, -44, -46,-326, -48, -49,1015,-1000,-1000,-1000,
-1000,-1000,-350,-313,-1000,-1000,-1000,-1000,-1000, -17,
  53,-288,-279,-178,-1000,-1000,-333, -17,-333,-333,
-1000, -17,-333,-333,-1000,1147,1147,1147,1020,1020,
1147,1147,1147,1020,1020,1147,1147,2577,1147,1009,
  53,1009,1009,1009,1009,1009,-1000,-1000,1002, 784,
-1000,  53,-1000,  43,-1000,  53,-1000,-1000,2588,1147,
1147,1829, 783,2853, 770,-1000,2853, 769,2853,-1000,
-1000,-337,-1000,-1000, 768, 767, 765,-1000,-1000,-1000,
-1000,-1000, 316, 313,-1000, 302,-1000,-1000,-1000,-1000,
-1000,-1000,-1000, 254,1147,1147,1147,1147,1147,1147,
1147,1147,1147,1147,1147,1147,-1000,-1000,-1000,-1000,
 763, 762,2853,2631,2117, 756, 254, 696, 695, 677,
 671, 670, 621,2853, 755,2853,-321,1020, 806, 514,
-1000, 527,-1000,-1000,-1000,1147,1147,1147,-1000,-1000,
-322, 905, 904, 903, 893,-1000,-253,-1000,-1000,-1000,
1147, 520, 754, 752,1147,1147,1147,1147,1147,2577,
2577,2577,2577,2577,2577,2577,2577,1147,2577,2577,
-1000,-196, 301,1001,-1000, 991, 990, 988,-1000,-346,
-347, 987, 985, 983, 975, 970, 969, 967, 965, 960,
1020, 892, 891,-1000,-1000,1020, 890, 889,-1000,-1000,
 959,1009,1009, 496,-1000,-271,1331,-1000,-1000,-1000,
-1000,-1000,-1000,-420, 633,-1000, 508,  53,-1000,-1000,
 231, 751,-1000,-1000,-1000,-1000,-1000, 298, 297,-1000,
 296,-1000,-1000,-1000,-1000,-1000, 254,2853, 743,2631,
 741,2853, 733,1488,1239,1488,1147,1147,1829,1261,
 -52, -67, -76, -78, -79, -80, -81, -82,-327, -83,
 -84,-337,-337, 732, 700,-1000,2853,-1000,-116,-217,
-1000,-1000,-117,-142,-1000,-222,-1000,-146,-1000, 675,
2853, 669,2965,-1000,-120,  53,-123, -86, -89, -90,
2965,1147,1147,1147,1147, 958, 957,1147,1147,1147,
1147,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,1015,1015,
  -2,1015,1015, -97,-1000,-1000,1015,1015, 955, 594,
 954,1371,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,1147,1147,-1000,1147,
1147,-1000,-1000,-1000,1147, 585, 566,-1000,-1000,-1000,
-1000,2577, 641,-1000, 633,-1000,1239,1147,1147,1829,
-1000,2853, 624,-1000,2853, 609,2853,-1000,-1000, 608,
 607,-1000,-1000,-1000,-1000,-1000, 294, 292,-1000, 287,
-1000,-1000,-1000,-1000,-1000,-1000,-1000, 254,1147,1147,
1147,1147,1147,1147,1147,1147,1147,1147,1147,1147,
1147,1147,2853,2631,-1000, 952, 951, 949, 947, 946,
 945,2853,-1000,2853,-1000,-1000,-1000, 509,2577,2577,
2577,-1000,1020,1020,1020,1020,-1000, 484, 943, 941,
 937, 935,-1000,-1000,  53,-1000,-1000,2577,-1000,-1000,
-1000,-1000,-190,-1000, 482, 805,1021,1275,1147,1147,
1147,1147,1147,1020,1020,1020,1020, 931,-165,-1000,
-313,-1000, 918,-422,  53,-1000,-1000,-1000,-1000,-1000,
 284, 283,-1000, 282,-1000,-1000,-1000,-1000,-1000, 254,
 578,2631,-1000,2853,-1000,1488,1488,1147,1147,2382,
 -98, -99,-101,-102,-1000, 569,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,  53,-1000,-1000,-1000,-1000,
1015,1015,-1000,-1000,-1000,-1000,  53,-1000,-1000,-1000,
-1000, 508,-1000,-1000, 917,1147,2577,1147,1009,  53,
1009,1009,1009,1009,1009,-1000,-1000,-1000,-1000,1009,
 916, 915,1009,-1000,-1000,1147,1147,2382,2853, 553,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,1147,1147,1147,1147,1322,-1000,-1000,-1000,-1000,
-1000,1009,1009, 337,-1000, 323,-1000,-1000,-1000,-1000,
-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,-1000,
-1000,1322,-1000,-1000,-1000,1147,2577,-1000, 913, 912,
1009,1009,-1000,-1000 };
short yypgo[]={

   0,1358,1357,1356,1355,  73, 443,1226,  19, 512,
  11,1354,  39,   1,   2, 116,1351,   0,1350,1349,
 783, 182,1348,1347,1345,1344, 316,1343,1340,1081,
   9,  17,  34, 385, 323,1339,1338,1337,1336,1135,
1106,1335,1142,1334,1333,1329,1328,1324,1321,1320,
1319,1318,1317,1316,1314,1313,1311,1310,1307,1297,
1291,1289,1287,1286,1285,1284,1283, 322,  15,1282,
   5,1279,1275,1269,1265,1263,1259,1255,1254,1251,
1250,1249,1247,1244,1243,1239,1235,1229,1228,1227,
1225,1222, 608,  62,  25,   7,  42,1214,1213,1211,
1210,1207, 315,  10, 526, 134, 111, 110, 121,  76,
1205,1204,1202,1199,  60,  54,  12, 146, 144,  52,
1198,1194,1193,1190, 330, 321,   3,1188,1184,  29,
1176,1175,1173,1172,1171,1169, 329, 589, 327,  18,
 494,1167,1162,1159,1158,1156, 317, 303, 291,1145,
1140,1138, 282, 274,  13, 320,1136,1133,1118,1117,
1114,1110,   8,1105 };
short yyr1[]={

   0,  35,  36,  37,  37,  37,  37,  39,  38,  38,
  40,  40,  40,  40,  40,  42,  42,  45,  44,  44,
  44,  44,  44,  44,  44,  44,  44,  44,  44,  46,
  47,  47,  47,  47,  47,  47,  54,  55,  55,  55,
  55,  56,  48,  48,  48,  48,  49,  50,  51,  52,
  53,  43,  43,  43,  43,  43,  43,  43,  43,  43,
  43,  57,  63,  67,  67,  68,  69,  68,  71,  68,
  72,  68,   2,   3,  73,   1,  16,  16,  60,  74,
  74,  61,  62,  59,  75,  75,  64,  65,  65,  65,
  65,  66,   4,   4,  58,  41,  41,  41,  41,  41,
  41,  76,  76,  76,  76,  76,  76,  82,  82,  82,
  82,  88,  88,  88,  88,  88,  89,  89,  89,  89,
  90,  90,  90,  90,  91,  91,  91,  91,  91,  83,
  83,  83,  83,  83,  83,  84,  84,  84,  84,  98,
  98,  98,  98,  98,  98,  98,  98, 102, 102,  99,
  99,  99,  99,  99,  99,  99,  99, 105, 105, 100,
 100, 100, 100, 100, 100, 100, 100, 108, 108, 101,
 101, 101, 101, 101, 101, 101, 101, 109, 109,  85,
  85,  85,  85, 110, 110, 110, 110, 110, 110, 110,
 110, 114, 114, 111, 111, 111, 111, 111, 111, 111,
 111, 111, 111, 111, 111, 111, 111, 112, 112, 112,
 112, 112, 112, 112, 112, 119, 119, 113, 113, 113,
 113, 113, 113, 113, 113, 113, 113, 113, 113, 113,
 113,  86,  86,  86,  86, 120, 120, 120, 121, 122,
 122, 122, 123,  87,  87, 125, 125, 125,  77, 128,
 128, 128, 128, 128, 128, 128, 128,  78,  78,  78,
  78,  78,  78, 130, 130, 130, 130, 130, 130, 130,
 130, 131, 131, 131, 131, 131, 131, 131, 131, 131,
 131, 131, 131, 131, 131, 131, 131, 131, 131, 131,
 131, 131, 131, 131, 131, 131, 131, 131, 131, 131,
 131, 132, 132, 132, 132, 132, 132, 132, 132, 133,
 133, 133, 133, 134, 134, 135, 139, 139,  79,  79,
  79,  79,  79, 141, 141, 141, 141, 142, 142, 142,
 142, 143, 143, 144, 145, 145, 145, 145,  80,  80,
  80,  80,  80,  80, 149, 149, 149, 149, 149, 150,
 150, 129, 151, 151, 151, 151, 151, 151, 151, 152,
 152, 153, 153, 154, 154,   5,   5,   5,   5,   6,
   6, 137, 137, 137, 137, 137, 137, 137, 137, 137,
 137, 137, 137, 137, 137, 137,  97,   8,   8,   8,
   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,
   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,
   8,   8,   8,   8,   8,   8,   8,   8,   8,   8,
   8,   8,   8, 136, 136, 136, 138, 138, 138, 140,
 155, 126, 126, 127, 127,  93,  96,  95,  94, 103,
 107, 116, 118, 104, 106, 115, 117, 146, 147,  92,
  92, 156, 156, 156, 156, 158, 158, 158, 158, 158,
 158, 158, 158, 158, 158, 158, 158, 158, 158, 158,
 158, 158, 158, 158, 158, 158,   9,   9, 159, 159,
 159, 159, 159, 159, 159, 159, 159, 159, 159, 159,
 159, 159, 159, 159, 159, 159, 159, 159, 159, 159,
 159, 159, 159, 159, 159, 159, 159, 159, 159, 159,
 159, 159, 159, 159, 159, 124, 124, 124, 124, 124,
 124, 124, 124, 124, 124, 124, 124, 124, 124, 124,
 160, 160, 160, 160, 160, 160, 160, 160, 160, 160,
 160, 160, 160, 160, 160, 160, 160, 160, 160, 160,
  10,  10,  10,  10,  10, 161, 161, 161, 161, 161,
 161, 161, 161, 161, 161, 161, 161, 161, 161, 161,
 161, 161, 161, 161, 161, 161, 161,  11,  11,  12,
  12,  12,  12,  12,  13,  14,  14,  14,  14, 157,
 157,  15,  15,  15,  15,  15,  15,  15,  15,  17,
  17,  17,  17,  17,  17,  17,  17,  17,  17,  17,
  18,  19,  20,  21,  22,  23,  24,  25,  26, 148,
 148, 148,  27,  28,  30,  29,  31,  32,  33,  33,
  33,  33,  33,  33,  33,  33,  33,  33,  33,  33,
  33,  33,  33,  34,  34,  34,  34,  34,  34,  34,
  70, 163,  70, 162,  81,  81,  81,  81,  81,   7,
   7,   7 };
short yyr2[]={

   0,   2,   0,   3,   2,   1,   0,   1,   2,   1,
   2,   2,   2,   1,   1,   1,   1,   2,   1,   1,
   1,   1,   1,   1,   1,   1,   1,   1,   1,   3,
   3,   4,   4,   4,   4,   4,   3,   3,   5,   7,
   9,   3,   3,   3,   4,   3,   3,   3,   3,   2,
   3,   1,   1,   1,   1,   1,   1,   1,   1,   1,
   1,   3,   3,   3,   1,   1,   0,   4,   0,   5,
   0,   4,   1,   1,   0,   3,   3,   0,   3,   3,
   1,   2,   2,   3,   3,   1,   4,   2,   2,   2,
   2,   4,   2,   2,   2,   1,   1,   1,   1,   1,
   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
   1,   5,   7,   9,   3,   3,   5,   7,   9,   3,
   5,   7,   9,   3,   5,   7,   9,   3,   3,   2,
   4,   6,   1,   3,   5,   1,   1,   1,   1,   4,
   6,   8,   2,   3,   5,   7,   1,   3,   3,   4,
   6,   8,   2,   3,   5,   7,   1,   3,   3,   4,
   6,   8,   2,   3,   5,   7,   1,   3,   3,   4,
   6,   8,   2,   3,   5,   7,   1,   3,   3,   1,
   1,   1,   1,   4,   6,   8,   2,   3,   5,   7,
   1,   3,   3,   6,   8,  10,   4,   5,   7,   9,
   6,   8,  10,   4,   5,   7,   9,   4,   6,   8,
   2,   3,   5,   7,   1,   3,   3,   6,   8,  10,
   4,   5,   7,   9,   6,   8,  10,   4,   5,   7,
   9,   1,   1,   1,   1,   6,   8,  10,   4,   5,
   7,   9,   3,   3,   2,   2,   1,   0,   1,   4,
   6,   8,   2,   3,   5,   7,   1,   1,   1,   1,
   1,   1,   1,   3,   2,   2,   1,   3,   2,   2,
   1,   5,   7,  10,   5,   4,   7,   6,   9,   8,
   4,   6,   8,   4,   3,   6,   5,   8,   7,   5,
   7,   9,   4,   6,   8,   4,   6,   8,   3,   5,
   7,   7,   9,  11,   5,   6,   8,  10,   4,   5,
   4,   5,   4,   7,   7,   3,   2,   2,   1,   1,
   1,   1,   1,   3,   3,   3,   3,   3,   3,   3,
   3,   3,   3,   3,   3,   3,   3,   3,   1,   1,
   1,   1,   2,   1,   4,   4,   4,   4,   4,   6,
   6,   6,   5,   3,   3,   1,   1,   1,   2,   2,
   2,   2,   2,   2,   2,   1,   3,   5,   0,   1,
   0,   5,   5,   3,   3,   7,   7,   7,   7,   7,
   7,   5,   5,   5,   5,   3,   2,   1,   1,   1,
   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
   1,   1,   1,   2,   1,   1,   1,   2,   2,   2,
   2,   2,   2,   2,   2,   2,   2,   2,   2,   1,
   1,   1,   2,   2,   2,   2,   2,   2,   2,   5,
   5,   1,   1,   2,   2,   3,   3,   3,   3,   6,
   6,   6,   6,   6,   6,   6,   6,   4,   4,   1,
   1,   1,   1,   1,   1,   6,   6,   6,   8,   8,
   8,   8,   8,   8,   8,   8,   5,   5,   5,   5,
   5,   5,   5,   5,   3,   3,   3,   0,   5,   5,
   9,   5,   7,   7,   5,   5,   9,   4,   4,   4,
   5,   5,   5,   4,   8,   8,   6,   6,   5,   8,
   8,   4,   6,   4,   4,   6,   6,   4,   4,   4,
   4,   4,   4,   4,   6,   6,   8,   6,   8,   6,
   6,   6,   6,   4,   7,   9,   7,   8,   6,   7,
   6,   8,   6,   8,   6,   6,   6,   6,   4,   7,
   9,   7,   8,   6,   7,   5,   4,   4,   4,   4,
   3,   3,   3,   5,   0,   4,   6,  10,   6,  10,
   9,  13,   5,   9,   9,  13,   5,   9,   5,   9,
   5,   9,   5,   9,   5,   9,   1,   3,   0,   5,
   5,   3,   3,   0,   1,   1,   1,   1,   1,   3,
   3,   1,   1,   1,   1,   1,   1,   1,   1,   1,
   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,
   1,   1,   1,   1,   3,   1,   1,   1,   1,   3,
   3,   3,   3,   3,   3,   3,   3,   3,   3,   3,
   2,   2,   2,   1,   1,   2,   3,   1,   1,   2,
   1,   0,   4,   1,   1,   1,   5,   5,   1,   2,
   1,   0 };
short yychk[]={

-1000, -35, -36, -37, 256, -38, -39, -40, 362, -41,
 -43, -44, -45, -42, -76, -77, -78, -79, -80, -81,
 -57, -58, -59, -60, -61, -62, -63, -64, -65, -66,
 -46, -47, -48, -49, -50, -51, -52, -53, -54, -55,
 -56, 443,  59, 256, -82, -83, -84, -85, -86, -87,
-128,-130,-131,-132,-133,-134,-135,-141,-142,-143,
-144,-145,-149,-150,-151, 365, 366, 336, 436, 432,
 431, 439,  46, -88, -89, -90, -91, -97, -92, -98,
 -99,-100,-101,-110,-111,-112,-113,-120,-121,-122,
-123,-124,-129,-136,-138, 387, 386, -17,-139,-146,
-147,-117,-118,-104,-103,-148, 380, 347, 294, 357,
 295,-152,-153,-154, 437, -93, -94, -96, -95, 337,
-156,-157,-102,-105,-108,-109,-114,-119, 298, 339,
 302, -18, -19, -20, -21, -23, -22, -26, -27, -28,
 -24, -25, 317, 315, 376, 300, 304, 305, 379, 378,
-158,-159,-160,-161, -15,-106,-107,-115,-116, 408,
 409, 410, 411, 413, 412, 414, 416, 417, 418, 342,
 420, 421, 309, 419, 394, 422, 423, 424, 425, 426,
 427, 428, 429, -39, -40, -42, -42, -42,  58, -29,
 -33, -34,  40,  45,  43, 126, 443, 444, 442, 446,
 445,  64, -31,-140, -33,  40, 286, 271, 278, 279,
 280, 272, 273, 274, 284, 275, 285, 270, 263, 260,
 261, 262, 258, 264, 265, 266, 268, 267, 269, 257,
 -92,-102,-105,-108,-109,-114,-117,-118,-119, -17,
-124,-129,-136,-138, 387, 386,-103,-104, 315, 376,
 357,  44,-125,  44,-127,-137,  44,  40,-137,  -7,
  44,  -6,-137,  -6,  61, 405,  61,  61,  61,  61,
  61,  61,  61, 301, 301, 390, 307, 401, 403, 407,
  40,  40,  44,  44, 301,  44,  44,  44,  44,  -8,
 320, 352, 343, 288, 292, 360, 358, 397, 398, 327,
 328, 329, 330, 400, 318, 341, 367, 361, 334, 335,
 402, 333, 430, -17, -31,-140,-155,  40, -31,-140,
-155, -31,-140,  40,  40, 350, 395, 417, 350, 395,
 417,  61,  61,  61,  61,  61,  61,  61,  40,  61,
  43,  45,  42,  47,  38, 124,  94, 441, 440,  37,
 -33, -33, -33, -33, 446,  45, -34,  40,  40, 418,
  -2, 259, 443,  46, 444, 444, 443,  46, 444,  45,
 443, -32, -33, -32, -32, 444, -67, -68,  -1, 443,
 -67, -74, 443, -75, 443,  61,  -4,  47,  44,  61,
  61,  61,-125,-137,  44,-137,  -7,  -6,  -6,  61,
  61,  40,  40,  40, -93, -92, -96,-102,-105,-108,
-109,-114,-117,-118,-119, -17,-129,-104, 298,-126,
 -94, -95, -93, -96,-103, -17,-104, 376, 315,  -7,
 319, -92, -17, 312, 340, 303,  -7, -92, 319,  -7,
  -7,-104,-103,-106,-107,-115,-116, -17, -29,-146,
-147,-117,-118,-148, 420, 421, 388, 382,  40,  45,
 287, 375, 367, 355, 354, 306, 349, 389, 353, 326,
 331, 381, 385, 434, 433, 438, 351, 291, 383, 293,
 296, 297, 324, 325, 332, 374, 404, 322, 345, 344,
 363, 364, 419, -15,  -8, -17, -17, -17, -17, -17,
 -29, -17, -29, -17, -32, -32, -26, -26, -26, -26,
 -26, -20, -20,-153, 379, 378,-152, 379, 378, -94,
 -95, -17, -93, -94, -95, -96, -17, 341, 288, 292,
 360, 358, 397, 398, 327, 328, 329, 330, 400, 318,
 430, 299, -21, -20, -21, -29, -31, -33, -20, -21,
 -29, -31, -17, -17, -17, -17, -17, -17, 420, 388,
 382, -32, -17, 421, 388, 382, -32, -17, -17, -33,
 356, 393, 323, 348, 392, 311, 289, -33, -33, -33,
 -33, -33, -33, -33, -33, -33, -33,  41, 446, 312,
 312,  44, 276, 281, 282, 283, 277,  44, 444,  44,
  61, -73,  44,  44, -32, 443, 376, 315, -92,-102,
-105,-108,-109,-114,-117,-118,-119, -17,-129, -17,
 -17,-104,-103,-117,-118, -17,  40,  45,  -7, 319,
 -92,  -7, -92,  -7,  -7, -17, -17, -20,  44,  44,
  44,  61,  61,  61,  61, -17,  61,  61,  61,  40,
  40, -92, -92,-126, -17,  44,  61,  44,  41,  44,
  41,  44,  41, -92,  44,  -5, -92,  -5,  44,  42,
  43,  45, 290, 369, 407, 310,  44,  43,  45,  43,
  45, 420, 421, 420, 421, -17, -17, -17, -17,  40,
 -17, -17,  40,  40, -17, -17, -17, -17, -17, -17,
 -17, -17, -17, -17, -17, -17, -17, -17, -17, -17,
 -17, -17, -17, -17, -17, -17, -17, -17, -17, -17,
 -17, -11,  44,  40, -29, -29, -29, -29, -29,  44,
  44,  44,  61,  61, -29, -17,  44,  44,  44,  44,
  41,  44,  44,  44,  41,  42,  43,  45, 420, 420,
  42,  43,  45, 421, 421,  44,  47,  47,  40, -17,
  40, -17, -17, -17, -17, -17,  41,  41, -31, 444,
 -68, -69, 362, -72, -16,  91, 443, 443,  44,  61,
  61,  61, -92,  44, -92,-126,  44, -92,  44,  -5,
  -5,  44, -94, -95, -93, -92, -96,-102,-105,-108,
-109,-114,-117,-118,-119, -17,-129, -94, -95, -17,
 -17,-117,-118, -17, 351, 291, 383, 293, 296, 297,
 324, 325, 332, 374, 404, 299, -17,-104,-103, -17,
 -20, -20,  44,  44,  61, -92, -17, 340, 303, 312,
 303, 312, 340,  44, -92,  44,-139, -17, -17, 303,
 -32, -17, -32, -17, -17, 351, 291, 324, -17, -17,
-139, -17, -17, -17, -17,  -9,  40,  -9,  -9,  -9,
  43, -17, -17, -17, 299, 299, 299, 299, 299, 299,
 299, 299, 299, 299, 299, 299, 299, 406, 299, 299,
 -10,  40, 419, -13, 399, -29, -21, -29,-154, 379,
 378, -20, -21, -29, -20, -20, -21, -29, -20, -20,
 -17, -17, -17,  -9,  -9, -17, -17, -17,  -9,  -9,
 -17, -17, -17, -17, -12,  40, -33, -12, -12, -12,
 -12, -12,  41,  44, -70,-162, -33, -71,  -3, 259,
 -32, -92,-102,-105,-108,-109,-114,-117,-118,-119,
 -17,-129, -17, -17,-117,-118, -17,  44, -92,  44,
 -92,  44, -92,  44,  44,  44,  61,  61,  61, 369,
 -17, -17, -17, -17, -17, -17, -17, -17, -17, -17,
 -17,  44,  44, -92, -92,-126,  44,  41,  44,  44,
  41,  41,  44,  44,  41,  44,  41,  44,  41, -92,
  44, -92, 405,  -9,  43,  45,  43, -17, -17, -17,
 405,  42,  42,  42,  42, 359, -17,  43,  45,  44,
  44, -17, -17, -17, -17, -17, -29, -17, -29, -17,
 -29, -17, -29, -17, -29, -17, -29, -17, -30, -17,
 -33, -30, -17, -17, -29, -17, -29, -17, 391, 368,
 321,  61,  41,  41,  41,  41,  41,  41,  41,  41,
  41,  41,  41,  41,  41,  -9,  42,  42,  -9,  42,
  42,  41, -12, -12,  47, -13, -14, 370, 371, 372,
 373,  47, 444,  44, -70,  93,  44,  61,  61,  61,
 -92,  44, -92,-126,  44, -92,  44, -94, -95, -93,
 -96,-102,-105,-108,-109,-114,-117,-118,-119, -17,
-129, -94, -95, -17, -17,-117,-118, -17, 351, 291,
 324, 299, 299, 299, 299, 299, 299, 299, 299, 406,
 299, 299,  44,  44, -92, 303, 340, 303, 312, 340,
 312,  44, -92,  44,  -8, 303, -32, 303, 299, 299,
 299,  -8, -17, -17, -17, -17,  41,  41, -17, -17,
 -17, -17, -10, -10,  58, -10, -10, 299, -10, -10,
  41,  41,  44,  41, -17, -33, 356, 393, 323, 348,
 392, 311, 289, -17, -17, -17, -17, -17,  44,  41,
  44,  41, -17,  44,-163,-102,-105,-108,-109,-114,
-117,-118,-119, -17,-129, -17, -17,-117,-118, -17,
 -92,  44, -92,  44, -92,  44,  44,  61,  61,  61,
 -17, -17, -17, -17, -92, -92,-126,  41,  41,  41,
  41,  41,  41, -92, -92,  45, -29, -17, -29, -17,
 -30, -17,  -9,  -9,  -9,  -9,  47,  41,  41,  41,
  41, -33, -30, -17, 321,  47,  47,  40, -17,  40,
 -17, -17, -17, -17, -17,  -9,  -9,  -9,  -9,  41,
 -14, -13,  41, 444,-162,  61,  61,  61,  44, -92,
-126, -92, -94, -95, -94, -95, -17, -17,-117,-118,
 -17, 299, 299, 299, 299,  44, -32, -10, -10, -32,
  41, -17, -17, -17, -12, -33, -12, -12, -12, -12,
 -12, -12,  41,  41, -12, -17, -17,-117,-118, -17,
 -92,  44,-126, -12, -12,  47,  47,-126, -17, -17,
  41,  41, -12, -12 };
short yydef[]={

   2,  -2,   6,   1,   5,   0,   4,   9,   7,   0,
   0,   0,  13,  14,  95,  96,  97,  98,  99, 100,
  51,  52,  53,  54,  55,  56,  57,  58,  59,  60,
  18,  19,  20,  21,  22,  23,  24,  25,  26,  27,
  28,   0,  15,  16, 101, 102, 103, 104, 105, 106,
 248, 257, 258, 259, 260, 261, 262, 318, 319, 320,
 321, 322, 338, 339, 340, 341,   0, 343, 654, 655,
   0, 658,   0, 107, 108, 109, 110,   0, 132, 135,
 136, 137, 138, 179, 180, 181, 182, 231, 232, 233,
 234, 247, 256, 266,  -2, 370, 370,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0, 355, 356, 357,   0,   0,   0,   0,   0,   0,
 449, 450, 146, 156, 166, 176, 190, 214,   0,   0,
   0, 599, 600, 601, 602, 603, 604, 605, 606, 607,
 608, 609,   0,   0,   0, 619, 620, 621,   0,   0,
 451, 452, 453, 454,   0,   0,   0,   0,   0, 610,
 611, 612, 613, 615, 614, 618, 622, 623, 616, 617,
   0,   0,   0,   0, 576, 591, 592, 593, 594, 595,
 596, 597, 598,   3,   8,  10,  11,  12,  17, 342,
 625, 628,   0,   0,   0,   0, 643, 644,   0, 647,
 648,   0,   0,   0, 626,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,  49,   0,   0,   0,   0,
  81,  82,   0,   0,  87,  88,  89,  90,   0,  94,
 129, 142, 152, 162, 172, 186,   0,   0, 210,   0,
 247, 252, 264,  -2, 370, 370,   0,   0,   0,   0,
   0,   0, 244,   0, 246,  -2,   0,   0,  -2,   0,
 660, 661, 369, 661,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0, 358,   0,   0,   0,   0, 386,
 387, 388, 389, 390, 391, 392, 393, 394, 395, 396,
 397, 398, 399, 400, 401, 402,   0, 404, 405, 406,
 419, 420, 421,   0, 423, 424, 425,   0, 426, 427,
 428, 316, 317,   0,   0, 359, 361, 363, 360, 362,
 364,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0, 640, 641, 642, 645,   0, 649,   0,   0,   0,
  29,  72,  30,   0,  36,  37,  41,  42,  43,   0,
  45,  46, 627,  47,  48,  50,  61,  64,  65,  74,
  62,  78,  80,  83,  85,   0,   0,   0,   0,   0,
   0,   0, 243,  -2,   0,  -2,   0, 661, 661,   0,
   0,   0,   0,   0,   0, 133,   0, 143, 153, 163,
 173, 187,   0,   0, 211,   0, 253,   0,   0, 245,
 433, 434, 431, 432,   0,   0,   0,   0,   0,   0,
   0, 284,   0,   0,   0,   0,   0, 298, 659, 368,
 368,  -2,  -2, 177, 178, 215, 216, 242, 333, 325,
 326, 329, 330, 335,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0, 578, 589, 315, 323, 324, 327, 328,  -2,
 331,  -2, 332, 334, 336, 337,   0,   0,   0,   0,
   0,   0,   0, 353,   0,   0, 354,   0,   0, 114,
 119,   0, 115, 123, 127, 128,   0, 403, 407, 408,
 409, 410, 411, 412, 413, 414, 415, 416, 417, 418,
 422,   0,   0,   0,   0,   0,   0,  -2,   0,   0,
   0,   0, 590, 157, 158, 191, 192,   0,   0,   0,
   0, 474,   0,   0,   0,   0, 475,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0, 629, 630, 631,
 632, 633, 634, 635, 636, 637, 638, 639, 646,   0,
   0,   0,  31,  32,  33,  34,  35,   0,  44,   0,
  -2,  77,   0,   0,  86,  91,  92,  93, 130, 139,
 149, 159, 169, 183,   0,   0, 207,   0, 249, 196,
 203, 167, 168, 220, 227, 238,   0,   0,   0,   0,
 275,   0, 292, 368, 368, 147, 148,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0, 280, 283, 308,   0,   0,   0,   0, 373,   0,
 374,   0, 385, 295,   0, 310, 365, 312,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0, 477, 477, 477, 477, 510,   0, 487, 488,   0,
 489, 493,   0,   0,   0, 501,   0, 503, 504, 507,
 508, 509, 511, 512, 513,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0, 554, 546, 547, 548,
 549, 555,   0,   0, 344, 345, 346, 347, 348,   0,
   0,   0,   0,   0, 523, 538,   0,   0,   0,   0,
 447,   0,   0,   0, 448,   0,   0,   0, 477, 477,
   0,   0,   0, 477, 477,   0,   0,   0,   0, 583,
   0, 583, 583, 583, 583, 583, 656, 657,   0,  38,
  63,   0,  68,   0,  75,   0,  79,  84,   0,   0,
   0,   0, 271,   0, 274, 304,   0, 289,   0, 309,
 311,   0, 111, 116,   0, 134,   0, 144, 154, 164,
 174, 188,   0,   0, 212,   0, 254, 120, 124, 197,
 204, 221, 228, 239,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0, 438, 436, 437, 435,
   0,   0,   0,   0,   0, 286,   0,   0,   0,   0,
   0,   0,   0,   0, 299,   0,   0, 477, 478, 481,
 484, 479, 485, 490, 491,   0,   0,   0, 492, 498,
   0,   0,   0,   0,   0, 466,   0, 467, 470, 471,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
 545,   0,   0,   0, 584,   0,   0,   0, 352,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
 477,   0,   0, 468, 472, 477,   0,   0, 469, 473,
   0, 583, 583,   0, 562,   0,   0, 566, 568, 570,
 572, 574, 429,   0,  67, 650, 653,   0,  71,  73,
   0, 131, 140, 150, 160, 170, 184,   0,   0, 208,
   0, 250, 193, 200, 217, 224, 235,   0,   0,   0,
 277,   0, 293,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0, 281, 285, 305,   0, 371,   0,   0,
 381, 372,   0,   0, 383,   0, 382,   0, 384, 296,
   0, 366,   0, 455,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0, 496, 502, 505, 506, 514, 515, 530, 517, 532,
 519, 534, 520, 535, 521, 536, 522, 537, 554, 554,
   0, 554, 554,   0, 528, 543, 554, 554,   0,   0,
   0,   0, 577, 349, 351, 350, 430, 443, 445, 444,
 446, 439, 441, 440, 442, 456,   0,   0, 457,   0,
   0, 497, 556, 558,   0,   0,   0, 585, 586, 587,
 588,   0,  39, 651,  69,  76,   0,   0,   0,   0,
 272,   0, 276, 301,   0, 290,   0, 112, 117,   0,
   0, 145, 155, 165, 175, 189,   0,   0, 213,   0,
 255, 121, 125, 198, 205, 222, 229, 240,   0,   0,
   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
   0,   0,   0,   0, 288,   0,   0,   0,   0,   0,
   0,   0, 300,   0, 314, 483, 482,   0,   0,   0,
   0, 313, 477, 477, 477, 477, 476,   0,   0,   0,
   0,   0, 524, 539,   0, 526, 541,   0, 529, 544,
 550, 551,   0, 552,   0,   0,   0,   0,   0,   0,
   0,   0,   0, 477, 477, 477, 477,   0,   0, 581,
   0, 582,   0,   0,   0, 141, 151, 161, 171, 185,
   0,   0, 209,   0, 251, 194, 201, 218, 225, 236,
   0,   0, 279,   0, 294,   0,   0,   0,   0,   0,
   0,   0,   0,   0, 282, 287, 306, 375, 376, 379,
 380, 377, 378, 297, 367,   0, 516, 531, 518, 533,
 554, 554, 458, 462, 459, 463,   0, 499, 500, 494,
 495, 624, 527, 542,   0,   0,   0,   0, 583,   0,
 583, 583, 583, 583, 583, 460, 464, 461, 465, 583,
   0,   0, 583,  40, 652,   0,   0,   0,   0, 278,
 302, 291, 113, 118, 122, 126, 199, 206, 223, 230,
 241,   0,   0,   0,   0,   0, 486, 525, 540, 480,
 553, 583, 583,   0, 563,   0, 567, 569, 571, 573,
 575, 560, 579, 580, 564, 195, 202, 219, 226, 237,
 273,   0, 307, 557, 559,   0,   0, 303,   0,   0,
 583, 583, 561, 565 };
#
# define YYFLAG -1000
# define YYERROR goto yyerrlab
# define YYACCEPT return(0)
# define YYABORT return(1)

/*      parser for yacc output  */

#ifdef YYDEBUG
int yydebug = 1; /* 1 for debugging */
#endif
YYSTYPE yyv[YYMAXDEPTH]; /* where the values are stored */
int yychar = -1; /* current input token number */
int yynerrs = 0;  /* number of errors */
short yyerrflag = 0;  /* error recovery flag */

yyparse() {

	short yys[YYMAXDEPTH];
	short yyj, yym;
	register YYSTYPE *yypvt;
	register short yystate, *yyps, yyn;
	register YYSTYPE *yypv;
	register short *yyxi;

	yystate = 0;
	yychar = -1;
	yynerrs = 0;
	yyerrflag = 0;
	yyps= &yys[-1];
	yypv= &yyv[-1];

 yystack:    /* put a state and value onto the stack */

#ifdef YYDEBUG
	if( yydebug  ) printf( "state %d, char 0%o\n", yystate, yychar );
#endif
		if( ++yyps> &yys[YYMAXDEPTH] ) { yyerror( "yacc stack overflow" ); return(1); }
		*yyps = yystate;
		++yypv;
		*yypv = yyval;

 yynewstate:

	yyn = yypact[yystate];

	if( yyn<= YYFLAG ) goto yydefault; /* simple state */

	if( yychar<0 ) if( (yychar=yylex())<0 ) yychar=0;
	if( (yyn += yychar)<0 || yyn >= YYLAST ) goto yydefault;

	if( yychk[ yyn=yyact[ yyn ] ] == yychar ){ /* valid shift */
		yychar = -1;
		yyval = yylval;
		yystate = yyn;
		if( yyerrflag > 0 ) --yyerrflag;
		goto yystack;
		}

 yydefault:
	/* default state action */

	if( (yyn=yydef[yystate]) == -2 ) {
		if( yychar<0 ) if( (yychar=yylex())<0 ) yychar = 0;
		/* look through exception table */

		for( yyxi=yyexca; (*yyxi!= (-1)) || (yyxi[1]!=yystate) ; yyxi += 2 ) ; /* VOID */

		while( *(yyxi+=2) >= 0 ){
			if( *yyxi == yychar ) break;
			}
		if( (yyn = yyxi[1]) < 0 ) return(0);   /* accept */
		}

	if( yyn == 0 ){ /* error */
		/* error ... attempt to resume parsing */

		switch( yyerrflag ){

		case 0:   /* brand new error */

			yyerror( "syntax error" );
		yyerrlab:
			++yynerrs;

		case 1:
		case 2: /* incompletely recovered error ... try again */

			yyerrflag = 3;

			/* find a state where "error" is a legal shift action */

			while ( yyps >= yys ) {
			   yyn = yypact[*yyps] + YYERRCODE;
			   if( yyn>= 0 && yyn < YYLAST && yychk[yyact[yyn]] == YYERRCODE ){
			      yystate = yyact[yyn];  /* simulate a shift of "error" */
			      goto yystack;
			      }
			   yyn = yypact[*yyps];

			   /* the current yyps has no shift onn "error", pop stack */

#ifdef YYDEBUG
			   if( yydebug ) printf( "error recovery pops state %d, uncovers %d\n", *yyps, yyps[-1] );
#endif
			   --yyps;
			   --yypv;
			   }

			/* there is no state on the stack with an error shift ... abort */

	yyabort:
			return(1);


		case 3:  /* no shift yet; clobber input char */

#ifdef YYDEBUG
			if( yydebug ) printf( "error recovery discards char %d\n", yychar );
#endif

			if( yychar == 0 ) goto yyabort; /* don't discard EOF, quit */
			yychar = -1;
			goto yynewstate;   /* try again in the same state */

			}

		}

	/* reduction by production yyn */

#ifdef YYDEBUG
		if( yydebug ) printf("reduce %d\n",yyn);
#endif
		yyps -= yyr2[yyn];
		yypvt = yypv;
		yypv -= yyr2[yyn];
		yyval = yypv[1];
		yym=yyn;
			/* consult goto table to find next state */
		yyn = yyr1[yyn];
		yyj = yypgo[yyn] + *yyps + 1;
		if( yyj>=YYLAST || yychk[ yystate = yyact[yyj] ] != -yyn ) yystate = yyact[yypgo[yyn]];
		switch(yym){
			
case 2:{
		      memset( (char *) &ilnode, 0, sizeof(ILNODE) );
		  } break;
case 5:{
		      memset( (char *) &ilnode, 0, sizeof(ILNODE) ); 
		      SYNTAX_ERROR( "Illegal statement.");
		      advance_to_semi();
		      yyerrok; 
		      yyclearin; 
		  } break;
case 7:{
		      ++yylineno;
		      WRITE_INTERMEDIATE( &yylineno, 0, NEW_STATEMENT,  NULL );
		  } break;
case 8:{
		      memset( (char *) &ilnode, 0, sizeof(ILNODE) );
		      pc->value = newpc;
		      WRITE_INTERMEDIATE( &yylineno, 0, NEW_STATEMENT,  NULL );
		  } break;
case 9:{
		      memset( (char *) &ilnode, 0, sizeof(ILNODE) );
		      pc->value = newpc;
		      WRITE_INTERMEDIATE( &yylineno, 0, NEW_STATEMENT,  NULL );
		  } break;
case 16:{
		     memset( (char *) &ilnode, 0, sizeof(ILNODE) ); 
		     SYNTAX_ERROR( "Syntax error or missing semicolon at end of previous line." );
		     advance_to_semi();
		     yyerrok; 
		     yyclearin; 
		  } break;
case 17:{
		      /* check for error first */
		      if ((current_symbol=symbol_lookup(last_identifier))) {
			  if (IS_DEFINED(current_symbol->type) ) {
			       USER_ERROR( "Multiply defined label." );
			  } else {
			       current_symbol->type |= pc->type;
			       current_symbol->value = newpc;
			       current_symbol->section_num = pc->section_num;
			       current_symbol->length = 1L;
			  }
		      } else {
			  current_symbol = symbol_insert( last_identifier, newpc, pc->section_num, pc->type, 1L);
			  current_symbol->type |= pc->type;
			  current_symbol->value = newpc;
			  current_symbol->section_num = pc->section_num;
			  current_symbol->length = 1L;
		      }                  
		   } break;
case 29:{ value = 0;
		      defined_symbol = ADD_IDENTIFIER(temp_ident_name, 0L, pc->section_num, STYPE_UNDEFINED, 0L);
/*
		      WRITE_INTERMEDIATE( &value, 0, DEFINE_FILE_SYMBOL, defined_symbol);
*/
		      strcpy(coff_name, temp_ident_name);
		      File_directive_needed = FALSE;
		    } break;
case 30:{       Debug_symbol_definition = TRUE;
			value = 0;
			defined_symbol = ADD_IDENTIFIER( last_identifier, 0L, pc->section_num, STYPE_UNDEFINED, 1L);
			WRITE_INTERMEDIATE( &value, 0, DEFINE_SYMBOL, defined_symbol);
		    } break;
case 31:{       Debug_symbol_definition = TRUE;
			value = 0;
			defined_symbol = ADD_IDENTIFIER( ".bf", 0L, pc->section_num, STYPE_UNDEFINED, 0L);
			defined_symbol->section_num = pc->section_num;
			WRITE_INTERMEDIATE( &value, 0, DEFINE_SYMBOL, defined_symbol);
		    } break;
case 32:{       Debug_symbol_definition = TRUE;
			value = 0;
			defined_symbol = ADD_IDENTIFIER( ".ef", 0L, pc->section_num, STYPE_UNDEFINED, 0L);
			defined_symbol->section_num = pc->section_num;
			WRITE_INTERMEDIATE( &value, 0, DEFINE_SYMBOL, defined_symbol);
		    } break;
case 33:{       Debug_symbol_definition = TRUE;
			value = 0;
			defined_symbol = ADD_IDENTIFIER( ".bb", 0L, pc->section_num, STYPE_UNDEFINED, 0L);
			defined_symbol->section_num = pc->section_num;
			WRITE_INTERMEDIATE( &value, 0, DEFINE_SYMBOL, defined_symbol);
		    } break;
case 34:{       Debug_symbol_definition = TRUE;
			value = 0;
			defined_symbol = ADD_IDENTIFIER( ".eb", 0L, pc->section_num, STYPE_UNDEFINED, 0L);
			defined_symbol->section_num = pc->section_num;
			WRITE_INTERMEDIATE( &value, 0, DEFINE_SYMBOL, defined_symbol);
		    } break;
case 35:{
			Debug_symbol_definition = TRUE;
			value = 0;
			defined_symbol = ADD_IDENTIFIER( ".eos", 0L, pc->section_num, STYPE_UNDEFINED, 0L);
			defined_symbol->section_num = pc->section_num;
			WRITE_INTERMEDIATE( &value, 0, DEFINE_SYMBOL, defined_symbol);
		    } break;
case 36:{
			value = yypvt[-0].lval;
			WRITE_INTERMEDIATE( &value, 0L, DEFINE_SYMBOL_SIZE, defined_symbol);
		   } break;
case 37:{
			value = yypvt[-0].lval;
			WRITE_INTERMEDIATE( &value, 0L, DEFINE_DIM1, defined_symbol);
		   } break;
case 38:{
			value = yypvt[-2].lval;
			WRITE_INTERMEDIATE( &value, 0L, DEFINE_DIM1, defined_symbol);
			value = yypvt[-0].lval;
			WRITE_INTERMEDIATE( &value, 0L, DEFINE_DIM2, defined_symbol);

		   } break;
case 39:{
			value = yypvt[-4].lval;
			WRITE_INTERMEDIATE( &value, 0L, DEFINE_DIM1, defined_symbol);
			value = yypvt[-2].lval;
			WRITE_INTERMEDIATE( &value, 0L, DEFINE_DIM2, defined_symbol);
			value = yypvt[-0].lval;
			WRITE_INTERMEDIATE( &value, 0L, DEFINE_DIM2, defined_symbol);
		   } break;
case 40:{
			value = yypvt[-6].lval;
			WRITE_INTERMEDIATE( &value ,0L, DEFINE_DIM1, defined_symbol);
			value = yypvt[-4].lval;
			WRITE_INTERMEDIATE( &value, 0L, DEFINE_DIM2, defined_symbol);
			value = yypvt[-2].lval;
			WRITE_INTERMEDIATE( &value, 0L, DEFINE_DIM2, defined_symbol);
			value = yypvt[-0].lval;
			WRITE_INTERMEDIATE( &value, 0L, DEFINE_DIM2, defined_symbol);

		   } break;
case 41:{
			defined_symbol = symbol_lookup(last_identifier);
			value = 0;
			WRITE_INTERMEDIATE( &value, 0L, DEFINE_SYMBOL_TAG, defined_symbol);
		   } break;
case 42:{    value = 0x80000000L;       /*Flag to set value to newpc!*/
			WRITE_INTERMEDIATE( &value, 0, DEFINE_SYMBOL_VALUE, defined_symbol);
		   } break;
case 43:{    value = yypvt[-0].lval;
			if( value == 0 )
			  value = 0x80000001L;
			WRITE_INTERMEDIATE( &value, 0, DEFINE_SYMBOL_VALUE, defined_symbol);
		   } break;
case 44:{    value = yypvt[-0].lval;
			value = -value;
			WRITE_INTERMEDIATE( &value, 0, DEFINE_SYMBOL_VALUE, defined_symbol);
		   } break;
case 45:{       value = 0;
			WRITE_INTERMEDIATE( &value, 0, DEFINE_SYMBOL_VALUE, defined_symbol);
		    } break;
case 46:{       value = INT_VAL(yypvt[-0].expr);
			WRITE_INTERMEDIATE( &value, 0, DEFINE_SYMBOL_SCLASS, defined_symbol);
		    } break;
case 47:{       value = INT_VAL(yypvt[-0].expr);
			increment=10000;
			octal_value = 0;
			while(increment>0) {
				octal_value <<= 3;
				octal_value |= (value/increment);
				value -= ((value/increment)*increment);
				increment /= 10;
				}
			value=octal_value;
			WRITE_INTERMEDIATE( &value, 0, DEFINE_SYMBOL_TYPE, defined_symbol);
		    } break;
case 48:{ value = INT_VAL(yypvt[-0].expr);
		     WRITE_INTERMEDIATE( &value, 0, DEFINE_SYMBOL_LINE, defined_symbol);
		   } break;
case 49:{       Debug_symbol_definition = FALSE;
			value = 0;
			WRITE_INTERMEDIATE( &value, 0, END_SYMBOL_DEFINE, defined_symbol);
		    } break;
case 50:{ value = yypvt[-0].lval;
		     WRITE_INTERMEDIATE( &value, 0, LINE_NUMBER, NULL);
		   } break;
case 61:{ ; } break;
case 62:{ ; } break;
case 65:{
			short int word_size;

			word_size = (short)(get_current_section_type() & SECTION_PM) ? PM_WORD_SIZE : DM_WORD_SIZE;
			expression_init_to_zero( (long)(yypvt[-0].symbol->length), word_size);
		  } break;
case 66:{ init_processing = AFFIRMATIVE; num_initializers = 0;} break;
case 67:{ 
		      init_processing = FALSE;
		      if( yypvt[-3].symbol->length > num_initializers ) {
			expression_init_to_zero( (yypvt[-3].symbol->length - num_initializers), (short)(get_current_section_type() & SECTION_PM) ? PM_WORD_SIZE : DM_WORD_SIZE );
			USER_WARN1( "Number of initializers less than length of buffer %s.", (IN_STRING_TABLE(yypvt[-3].symbol) ? &string_table[OFFSET(yypvt[-3].symbol)] : NAME(yypvt[-3].symbol)) );
		      } else if( yypvt[-3].symbol->length < num_initializers )
		      {
			  FATAL_ERROR1( "Number of initializers exceeds length of buffer %s.", (IN_STRING_TABLE(yypvt[-3].symbol) ? &string_table[OFFSET(yypvt[-3].symbol)] : NAME(yypvt[-3].symbol)) );
		      }

		  } break;
case 68:{ init_processing = AFFIRMATIVE; num_initializers = 0;} break;
case 69:{ 
		      init_processing = FALSE;
		      if( yypvt[-4].symbol->length > num_initializers ) {
			expression_init_to_zero( (yypvt[-4].symbol->length - num_initializers), (short)(get_current_section_type() & SECTION_PM) ? PM_WORD_SIZE : DM_WORD_SIZE );
			USER_WARN1( "Number of initializers less than length of buffer %s.", (IN_STRING_TABLE(yypvt[-4].symbol) ? &string_table[OFFSET(yypvt[-4].symbol)] : NAME(yypvt[-4].symbol)) );
		      } else if( yypvt[-4].symbol->length < num_initializers )
		      {
			  FATAL_ERROR1( "Number of initializers exceeds length of buffer %s.", (IN_STRING_TABLE(yypvt[-4].symbol) ? &string_table[OFFSET(yypvt[-4].symbol)] : NAME(yypvt[-4].symbol)) );
		      }
		  } break;
case 70:{ file_init_processing = AFFIRMATIVE; num_initializers = 0;} break;
case 71:{
		      file_init_processing = FALSE;
		      if( yypvt[-3].symbol->length > num_initializers ) {
			expression_init_to_zero( (yypvt[-3].symbol->length - num_initializers), (short)(get_current_section_type() & SECTION_PM) ? PM_WORD_SIZE : DM_WORD_SIZE );
/*
			USER_WARN2( "Number of initializers in file %s less than length of buffer %s.", yypvt[0].sval, (IN_STRING_TABLE($1) ? &string_table[OFFSET($1)] : NAME($1)) );
*/
		      } else if( yypvt[-3].symbol->length < num_initializers )
		      {
			  FATAL_ERROR2( "Number of initializers exceeds length of buffer .", 0, 0 );
/*
			  FATAL_ERROR2( "Number of initializers in file %s exceeds length of buffer %s.", yypvt[0].sval, (IN_STRING_TABLE($1) ? &string_table[OFFSET($1)] : NAME($1)) );
*/
		      }
		  } break;
case 72:{
			strcat(temp_ident_name, yyval.sval);
		  } break;
case 73:{ 
		     read_data_file( yypvt[-0].sval );
		     yyval.sval = yypvt[-0].sval;
		  } break;
case 74:{
		    strcpy( temp_ident_name, last_identifier);
		  } break;
case 75:{
		    current_symbol = symbol_lookup(temp_ident_name);
		    if( current_symbol && IS_DEFINED(current_symbol->type) )
		    {
		      char *name;
			
		      if( IN_STRING_TABLE(current_symbol) )
			name = &string_table[OFFSET(current_symbol)];
		      else
			name = NAME( current_symbol );
		      USER_ERROR1( "Attempt to redefine symbol %s.", name  );

		    }
		    else
		    {

		      current_symbol = ADD_IDENTIFIER( temp_ident_name, newpc, pc->section_num, pc->type, yypvt[-0].lval);
		      current_symbol->type |= pc->type;
		      current_symbol->type = (current_symbol->type & ~STYPE_EXTERN);
		      current_symbol->value = newpc; 
		      current_symbol->section_num = pc->section_num;
		      current_symbol->length = yypvt[-0].lval;
		    }
		    yyval.symbol = current_symbol;
		  } break;
case 76:{
		    yyval.lval = (long)INT_VAL(yypvt[-1].expr);
		  } break;
case 77:{
		    yyval.lval = 1L;
		  } break;
case 78:{ ; } break;
case 79:{
		    current_symbol = ADD_IDENTIFIER( last_identifier, 0L, 0L, STYPE_UNDEFINED, 0L);
		    MAKE_IT_GLOBAL( current_symbol );
		  } break;
case 80:{ 
		    current_symbol = ADD_IDENTIFIER( last_identifier, 0L, 0L, STYPE_UNDEFINED, 0L);
		    MAKE_IT_GLOBAL( current_symbol );
		  } break;
case 81:{
			 Gcc_compiled = TRUE;
		     } break;
case 82:{ 
		       listing_new_page ();
		     } break;
case 83:{ ; } break;
case 84:{
		       current_symbol = ADD_IDENTIFIER( last_identifier, 0L, 0L, STYPE_UNDEFINED, 0L);
		       MAKE_IT_EXTERN( current_symbol );
		     } break;
case 85:{
		       current_symbol = ADD_IDENTIFIER( last_identifier, 0L, 0L, STYPE_UNDEFINED, 0L);
		       MAKE_IT_EXTERN( current_symbol );
		     } break;
case 86:{
			if( INT_VAL(yypvt[-0].expr) == 32 ) 
			    precision = SINGLE_PRECISION;
			else if( INT_VAL(yypvt[-0].expr) == 40 )
			    precision = EXTENDED_PRECISION;
			else
			    USER_ERROR( "Illegal precision value." );
		     } break;
case 87:{ round_mode = RND_NEAREST; } break;
case 88:{ round_mode = RND_ZERO; } break;
case 89:{ round_mode = RND_MINUS_INF; } break;
case 90:{ round_mode = RND_PLUS_INF; } break;
case 91:{
			 short          okay;
			 static   int   inserted_file_directive_okay = 0;

			 if( strlen(last_identifier) > SYMNMLEN )
			 {
			   USER_WARN1( "segment name '%s' truncated to eight characters", last_identifier);
			   last_identifier[SYMNMLEN] = '\0';
			 }

			 current_symbol = ADD_IDENTIFIER( last_identifier, 0L, 0L, STYPE_UNDEFINED, 0L);
			  
#ifdef DEBUG
			 printf("yyparse: section name = %s\n", last_identifier);
#endif                         
			 okay = make_section(symbol_lookup(last_identifier), yypvt[-1].lval );
			 if( !okay )
			     USER_ERROR( "Missing .endseg directive." );

			 change_section( okay );

			 /* Must be in a section before we put the .file in symbol table */

			 if( File_directive_needed )
			 {
				value = 0;
				defined_symbol = ADD_IDENTIFIER(coff_name, 0L, pc->section_num, STYPE_UNDEFINED, 0L);
				WRITE_INTERMEDIATE( &value, 0, DEFINE_FILE_SYMBOL, defined_symbol);
				File_directive_needed = FALSE;
			 }

		     } break;
case 92:{ yyval.lval = SECTION_PM; } break;
case 93:{ yyval.lval = SECTION_DM; } break;
case 94:{
			 end_section();
		     } break;
case 95:{
			 assemble_instruction( &ilnode );
		     } break;
case 96:{
			 assemble_instruction( &ilnode );
		     } break;
case 97:{
			 assemble_instruction( &ilnode );
		     } break;
case 98:{
			 assemble_instruction( &ilnode );
		     } break;
case 99:{
			 assemble_instruction( &ilnode );
		     } break;
case 100:{
			 if( !Z3 )
			     USER_WARN("Use of ADSP21060 instruction without -ADSP21060 switch");
			 assemble_instruction( &ilnode );
		     } break;
case 101:{
			 ilnode.instruction_type = INSTRUCTION_TYPE1;
		     } break;
case 102:{
			 ilnode.instruction_type = INSTRUCTION_TYPE2;
		     } break;
case 103:{
			 ilnode.instruction_type = INSTRUCTION_TYPE3;
		     } break;
case 104:{
			 ilnode.instruction_type = INSTRUCTION_TYPE4;
		     } break;
case 105:{
			 ilnode.instruction_type = INSTRUCTION_TYPE5;
		     } break;
case 106:{
			 ilnode.instruction_type = INSTRUCTION_TYPE6;
		     } break;
case 111:{
			 ilnode.dmd = D_WRITE;
			 ilnode.pmd = D_WRITE;
		     } break;
case 112:{
			 ilnode.dmd = D_WRITE;
			 ilnode.pmd = D_WRITE;
		     } break;
case 113:{
			 ilnode.dmd = D_WRITE;
			 ilnode.pmd = D_WRITE;
		     } break;
case 114:{
			 ilnode.dmd = D_WRITE;
			 ilnode.pmd = D_WRITE;
			 ilnode.compute.compute_type = COMPUTE_NULL;
		     } break;
case 115:{
			 ilnode.dmd = D_WRITE;
			 ilnode.pmd = D_WRITE;
			 ilnode.compute.compute_type = COMPUTE_NULL;
		     } break;
case 116:{
			 ilnode.dmd = D_WRITE;
			 ilnode.pmd = D_READ;
		     } break;
case 117:{
			 ilnode.dmd = D_WRITE;
			 ilnode.pmd = D_READ;
		     } break;
case 118:{
			 ilnode.dmd = D_WRITE;
			 ilnode.pmd = D_READ;
		     } break;
case 119:{
			 ilnode.dmd = D_WRITE;
			 ilnode.pmd = D_READ;
			 ilnode.compute.compute_type = COMPUTE_NULL;
		     } break;
case 120:{
			 ilnode.dmd = D_READ;
			 ilnode.pmd = D_WRITE;
		     } break;
case 121:{
			 ilnode.dmd = D_READ;
			 ilnode.pmd = D_WRITE;
		     } break;
case 122:{
			 ilnode.dmd = D_READ;
			 ilnode.pmd = D_WRITE;
		     } break;
case 123:{
			 ilnode.dmd = D_READ;
			 ilnode.pmd = D_WRITE;
			 ilnode.compute.compute_type = COMPUTE_NULL;
		     } break;
case 124:{
			 ilnode.dmd = D_READ;
			 ilnode.pmd = D_READ;
		     } break;
case 125:{
			 ilnode.dmd = D_READ;
			 ilnode.pmd = D_READ;
		     } break;
case 126:{
			 ilnode.dmd = D_READ;
			 ilnode.pmd = D_READ;
		     } break;
case 127:{
			 ilnode.dmd = D_READ;
			 ilnode.pmd = D_READ;
			 ilnode.compute.compute_type = COMPUTE_NULL;
		     } break;
case 128:{
			 ilnode.dmd = D_READ;
			 ilnode.pmd = D_READ;
			 ilnode.compute.compute_type = COMPUTE_NULL;
		     } break;
case 132:{
			 ilnode.cond = COND_TRUE;
		     } break;
case 133:{
			 ilnode.cond = COND_TRUE;
		     } break;
case 134:{
			 ilnode.cond = COND_TRUE;
		     } break;
case 142:{
			 ilnode.compute.compute_type = COMPUTE_NULL;
		     } break;
case 143:{
			 ilnode.cond = COND_TRUE;
		     } break;
case 144:{
			 ilnode.cond = COND_TRUE;
		     } break;
case 145:{
			 ilnode.cond = COND_TRUE;
		     } break;
case 146:{
			 ilnode.cond = COND_TRUE;
			 ilnode.compute.compute_type = COMPUTE_NULL;
		     } break;
case 147:{
			 ilnode.u = U_POST_MODIFIED;
			 ilnode.g = G_PROGRAM_MEMORY;
			 ilnode.d = D_WRITE;
			 ilnode.ureg = (short) REG(yypvt[-0].regval);
		     } break;
case 148:{
			 ilnode.u = U_POST_MODIFIED;
			 ilnode.g = G_DATA_MEMORY;
			 ilnode.d = D_WRITE;
			 ilnode.ureg = (short) REG(yypvt[-0].regval);
		     } break;
case 152:{
			 ilnode.compute.compute_type = COMPUTE_NULL;
		     } break;
case 153:{
			 ilnode.cond = COND_TRUE;
		     } break;
case 154:{
			 ilnode.cond = COND_TRUE;
		     } break;
case 155:{
			 ilnode.cond = COND_TRUE;
		     } break;
case 156:{
			 ilnode.cond = COND_TRUE;
			 ilnode.compute.compute_type = COMPUTE_NULL;
		     } break;
case 157:{
			 ilnode.u = U_PRE_MODIFIED;
			 ilnode.g = G_DATA_MEMORY;
			 ilnode.d = D_WRITE;
			 ilnode.ureg = (short) REG(yypvt[-0].regval);
		     } break;
case 158:{
			 ilnode.u = U_PRE_MODIFIED;
			 ilnode.g = G_PROGRAM_MEMORY;
			 ilnode.d = D_WRITE;
			 ilnode.ureg = (short) REG(yypvt[-0].regval);
		     } break;
case 162:{
			 ilnode.compute.compute_type = COMPUTE_NULL;
		     } break;
case 163:{
			 ilnode.cond = COND_TRUE;
		     } break;
case 164:{
			 ilnode.cond = COND_TRUE;
		     } break;
case 165:{
			 ilnode.cond = COND_TRUE;
		     } break;
case 166:{
			 ilnode.cond = COND_TRUE;
			 ilnode.compute.compute_type = COMPUTE_NULL;
		     } break;
case 167:{
			 ilnode.u = U_POST_MODIFIED;
			 ilnode.g = G_DATA_MEMORY;
			 ilnode.d = D_READ;
			 ilnode.ureg = (short) REG(yypvt[-2].regval);
		     } break;
case 168:{
			 ilnode.u = U_POST_MODIFIED;
			 ilnode.g = G_PROGRAM_MEMORY;
			 ilnode.d = D_READ;
			 ilnode.ureg = (short) REG(yypvt[-2].regval);
		     } break;
case 172:{
			 ilnode.compute.compute_type = COMPUTE_NULL;
		     } break;
case 173:{
			 ilnode.cond = COND_TRUE;
		     } break;
case 174:{
			 ilnode.cond = COND_TRUE;
		     } break;
case 175:{
			 ilnode.cond = COND_TRUE;
		     } break;
case 176:{
			 ilnode.cond = COND_TRUE;
			 ilnode.compute.compute_type = COMPUTE_NULL;
		     } break;
case 177:{
			 ilnode.u = U_PRE_MODIFIED;
			 ilnode.g = G_DATA_MEMORY;
			 ilnode.d = D_READ;
			 ilnode.ureg = (short) REG(yypvt[-2].regval);
		     } break;
case 178:{
			 ilnode.u = U_PRE_MODIFIED;
			 ilnode.g = G_PROGRAM_MEMORY;
			 ilnode.d = D_READ;
			 ilnode.ureg = (short) REG(yypvt[-2].regval);
		     } break;
case 186:{
			 ilnode.compute.compute_type = COMPUTE_NULL;
		     } break;
case 187:{
			 ilnode.cond = COND_TRUE;
		     } break;
case 188:{
			 ilnode.cond = COND_TRUE;
		     } break;
case 189:{
			 ilnode.cond = COND_TRUE;
		     } break;
case 190:{
			 ilnode.cond = COND_TRUE;
			 ilnode.compute.compute_type = COMPUTE_NULL;
		     } break;
case 191:{
			 if( IS_REG_FILE(REG(yypvt[-0].regval)) )
			 {
			     ilnode.dm_dreg = (short) REG(yypvt[-0].regval);
			     ilnode.g = G_DATA_MEMORY;
			     ilnode.d = D_WRITE;
			     ilnode.u = U_POST_MODIFIED;
			 }
			 else
			 {
			     USER_ERROR( "Illegal data file register." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 192:{
			 if( IS_REG_FILE(REG(yypvt[-0].regval)) )
			 {
			     ilnode.pm_dreg = (short) REG(yypvt[-0].regval);
			     ilnode.g = G_PROGRAM_MEMORY;
			     ilnode.d = D_WRITE;
			     ilnode.u = U_POST_MODIFIED;
			 }
			 else
			 {
			     USER_ERROR( "Illegal data file register." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 193:{
			 if( IS_REG_FILE(REG(yypvt[-0].regval)) )
			 {
			     ilnode.dm_dreg = (short) REG(yypvt[-0].regval);
			     ilnode.g = G_DATA_MEMORY;
			     ilnode.d = D_WRITE;
			     ilnode.u = U_PRE_MODIFIED;
			 }
			 else
			 {
			     USER_ERROR( "Illegal data file register." );
			     ilnode.error_occurred = ASM_ERROR;
			 }                         
		     } break;
case 194:{
			 if( IS_REG_FILE(REG(yypvt[-0].regval)) )
			 {
			     ilnode.dm_dreg = (short) REG(yypvt[-0].regval);
			     ilnode.g = G_DATA_MEMORY;
			     ilnode.d = D_WRITE;
			     ilnode.u = U_PRE_MODIFIED;
			 }
			 else
			 {
			     USER_ERROR( "Illegal data file register." );
			     ilnode.error_occurred = ASM_ERROR;
			 }                         
		     } break;
case 195:{
			 if( IS_REG_FILE(REG(yypvt[-0].regval)) )
			 {
			     ilnode.dm_dreg = (short) REG(yypvt[-0].regval);
			     ilnode.g = G_DATA_MEMORY;
			     ilnode.d = D_WRITE;
			     ilnode.u = U_PRE_MODIFIED;
			 }
			 else
			 {
			     USER_ERROR( "Illegal data file register." );
			     ilnode.error_occurred = ASM_ERROR;
			 }                         
		     } break;
case 196:{
			 if( IS_REG_FILE(REG(yypvt[-0].regval)) )
			 {
			     ilnode.compute.compute_type = COMPUTE_NULL;
			     ilnode.dm_dreg = (short) REG(yypvt[-0].regval);
			     ilnode.g = G_DATA_MEMORY;
			     ilnode.d = D_WRITE;
			     ilnode.u = U_PRE_MODIFIED;
			 }
			 else
			 {
			     USER_ERROR( "Illegal data file register." );
			     ilnode.error_occurred = ASM_ERROR;
			 }                         
		     } break;
case 197:{
			 if( IS_REG_FILE(REG(yypvt[-0].regval)) )
			 {
			     ilnode.cond = COND_TRUE;
			     ilnode.dm_dreg = (short) REG(yypvt[-0].regval);
			     ilnode.g = G_DATA_MEMORY;
			     ilnode.d = D_WRITE;
			     ilnode.u = U_PRE_MODIFIED;
			 }
			 else
			 {
			     USER_ERROR( "Illegal data file register." );
			     ilnode.error_occurred = ASM_ERROR;
			 }                         
		     } break;
case 198:{
			 if( IS_REG_FILE(REG(yypvt[-0].regval)) )
			 {
			     ilnode.cond = COND_TRUE;
			     ilnode.dm_dreg = (short) REG(yypvt[-0].regval);
			     ilnode.g = G_DATA_MEMORY;
			     ilnode.d = D_WRITE;
			     ilnode.u = U_PRE_MODIFIED;
			 }
			 else
			 {
			     USER_ERROR( "Illegal data file register." );
			     ilnode.error_occurred = ASM_ERROR;
			 }                         
		     } break;
case 199:{
			 if( IS_REG_FILE(REG(yypvt[-0].regval)) )
			 {
			     ilnode.cond = COND_TRUE;
			     ilnode.dm_dreg = (short) REG(yypvt[-0].regval);
			     ilnode.g = G_DATA_MEMORY;
			     ilnode.d = D_WRITE;
			     ilnode.u = U_PRE_MODIFIED;
			 }
			 else
			 {
			     USER_ERROR( "Illegal data file register." );
			     ilnode.error_occurred = ASM_ERROR;
			 }                         
		     } break;
case 200:{
			 if( IS_REG_FILE(REG(yypvt[-0].regval)) )
			 {
			     ilnode.pm_dreg = (short) REG(yypvt[-0].regval);
			     ilnode.g = G_PROGRAM_MEMORY;
			     ilnode.d = D_WRITE;
			     ilnode.u = U_PRE_MODIFIED;
			 }
			 else
			 {
			     USER_ERROR( "Illegal data file register." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 201:{
			 if( IS_REG_FILE(REG(yypvt[-0].regval)) )
			 {
			     ilnode.pm_dreg = (short) REG(yypvt[-0].regval);
			     ilnode.g = G_PROGRAM_MEMORY;
			     ilnode.d = D_WRITE;
			     ilnode.u = U_PRE_MODIFIED;
			 }
			 else
			 {
			     USER_ERROR( "Illegal data file register." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 202:{
			 if( IS_REG_FILE(REG(yypvt[-0].regval)) )
			 {
			     ilnode.pm_dreg = (short) REG(yypvt[-0].regval);
			     ilnode.g = G_PROGRAM_MEMORY;
			     ilnode.d = D_WRITE;
			     ilnode.u = U_PRE_MODIFIED;
			 }
			 else
			 {
			     USER_ERROR( "Illegal data file register." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 203:{
			 if( IS_REG_FILE(REG(yypvt[-0].regval)) )
			 {
			     ilnode.compute.compute_type = COMPUTE_NULL;
			     ilnode.pm_dreg = (short) REG(yypvt[-0].regval);
			     ilnode.g = G_PROGRAM_MEMORY;
			     ilnode.d = D_WRITE;
			     ilnode.u = U_PRE_MODIFIED;
			 }
			 else
			 {
			     USER_ERROR( "Illegal data file register." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 204:{
			 if( IS_REG_FILE(REG(yypvt[-0].regval)) )
			 {
			     ilnode.cond = COND_TRUE;
			     ilnode.pm_dreg = (short) REG(yypvt[-0].regval);
			     ilnode.g = G_PROGRAM_MEMORY;
			     ilnode.d = D_WRITE;
			     ilnode.u = U_PRE_MODIFIED;
			 }
			 else
			 {
			     USER_ERROR( "Illegal data file register." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 205:{
			 if( IS_REG_FILE(REG(yypvt[-0].regval)) )
			 {
			     ilnode.cond = COND_TRUE;
			     ilnode.pm_dreg = (short) REG(yypvt[-0].regval);
			     ilnode.g = G_PROGRAM_MEMORY;
			     ilnode.d = D_WRITE;
			     ilnode.u = U_PRE_MODIFIED;
			 }
			 else
			 {
			     USER_ERROR( "Illegal data file register." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 206:{
			 if( IS_REG_FILE(REG(yypvt[-0].regval)) )
			 {
			     ilnode.cond = COND_TRUE;
			     ilnode.pm_dreg = (short) REG(yypvt[-0].regval);
			     ilnode.g = G_PROGRAM_MEMORY;
			     ilnode.d = D_WRITE;
			     ilnode.u = U_PRE_MODIFIED;
			 }
			 else
			 {
			     USER_ERROR( "Illegal data file register." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 210:{
			 ilnode.compute.compute_type = COMPUTE_NULL;
		     } break;
case 211:{
			 ilnode.cond = COND_TRUE;
		     } break;
case 212:{
			 ilnode.cond = COND_TRUE;
		     } break;
case 213:{
			 ilnode.cond = COND_TRUE;
		     } break;
case 214:{
			 ilnode.cond = COND_TRUE;
			 ilnode.compute.compute_type = COMPUTE_NULL;
		     } break;
case 215:{
			 if( IS_REG_FILE(REG(yypvt[-2].regval)) )
			 {
			     ilnode.dm_dreg = (short) REG(yypvt[-2].regval);
			     ilnode.g = G_DATA_MEMORY;
			     ilnode.d = D_READ;
			     ilnode.u = U_POST_MODIFIED;
			 }
			 else
			 {
			     USER_ERROR( "Illegal data file register." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 216:{
			 if( IS_REG_FILE(REG(yypvt[-2].regval)) )
			 {
			     ilnode.pm_dreg = (short) REG(yypvt[-2].regval);
			     ilnode.g = G_PROGRAM_MEMORY;
			     ilnode.d = D_READ;
			     ilnode.u = U_POST_MODIFIED;
			 }
			 else
			 {
			     USER_ERROR( "Illegal data file register." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 217:{
			 if( IS_REG_FILE(REG(yypvt[-2].regval)) )
			 {
			     ilnode.dm_dreg = (short) REG(yypvt[-2].regval);
			     ilnode.g = G_DATA_MEMORY;
			     ilnode.d = D_READ;
			     ilnode.u = U_PRE_MODIFIED;
			 }
			 else
			 {
			     USER_ERROR( "Illegal data file register." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 218:{
			 if( IS_REG_FILE(REG(yypvt[-2].regval)) )
			 {
			     ilnode.dm_dreg = (short) REG(yypvt[-2].regval);
			     ilnode.g = G_DATA_MEMORY;
			     ilnode.d = D_READ;
			     ilnode.u = U_PRE_MODIFIED;
			 }
			 else
			 {
			     USER_ERROR( "Illegal data file register." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 219:{
			 if( IS_REG_FILE(REG(yypvt[-2].regval)) )
			 {
			     ilnode.dm_dreg = (short) REG(yypvt[-2].regval);
			     ilnode.g = G_DATA_MEMORY;
			     ilnode.d = D_READ;
			     ilnode.u = U_PRE_MODIFIED;
			 }
			 else
			 {
			     USER_ERROR( "Illegal data file register." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 220:{
			 if( IS_REG_FILE(REG(yypvt[-2].regval)) )
			 {
			     ilnode.compute.compute_type = COMPUTE_NULL;
			     ilnode.dm_dreg = (short) REG(yypvt[-2].regval);
			     ilnode.g = G_DATA_MEMORY;
			     ilnode.d = D_READ;
			     ilnode.u = U_PRE_MODIFIED;
			 }
			 else
			 {
			     USER_ERROR( "Illegal data file register." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 221:{
			 if( IS_REG_FILE(REG(yypvt[-2].regval)) )
			 {
			     ilnode.cond = COND_TRUE;
			     ilnode.dm_dreg = (short) REG(yypvt[-2].regval);
			     ilnode.g = G_DATA_MEMORY;
			     ilnode.d = D_READ;
			     ilnode.u = U_PRE_MODIFIED;
			 }
			 else
			 {
			     USER_ERROR( "Illegal data file register." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 222:{
			 if( IS_REG_FILE(REG(yypvt[-2].regval)) )
			 {
			     ilnode.cond = COND_TRUE;
			     ilnode.dm_dreg = (short) REG(yypvt[-2].regval);
			     ilnode.g = G_DATA_MEMORY;
			     ilnode.d = D_READ;
			     ilnode.u = U_PRE_MODIFIED;
			 }
			 else
			 {
			     USER_ERROR( "Illegal data file register." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 223:{
			 if( IS_REG_FILE(REG(yypvt[-2].regval)) )
			 {
			     ilnode.cond = COND_TRUE;
			     ilnode.dm_dreg = (short) REG(yypvt[-2].regval);
			     ilnode.g = G_DATA_MEMORY;
			     ilnode.d = D_READ;
			     ilnode.u = U_PRE_MODIFIED;
			 }
			 else
			 {
			     USER_ERROR( "Illegal data file register." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 224:{
			 if( IS_REG_FILE(REG(yypvt[-2].regval)) )
			 {
			     ilnode.pm_dreg = (short) REG(yypvt[-2].regval);
			     ilnode.g = G_PROGRAM_MEMORY;
			     ilnode.d = D_READ;
			     ilnode.u = U_PRE_MODIFIED;
			 }
			 else
			 {
			     USER_ERROR( "Illegal data file register." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 225:{
			 if( IS_REG_FILE(REG(yypvt[-2].regval)) )
			 {
			     ilnode.pm_dreg = (short) REG(yypvt[-2].regval);
			     ilnode.g = G_PROGRAM_MEMORY;
			     ilnode.d = D_READ;
			     ilnode.u = U_PRE_MODIFIED;
			 }
			 else
			 {
			     USER_ERROR( "Illegal data file register." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 226:{
			 if( IS_REG_FILE(REG(yypvt[-2].regval)) )
			 {
			     ilnode.pm_dreg = (short) REG(yypvt[-2].regval);
			     ilnode.g = G_PROGRAM_MEMORY;
			     ilnode.d = D_READ;
			     ilnode.u = U_PRE_MODIFIED;
			 }
			 else
			 {
			     USER_ERROR( "Illegal data file register." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 227:{
			 if( IS_REG_FILE(REG(yypvt[-2].regval)) )
			 {
			     ilnode.compute.compute_type = COMPUTE_NULL;
			     ilnode.pm_dreg = (short) REG(yypvt[-2].regval);
			     ilnode.g = G_PROGRAM_MEMORY;
			     ilnode.d = D_READ;
			     ilnode.u = U_PRE_MODIFIED;
			 }
			 else
			 {
			     USER_ERROR( "Illegal data file register." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 228:{
			 if( IS_REG_FILE(REG(yypvt[-2].regval)) )
			 {
			     ilnode.cond = COND_TRUE;
			     ilnode.pm_dreg = (short) REG(yypvt[-2].regval);
			     ilnode.g = G_PROGRAM_MEMORY;
			     ilnode.d = D_READ;
			     ilnode.u = U_PRE_MODIFIED;
			 }
			 else
			 {
			     USER_ERROR( "Illegal data file register." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 229:{
			 if( IS_REG_FILE(REG(yypvt[-2].regval)) )
			 {
			     ilnode.cond = COND_TRUE;
			     ilnode.pm_dreg = (short) REG(yypvt[-2].regval);
			     ilnode.g = G_PROGRAM_MEMORY;
			     ilnode.d = D_READ;
			     ilnode.u = U_PRE_MODIFIED;
			 }
			 else
			 {
			     USER_ERROR( "Illegal data file register." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 230:{

			 if( IS_REG_FILE(REG(yypvt[-2].regval)) )
			 {
			     ilnode.cond = COND_TRUE;
			     ilnode.pm_dreg = (short) REG(yypvt[-2].regval);
			     ilnode.g = G_PROGRAM_MEMORY;
			     ilnode.d = D_READ;
			     ilnode.u = U_PRE_MODIFIED;
			 }
			 else
			 {
			     USER_ERROR( "Illegal data file register." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 235:{
			 ilnode.src_ureg = (short) REG(yypvt[-0].regval);
			 ilnode.dest_ureg = (short) REG(yypvt[-2].regval);
		     } break;
case 236:{
			 ilnode.src_ureg = (short) REG(yypvt[-0].regval);
			 ilnode.dest_ureg = (short) REG(yypvt[-2].regval);
		     } break;
case 237:{
			 ilnode.src_ureg = (short) REG(yypvt[-0].regval);
			 ilnode.dest_ureg = (short) REG(yypvt[-2].regval);
		     } break;
case 238:{
			 ilnode.compute.compute_type = COMPUTE_NULL;
			 ilnode.src_ureg = (short) REG(yypvt[-0].regval);
			 ilnode.dest_ureg = (short) REG(yypvt[-2].regval);
		     } break;
case 239:{
			 ilnode.cond = COND_TRUE;
			 ilnode.src_ureg = (short) REG(yypvt[-0].regval);
			 ilnode.dest_ureg = (short) REG(yypvt[-2].regval);
		     } break;
case 240:{
			 ilnode.cond = COND_TRUE;
			 ilnode.src_ureg = (short) REG(yypvt[-0].regval);
			 ilnode.dest_ureg = (short) REG(yypvt[-2].regval);
		     } break;
case 241:{
			 ilnode.cond = COND_TRUE;
			 ilnode.src_ureg = (short) REG(yypvt[-0].regval);
			 ilnode.dest_ureg = (short) REG(yypvt[-2].regval);
		     } break;
case 242:{
			 ilnode.cond = COND_TRUE;
			 ilnode.compute.compute_type = COMPUTE_NULL;
			 ilnode.src_ureg = (short) REG(yypvt[-0].regval);
			 ilnode.dest_ureg = (short) REG(yypvt[-2].regval);
		     } break;
case 244:{ 
			 ilnode.cond = COND_TRUE; 
		     } break;
case 245:{
			 ilnode.shift_data_move = PRESENT;
			 ilnode.g = G_DATA_MEMORY;
		     } break;
case 246:{
			 ilnode.shift_data_move = PRESENT;
			 ilnode.g = G_PROGRAM_MEMORY;
		     } break;
case 248:{
			 ilnode.instruction_type = INSTRUCTION_TYPE8;
		     } break;
case 252:{ 
			 ilnode.compute.compute_type = COMPUTE_NULL; 
		     } break;
case 253:{ 
			 ilnode.cond = COND_TRUE; 
		     } break;
case 254:{ 
			 ilnode.cond = COND_TRUE; 
		     } break;
case 255:{ 
			 ilnode.cond = COND_TRUE; 
		     } break;
case 256:{
			 ilnode.cond = COND_TRUE;
			 ilnode.compute.compute_type = COMPUTE_NULL;
		     } break;
case 259:{
/*************NOTE***********************/
/* our type    spec type                */
/*                                      */
/*   9            8                     */
/*  10            9                     */
/*  11           10                     */
/*  12           11                     */
/*  etc. i think                        */
/*************NOTE***********************/

			 ilnode.instruction_type = INSTRUCTION_TYPE11;
		     } break;
case 260:{
			 ilnode.instruction_type = INSTRUCTION_TYPE12; 
		     } break;
case 261:{
			 ilnode.instruction_type = INSTRUCTION_TYPE13;
		     } break;
case 262:{
			 ilnode.instruction_type = INSTRUCTION_TYPE14;
		     } break;
case 263:{
			 if( ilnode.address_type == ADDRESS_DIRECT || 
			     ilnode.address_type == ADDRESS_PC_RELATIVE )
			 {
			     ilnode.b = B_JUMP;
			     ilnode.instruction_type = INSTRUCTION_TYPE9;
			 }
			 else if( ilnode.address_type == ADDRESS_INDIRECT )
			 {
			     ilnode.b = B_JUMP;
			     ilnode.compute.compute_type = COMPUTE_NULL;
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			 }
			 else
			 {
			     USER_ERROR( "Illegal jump address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 264:{
			 if( ilnode.address_type == ADDRESS_INDIRECT )
			 {
			     ilnode.b = B_JUMP;
			     ilnode.compute.compute_type = COMPUTE_NULL;
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			 }
			 else if( ilnode.address_type == ADDRESS_DIRECT || 
			     ilnode.address_type == ADDRESS_PC_RELATIVE )
			 {
			     ilnode.b = B_JUMP;
			     ilnode.instruction_type = INSTRUCTION_TYPE9;
			 }
			 else
			 {
			     USER_ERROR( "Illegal jump address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 265:{
			 if( ilnode.address_type == ADDRESS_INDIRECT )
			 {
			     ilnode.cond = COND_TRUE;
			     ilnode.compute.compute_type = COMPUTE_NULL;
			     ilnode.b = B_JUMP;
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			 }
			 else if( ilnode.address_type == ADDRESS_DIRECT || 
				  ilnode.address_type == ADDRESS_PC_RELATIVE )
			 {
			     ilnode.cond = COND_TRUE;
			     ilnode.b = B_JUMP;
			     ilnode.instruction_type = INSTRUCTION_TYPE9;
			 }
			 else
			 {
			     USER_ERROR( "Illegal jump address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 266:{
			 if( ilnode.address_type == ADDRESS_INDIRECT )
			 {
			     ilnode.cond = COND_TRUE;
			     ilnode.compute.compute_type = COMPUTE_NULL;
			     ilnode.b = B_JUMP;
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			 }
			 else if( ilnode.address_type == ADDRESS_DIRECT || 
				  ilnode.address_type == ADDRESS_PC_RELATIVE )
			 {
			     ilnode.cond = COND_TRUE;
			     ilnode.b = B_JUMP;
			     ilnode.instruction_type = INSTRUCTION_TYPE9;
			 }
			 else
			 {
			     USER_ERROR( "Illegal jump address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 267:{
			 if( ilnode.address_type == ADDRESS_DIRECT || 
			     ilnode.address_type == ADDRESS_PC_RELATIVE )
			 {
			     ilnode.b = B_CALL;
			     ilnode.instruction_type = INSTRUCTION_TYPE9;
			 }
			 else if( ilnode.address_type == ADDRESS_INDIRECT )
			 {
			     ilnode.compute.compute_type = COMPUTE_NULL;
			     ilnode.b = B_CALL;
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			 }                         
			 else
			 {
			     USER_ERROR( "Illegal call address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 268:{
			 if( ilnode.address_type == ADDRESS_INDIRECT )
			 {
			     ilnode.b = B_CALL;
			     ilnode.compute.compute_type = COMPUTE_NULL;
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			 }
			 else if( ilnode.address_type == ADDRESS_DIRECT || 
			     ilnode.address_type == ADDRESS_PC_RELATIVE )
			 {
			     ilnode.b = B_CALL;
			     ilnode.instruction_type = INSTRUCTION_TYPE9;
			 }
			 else
			 {
			     USER_ERROR( "Illegal call address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 269:{
			 if( ilnode.address_type == ADDRESS_INDIRECT )
			 {
			     ilnode.cond = COND_TRUE;
			     ilnode.compute.compute_type = COMPUTE_NULL;
			     ilnode.b = B_CALL;
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			 }
			 else if( ilnode.address_type == ADDRESS_DIRECT || 
				  ilnode.address_type == ADDRESS_PC_RELATIVE )
			 {
			     ilnode.cond = COND_TRUE;
			     ilnode.b = B_CALL;
			     ilnode.instruction_type = INSTRUCTION_TYPE9;
			 }
			 else
			 {
			     USER_ERROR( "Illegal call address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 270:{
			 if( ilnode.address_type == ADDRESS_INDIRECT )
			 {
			     ilnode.cond = COND_TRUE;
			     ilnode.compute.compute_type = COMPUTE_NULL;
			     ilnode.b = B_CALL;
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			 }
			 else if( ilnode.address_type == ADDRESS_DIRECT || 
				  ilnode.address_type == ADDRESS_PC_RELATIVE )
			 {
			     ilnode.cond = COND_TRUE;
			     ilnode.b = B_CALL;
			     ilnode.instruction_type = INSTRUCTION_TYPE9;
			 }
			 else
			 {
			     USER_ERROR( "Illegal call address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 271:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			     ilnode.b = B_JUMP;
			 }
			 else
			 {
			     USER_ERROR( "Illegal jump address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 272:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			     ilnode.b = B_JUMP;
			 }
			 else
			 {
			     USER_ERROR( "Illegal jump address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 273:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			     ilnode.b = B_JUMP;
			 }
			 else
			 {
			     USER_ERROR( "Illegal jump address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 274:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			  if( !Z3 )
			      USER_WARN("Use of Z# ELSE clause without -ADSP21060 switch");
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			     ilnode.b = B_JUMP;
			     ilnode.oelse = 1;
			 }
			 else
			 {
			     USER_ERROR( "Illegal jump address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 275:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			     ilnode.b = B_JUMP;
			     ilnode.oelse = 0;
			 }
			 else
			 {
			     USER_ERROR( "Illegal jump address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 276:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			  if( !Z3 )
			      USER_WARN("Use of Z# ELSE clause without -ADSP21060 switch");
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			     ilnode.b = B_JUMP;
			     ilnode.oelse = 1;
			 }
			 else
			 {
			     USER_ERROR( "Illegal jump address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 277:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			     ilnode.b = B_JUMP;
			     ilnode.oelse = 0;
			 }
			 else
			 {
			     USER_ERROR( "Illegal jump address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 278:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			  if( !Z3 )
			      USER_WARN("Use of Z# ELSE clause without -ADSP21060 switch");
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			     ilnode.b = B_JUMP;
			     ilnode.oelse = 1;
			 }
			 else
			 {
			     USER_ERROR( "Illegal jump address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 279:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			     ilnode.b = B_JUMP;
			     ilnode.oelse = 0;
			 }
			 else
			 {
			     USER_ERROR( "Illegal jump address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 280:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			     ilnode.cond = COND_TRUE;
			     ilnode.b = B_JUMP;
			 }
			 else
			 {
			     USER_ERROR( "Illegal jump address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 281:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			     ilnode.cond = COND_TRUE;
			     ilnode.b = B_JUMP;
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			 }
			 else
			 {
			     USER_ERROR( "Illegal jump address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 282:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			     ilnode.cond = COND_TRUE;
			     ilnode.b = B_JUMP;
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			 }
			 else
			 {
			     USER_ERROR( "Illegal jump address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 283:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			  if( !Z3 )
			      USER_WARN("Use of Z# ELSE clause without -ADSP21060 switch");
			     ilnode.cond = COND_TRUE;
			     ilnode.b = B_JUMP;
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			     ilnode.oelse = 1;
			 }
			 else
			 {
			     USER_ERROR( "Illegal jump address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 284:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			     ilnode.cond = COND_TRUE;
			     ilnode.b = B_JUMP;
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			     ilnode.oelse = 0;
			 }
			 else
			 {
			     USER_ERROR( "Illegal jump address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 285:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			  if( !Z3 )
			      USER_WARN("Use of Z# ELSE clause without -ADSP21060 switch");
			     ilnode.cond = COND_TRUE;
			     ilnode.b = B_JUMP;
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			     ilnode.oelse = 1;
			 }
			 else
			 {
			     USER_ERROR( "Illegal jump address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 286:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			     ilnode.cond = COND_TRUE;
			     ilnode.b = B_JUMP;
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			     ilnode.oelse = 0;
			 }
			 else
			 {
			     USER_ERROR( "Illegal jump address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 287:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			  if( !Z3 )
			      USER_WARN("Use of Z# ELSE clause without -ADSP21060 switch");
			     ilnode.cond = COND_TRUE;
			     ilnode.b = B_JUMP;
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			     ilnode.oelse = 1;
			 }
			 else
			 {
			     USER_ERROR( "Illegal jump address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 288:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			     ilnode.cond = COND_TRUE;
			     ilnode.b = B_JUMP;
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			     ilnode.oelse = 0;
			 }
			 else
			 {
			     USER_ERROR( "Illegal jump address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 289:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			     ilnode.b = B_CALL;
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			 }
			 else
			 {
			     USER_ERROR( "Illegal call address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 290:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			     ilnode.b = B_CALL;
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			 }
			 else
			 {
			     USER_ERROR( "Illegal call address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 291:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			     ilnode.b = B_CALL;
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			 }
			 else
			 {
			     USER_ERROR( "Illegal call address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 292:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			     ilnode.b = B_CALL;
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			 }
			 else
			 {
			     USER_ERROR( "Illegal call address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 293:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			     ilnode.b = B_CALL;
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			 }
			 else
			 {
			     USER_ERROR( "Illegal call address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 294:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			     ilnode.b = B_CALL;
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			 }
			 else
			 {
			     USER_ERROR( "Illegal call address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 295:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			     ilnode.cond = COND_TRUE;
			     ilnode.b = B_CALL;
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			 }
			 else
			 {
			     USER_ERROR( "Illegal call address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 296:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			     ilnode.cond = COND_TRUE;
			     ilnode.b = B_CALL;
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			 }
			 else
			 {
			     USER_ERROR( "Illegal call address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 297:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			     ilnode.cond = COND_TRUE;
			     ilnode.b = B_CALL;
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			 }
			 else
			 {
			     USER_ERROR( "Illegal call address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 298:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			     ilnode.cond = COND_TRUE;
			     ilnode.b = B_CALL;
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			 }
			 else
			 {
			     USER_ERROR( "Illegal call address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 299:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			     ilnode.cond = COND_TRUE;
			     ilnode.b = B_CALL;
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			 }
			 else
			 {
			     USER_ERROR( "Illegal call address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 300:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			     ilnode.cond = COND_TRUE;
			     ilnode.b = B_CALL;
			     ilnode.instruction_type = INSTRUCTION_TYPE10;
			 }
			 else
			 {
			     USER_ERROR( "Illegal call address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 301:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			     ;
			 }
			 else
			 {
			     USER_ERROR( "Illegal jump address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 302:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			     ;
			 }
			 else
			 {
			     USER_ERROR( "Illegal jump address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 303:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			     ;
			 }
			 else
			 {
			     USER_ERROR( "Illegal jump address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 304:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			     ilnode.compute.compute_type = COMPUTE_NULL;;
			 }
			 else
			 {
			     USER_ERROR( "Illegal jump address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 305:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			     ilnode.cond = COND_TRUE;
			 }
			 else
			 {
			     USER_ERROR( "Illegal jump address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 306:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			     ilnode.cond = COND_TRUE;
			 }
			 else
			 {
			     USER_ERROR( "Illegal jump address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 307:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			     ilnode.cond = COND_TRUE;
			 }
			 else
			 {
			     USER_ERROR( "Illegal jump address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 308:{
			 if( ilnode.address_type == ADDRESS_INDIRECT || ilnode.address_type ==
			     ADDRESS_PC_RELATIVE )
			 {
			     ilnode.compute.compute_type = COMPUTE_NULL;
			     ilnode.cond = COND_TRUE;
			 }
			 else
			 {
			     USER_ERROR( "Illegal jump address." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
		     } break;
case 309:{
			 if( ilnode.a == A_NO_LOOP_ABORT )
			     ilnode.ret = RET_TYPE_RTS; 
			 else
			 {
			     USER_ERROR( "Loop abort modifier is illegal on return instructions." );
			     ilnode.error_occurred = ASM_ERROR;                
			 }
		     } break;
case 310:{
			 if( ilnode.a == A_NO_LOOP_ABORT )
			 {
			     ilnode.cond = COND_TRUE;
			     ilnode.ret = RET_TYPE_RTS; 
			 }
			 else
			 {
			     USER_ERROR( "Loop abort modifier is illegal on return instructions." );
			     ilnode.error_occurred = ASM_ERROR;                
			 }
		     } break;
case 311:{ 
			 if( ilnode.a == A_NO_LOOP_ABORT )
			     ilnode.ret = RET_TYPE_RTI;
			 else
			 {
			     USER_ERROR( "Loop abort modifier is illegal on return instructions." );
			     ilnode.error_occurred = ASM_ERROR;                
			 }
		     } break;
case 312:{
			 if( ilnode.a == A_NO_LOOP_ABORT )
			 {
			     ilnode.cond = COND_TRUE; 
			     ilnode.ret = RET_TYPE_RTI;
			 }        
			 else
			 {
			     USER_ERROR( "Loop abort modifier is illegal on return instructions." );
			     ilnode.error_occurred = ASM_ERROR;                
			 }
		     } break;
case 313:{
			 if( REG(yypvt[-6].regval) != REG_LCNTR )
			 {
			     USER_ERROR( "Illegal register for loop initialization." );
			     ilnode.error_occurred = ASM_ERROR;
			 }

			 if( yypvt[-0].lval != COND_LCE )
			 {
			     USER_ERROR( "Illegal loop termination condition." );
			     ilnode.error_occurred = ASM_ERROR;
			 }


			 ilnode.immediate = yypvt[-4].expr;
			 if (ilnode.immediate.value.int_val > 65535L)
			 {
			     USER_ERROR( "LCNTR has max of 16 bits in this instruction.");
			     ilnode.error_occurred = ASM_ERROR;
			 }
			 else
				ilnode.linit = LCNTR_INIT_IMMED;
		     } break;
case 314:{
			 if( REG(yypvt[-6].regval) != REG_LCNTR )
			 {
			     USER_ERROR( "Illegal register for loop initialization." );
			     ilnode.error_occurred = ASM_ERROR;
			 }

			 if( yypvt[-0].lval != COND_LCE )
			 {
			     USER_ERROR( "Illegal loop termination condition." );
			     ilnode.error_occurred = ASM_ERROR;
			 }

			 ilnode.ureg = (short) REG( yypvt[-4].regval );
			 ilnode.linit = LCNTR_INIT_UNIV_REG;
		     } break;
case 315:{ 
			 ilnode.cond = (short) yypvt[-0].lval; 
		     } break;
case 316:{
			 ilnode.pm_addr = yypvt[-0].expr;
			 ilnode.address_type = ADDRESS_DIRECT;
		     } break;
case 317:{
			 ilnode.address_type = ADDRESS_PC_RELATIVE;
		     } break;
case 318:{
			 ilnode.instruction_type = INSTRUCTION_TYPE15;
		     } break;
case 319:{
			 ilnode.instruction_type = INSTRUCTION_TYPE16;
		     } break;
case 320:{
			 ilnode.instruction_type = INSTRUCTION_TYPE17;
		     } break;
case 321:{
			 ilnode.instruction_type = INSTRUCTION_TYPE18;
		     } break;
case 322:{
			 ilnode.instruction_type = INSTRUCTION_TYPE19;
		     } break;
case 323:{
			 ilnode.ureg = (short) REG(yypvt[-0].regval);
			 ilnode.g = G_DATA_MEMORY;
			 ilnode.d = D_WRITE;
		     } break;
case 324:{
			 ilnode.ureg = (short) REG(yypvt[-0].regval);
			 ilnode.g = G_PROGRAM_MEMORY;
			 ilnode.d = D_WRITE;
		     } break;
case 325:{
			 ilnode.ureg = (short) REG(yypvt[-2].regval);
			 ilnode.g = G_DATA_MEMORY;
			 ilnode.d = D_READ;
		     } break;
case 326:{
			 ilnode.ureg = (short) REG(yypvt[-2].regval);
			 ilnode.g = G_PROGRAM_MEMORY;
			 ilnode.d = D_READ;
		     } break;
case 327:{
			 ilnode.ureg = (short) REG(yypvt[-0].regval);
			 ilnode.g = G_DATA_MEMORY;
			 ilnode.d = D_WRITE;
		     } break;
case 328:{
			 ilnode.ureg = (short) REG(yypvt[-0].regval);
			 ilnode.g = G_PROGRAM_MEMORY;
			 ilnode.d = D_WRITE;
		     } break;
case 329:{
			 ilnode.ureg = (short) REG(yypvt[-2].regval);
			 ilnode.g = G_DATA_MEMORY;
			 ilnode.d = D_READ;
		     } break;
case 330:{
			 ilnode.ureg = (short) REG(yypvt[-2].regval);
			 ilnode.g = G_PROGRAM_MEMORY;
			 ilnode.d = D_READ;
		     } break;
case 331:{
			 ilnode.immediate = yypvt[-0].expr;
			 ilnode.g = G_DATA_MEMORY;
		     } break;
case 332:{
			 ilnode.immediate = yypvt[-0].expr;
			 ilnode.g = G_PROGRAM_MEMORY;
		     } break;
case 333:{
			 ilnode.ureg = (short) REG(yypvt[-2].regval);
			 ilnode.immediate = yypvt[-0].expr;
		     } break;
case 334:{
			 ilnode.ureg = (short) REG(yypvt[-0].regval);
			 ilnode.d = D_WRITE;
			 ilnode.s = S_TRANSFER;
			 ilnode.cache_reg = NULL_OPERAND;
		     } break;
case 335:{
			 ilnode.ureg = (short) REG(yypvt[-2].regval);
			 ilnode.d = D_READ;
			 ilnode.s = S_TRANSFER;
			 ilnode.cache_reg = NULL_OPERAND;
		     } break;
case 336:{
			 ilnode.d = D_READ;
			 ilnode.s = S_LOAD_READ_CACHE;
			 ilnode.cache_reg = (short) INT_VAL( yypvt[-0].expr );
			 ilnode.ureg = NULL_OPERAND; 
			 ilnode.cs = NULL_OPERAND;
		     } break;
case 337:{
			 ilnode.d = D_WRITE;
			 ilnode.s = S_LOAD_READ_CACHE;
			 ilnode.cache_reg = (short) INT_VAL( yypvt[-0].expr );
			 ilnode.ureg = NULL_OPERAND; 
			 ilnode.cs = NULL_OPERAND;
		     } break;
case 338:{
			  ilnode.instruction_type = INSTRUCTION_TYPE20;
		      } break;
case 339:{
			  ilnode.instruction_type = INSTRUCTION_TYPE22;
		      } break;
case 340:{
			  ilnode.instruction_type = INSTRUCTION_TYPE23;
		      } break;
case 341:{ 
			  ilnode.compute.compute_type = COMPUTE_NULL;
			  ilnode.instruction_type = INSTRUCTION_TYPE24;

			  ilnode.immediate.value.int_val = 0;
		      } break;
case 342:{ 
			  ilnode.compute.compute_type = COMPUTE_NULL;
			  ilnode.instruction_type = INSTRUCTION_TYPE24;

			  ilnode.immediate = yypvt[-0].expr;
		      } break;
case 343:{ 
			  ilnode.compute.compute_type = COMPUTE_NULL;
			  ilnode.instruction_type = INSTRUCTION_TYPE25;
		      } break;
case 344:{
			  ilnode.bop = BIT_SET;
			  ilnode.sreg = (short) REG(yypvt[-1].regval);
			  ilnode.immediate = yypvt[-0].expr;
		      } break;
case 345:{
			  ilnode.bop = BIT_CLEAR;
			  ilnode.sreg = (short) REG(yypvt[-1].regval);
			  ilnode.immediate = yypvt[-0].expr;
		      } break;
case 346:{
			  ilnode.bop = BIT_TOGGLE;
			  ilnode.sreg = (short) REG(yypvt[-1].regval);
			  ilnode.immediate = yypvt[-0].expr;
		      } break;
case 347:{
			  ilnode.bop = BIT_TEST;
			  ilnode.sreg = (short) REG(yypvt[-1].regval);
			  ilnode.immediate = yypvt[-0].expr;
		      } break;
case 348:{
			  ilnode.bop = BIT_XOR;
			  ilnode.sreg = (short) REG(yypvt[-1].regval);
			  ilnode.immediate = yypvt[-0].expr;
		      } break;
case 349:{
			  if( IS_DAG1_INDEX_REG(REG(yypvt[-3].regval)) )
			  {
			      ilnode.g = G_DATA_MEMORY;
			      ilnode.dm_ireg = (short) REG(yypvt[-3].regval);
			  }
			  else
			  {
			      ilnode.g = G_PROGRAM_MEMORY;
			      ilnode.pm_ireg = (short) REG(yypvt[-3].regval);
			  }
			  ilnode.immediate = yypvt[-1].expr;
			  ilnode.bit_rev = NO_BIT_REVERSE;
		      } break;
case 350:{
			   if( IS_DAG1_INDEX_REG(REG(yypvt[-3].regval)) )
			   {
			       ilnode.g = G_DATA_MEMORY;
			       ilnode.dm_ireg = (short) REG( yypvt[-3].regval );
			       ilnode.immediate = yypvt[-1].expr;
			       ilnode.bit_rev = BIT_REVERSE;
			   }
			   else if( IS_DAG2_INDEX_REG(REG(yypvt[-3].regval)) )
			   {
			       if( !Z3 )
				   USER_WARN("Use of ADSP21060 instruction without the -ADSP21060 switch");
			       ilnode.g = G_PROGRAM_MEMORY;
			       ilnode.pm_ireg = (short) REG(yypvt[-3].regval);
			       ilnode.immediate = yypvt[-1].expr;
			       ilnode.bit_rev = BIT_REVERSE;
			   }
			   else
			   {
			      USER_ERROR( "Illegal data memory modify register for bit-reverse." );
			      ilnode.error_occurred = ASM_ERROR;
			   }
		       } break;
case 351:{
			  if( IS_DAG1_INDEX_REG(REG(yypvt[-3].regval)) && IS_DAG1_MODIFY_REG(REG(yypvt[-1].regval)) )
			  {
			      ilnode.g = G_DATA_MEMORY;
			      ilnode.dm_ireg = (short) REG(yypvt[-3].regval);
			      ilnode.dm_mreg = (short) REG(yypvt[-1].regval);
			  }
			  else if( IS_DAG2_INDEX_REG(REG(yypvt[-3].regval)) && IS_DAG2_MODIFY_REG(REG(yypvt[-1].regval)) )
			  {
			      ilnode.g = G_PROGRAM_MEMORY;
			      ilnode.pm_ireg = (short) REG(yypvt[-3].regval);
			      ilnode.pm_mreg = (short) REG(yypvt[-1].regval);
			  }
			  else
			  {
			      USER_ERROR( "Illegal modify instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 358:{         
			 if( !Z3 )
			     USER_WARN("Use of ADSP21060 FLUSH CACHE instruction without -ADSP21060 switch");
			  ilnode.d = D_WRITE;
			  ilnode.s = 1;
			  ilnode.cache_reg = 0;
			  ilnode.ureg = NULL_OPERAND; 
			  ilnode.cs = NULL_OPERAND;
		     } break;
case 359:{
			 ilnode.lpu = LOOP_STACK_PUSH;
		      } break;
case 360:{
			  ilnode.lpo = LOOP_STACK_POP;
		      } break;
case 361:{
			  ilnode.spu = INTERRUPT_STACK_PUSH;
		      } break;
case 362:{
			  ilnode.spo = INTERRUPT_STACK_POP;
		      } break;
case 363:{
			if( get_register_number(yypvt[-0].lval) == REG_PCSTK )
				ilnode.ppu = PC_STACK_PUSH;
			else
				USER_ERROR("Illegal PUSH/POP register.");       
		      } break;
case 364:{
			if( get_register_number(yypvt[-0].lval) == REG_PCSTK )
				ilnode.ppo = PC_STACK_POP;
			else
				USER_ERROR("Illegal PUSH/POP register.");       
		      } break;
case 365:{ 
			  yyval.lval = PRESENT; 
		      } break;
case 366:{ 
			  yyval.lval = PRESENT; 
		      } break;
case 367:{ 
			  yyval.lval = PRESENT; 
		      } break;
case 368:{ 
			  yyval.lval = 0; /*EK*/
			  ilnode.compute.compute_type = COMPUTE_NULL;
		      } break;
case 369:{ yyval.lval = PRESENT; } break;
case 370:{ yyval.lval = 0; /*EK*/ } break;
case 371:{
			  ilnode.j = J_DELAYED;
			  ilnode.a = A_LOOP_ABORT;
			  ilnode.cios = NO_CI_CLEAR;
		      } break;
case 372:{
			  ilnode.j = J_DELAYED;
			  ilnode.a = A_LOOP_ABORT;
			  ilnode.cios = NO_CI_CLEAR;
		      } break;
case 373:{
			  ilnode.j = J_DELAYED;
			  ilnode.a = A_NO_LOOP_ABORT;
			  ilnode.cios = NO_CI_CLEAR;
		      } break;
case 374:{
			  ilnode.j = J_NON_DELAYED;
			  ilnode.a = A_LOOP_ABORT;
			  ilnode.cios = NO_CI_CLEAR;
		      } break;
case 375:{
			 if( !Z3 )
			     USER_WARN("Use of ADSP21060 CI or LR option without -ADSP21060 switch");
			  ilnode.j = J_DELAYED;
			  ilnode.a = A_LOOP_ABORT;
			  ilnode.cios = CI_CLEAR;
		      } break;
case 376:{
			 if( !Z3 )
			     USER_WARN("Use of ADSP21060 CI or LR option without -ADSP21060 switch");
			  ilnode.j = J_DELAYED;
			  ilnode.a = A_LOOP_ABORT;
			  ilnode.cios = CI_CLEAR;
		      } break;
case 377:{
			 if( !Z3 )
			     USER_WARN("Use of ADSP21060 CI or LR option without -ADSP21060 switch");
			  ilnode.j = J_DELAYED;
			  ilnode.a = A_LOOP_ABORT;
			  ilnode.cios = CI_CLEAR;
		      } break;
case 378:{
			 if( !Z3 )
			     USER_WARN("Use of ADSP21060 CI or LR option without -ADSP21060 switch");
			  ilnode.j = J_DELAYED;
			  ilnode.a = A_LOOP_ABORT;
			  ilnode.cios = CI_CLEAR;
		      } break;
case 379:{
			 if( !Z3 )
			     USER_WARN("Use of ADSP21060 CI or LR option without -ADSP21060 switch");
			  ilnode.j = J_DELAYED;
			  ilnode.a = A_LOOP_ABORT;
			  ilnode.cios = CI_CLEAR;
		      } break;
case 380:{
			 if( !Z3 )
			     USER_WARN("Use of ADSP21060 CI or LR option without -ADSP21060 switch");
			  ilnode.j = J_DELAYED;
			  ilnode.a = A_LOOP_ABORT;
			  ilnode.cios = CI_CLEAR;
		      } break;
case 381:{
			 if( !Z3 )
			     USER_WARN("Use of ADSP21060 CI or LR option without -ADSP21060 switch");
			  ilnode.j = J_DELAYED;
			  ilnode.a = A_NO_LOOP_ABORT;
			  ilnode.cios = CI_CLEAR;
		      } break;
case 382:{
			 if( !Z3 )
			     USER_WARN("Use of ADSP21060 CI or LR option without -ADSP21060 switch");
			  ilnode.j = J_DELAYED;
			  ilnode.cios = CI_CLEAR;
			  ilnode.a = A_NO_LOOP_ABORT;
		      } break;
case 383:{
			 if( !Z3 )
			     USER_WARN("Use of ADSP21060 CI or LR option without -ADSP21060 switch");
			  ilnode.j = J_NON_DELAYED;
			  ilnode.a = A_LOOP_ABORT;
			  ilnode.cios = CI_CLEAR;
		      } break;
case 384:{
			 if( !Z3 )
			     USER_WARN("Use of ADSP21060 CI or LR option without -ADSP21060 switch");
			  ilnode.j = J_NON_DELAYED;
			  ilnode.a = A_LOOP_ABORT;
			  ilnode.cios = CI_CLEAR;
		      } break;
case 385:{
			 if( !Z3 )
			     USER_WARN("Use of ADSP21060 CI or LR option without -ADSP21060 switch");
			  ilnode.j = J_NON_DELAYED;
			  ilnode.cios = CI_CLEAR;
			  ilnode.a = A_NO_LOOP_ABORT;
		      } break;
case 386:{
			  ilnode.cond = (short) yypvt[-0].lval;
		      } break;
case 387:{ yyval.lval = COND_EQ; } break;
case 388:{ yyval.lval = COND_LT; } break;
case 389:{ yyval.lval = COND_LE; } break;
case 390:{ yyval.lval = COND_AC; } break;
case 391:{ yyval.lval = COND_AV; } break;
case 392:{ yyval.lval = COND_MV; } break;
case 393:{ yyval.lval = COND_MS; } break;
case 394:{ yyval.lval = COND_SV; } break;
case 395:{ yyval.lval = COND_SZ; } break;
case 396:{ yyval.lval = COND_FLAG0_IN; } break;
case 397:{ yyval.lval = COND_FLAG1_IN; } break;
case 398:{ yyval.lval = COND_FLAG2_IN; } break;
case 399:{ yyval.lval = COND_FLAG3_IN; } break;
case 400:{ yyval.lval = COND_TF; } break;
case 401:{ yyval.lval = COND_ECE; } break;
case 402:{ yyval.lval = COND_LCE; ilnode.cond_kludge = AFFIRMATIVE; } break;
case 403:{ yyval.lval = COND_NOT_LCE; } break;
case 404:{ yyval.lval = COND_NE; } break;
case 405:{ yyval.lval = COND_GE; } break;
case 406:{ yyval.lval = COND_GT; } break;
case 407:{ yyval.lval = COND_NOT_AC; } break;
case 408:{ yyval.lval = COND_NOT_AV; } break;
case 409:{ yyval.lval = COND_NOT_MV; } break;
case 410:{ yyval.lval = COND_NOT_MS; } break;
case 411:{ yyval.lval = COND_NOT_SV; } break;
case 412:{ yyval.lval = COND_NOT_SZ; } break;
case 413:{ yyval.lval = COND_NOT_FLAG1_IN; } break;
case 414:{ yyval.lval = COND_NOT_FLAG2_IN; } break;
case 415:{ yyval.lval = COND_NOT_FLAG3_IN; } break;
case 416:{ yyval.lval = COND_NOT_FLAG4_IN; } break;
case 417:{ yyval.lval = COND_NOT_TF; } break;
case 418:{ yyval.lval = COND_NOT_ECE; } break;
case 419:{ yyval.lval = COND_TRUE; } break;
case 420:{ yyval.lval = COND_FOREVER; } break;
case 421:{ 
			  if( !Z3 )
			      USER_WARN("Use of ADSP21060 condition code without -ADSP21060 switch");
			  yyval.lval = COND_BUS_MASTER; 
		      } break;
case 422:{ 
			  if( !Z3 )
			      USER_WARN("Use of ADSP21060 condition code without -ADSP21060 switch");
			  yyval.lval = COND_NOT_BUS_MASTER; 
		      } break;
case 423:{
			  ilnode.pm_addr = yypvt[-0].expr;
			  ilnode.address_type = ADDRESS_DIRECT;
		      } break;
case 424:{
			  ilnode.address_type = ADDRESS_PC_RELATIVE;
		      } break;
case 425:{
			  ilnode.address_type = ADDRESS_INDIRECT;
		      } break;
case 426:{
			  ilnode.pm_addr = yypvt[-0].expr;
			  ilnode.address_type = ADDRESS_DIRECT;
		      } break;
case 427:{ 
			  ilnode.address_type = ADDRESS_PC_RELATIVE;
		      } break;
case 428:{
			  ilnode.address_type = ADDRESS_INDIRECT;
		      } break;
case 429:{
			  ilnode.pc_disp = yypvt[-1].expr;
		       } break;
case 430:{
			  if( IS_DAG2_MODIFY_REG(REG(yypvt[-3].regval)) )
			      ilnode.pm_mreg = (short) REG(yypvt[-3].regval);
			  else
			  {
			      USER_ERROR( "Illegal program memory modify register." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
			  if( IS_DAG2_INDEX_REG(REG(yypvt[-1].regval)) )
			      ilnode.pm_ireg = (short) REG(yypvt[-1].regval);
			  else
			  {
			      USER_ERROR( "Illegal program memory index register." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 431:{
			  ilnode.d = D_WRITE; 
		      } break;
case 432:{
			  ilnode.d = D_READ; 
		      } break;
case 433:{
			  ilnode.d = D_WRITE;
		      } break;
case 434:{
			  ilnode.d = D_READ;
		      } break;
case 435:{
			  if( IS_REG_FILE(REG(yypvt[-0].regval)) )
			      ilnode.dm_dreg = (short) REG(yypvt[-0].regval);
			  else
			  {
			      USER_ERROR( "Illegal data file register." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 436:{
			  if( IS_REG_FILE(REG(yypvt[-2].regval)) )
			      ilnode.dm_dreg = (short) REG(yypvt[-2].regval);
			  else
			  {
			      USER_ERROR( "Illegal data file register." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 437:{
			  if( IS_REG_FILE(REG(yypvt[-2].regval)) )
			      ilnode.pm_dreg = (short) REG(yypvt[-2].regval);
			  else
			  {
			      USER_ERROR( "Illegal data file register." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 438:{
			  if( IS_REG_FILE(REG(yypvt[-0].regval)) )
			      ilnode.pm_dreg = (short) REG(yypvt[-0].regval);
			  else
			  {
			      USER_ERROR( "Illegal data file register." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 439:{
			  if( IS_DAG2_INDEX_REG(REG(yypvt[-3].regval)) )
			      ilnode.pm_ireg = (short) REG(yypvt[-3].regval);
			  else
			  {
			      USER_ERROR( "Illegal program memory index register." );
			      ilnode.error_occurred = ASM_ERROR;
			  }

			  if( IS_DAG2_MODIFY_REG(REG(yypvt[-1].regval)) )
			      ilnode.pm_mreg = (short) REG(yypvt[-1].regval);
			  else
			  {
			      USER_ERROR( "Illegal program memory modify register." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 440:{
			  if( IS_DAG2_INDEX_REG(REG(yypvt[-1].regval)) )
			      ilnode.pm_ireg = (short) REG(yypvt[-1].regval);
			  else
			  {
			      USER_ERROR( "Illegal program memory index register." );
			      ilnode.error_occurred = ASM_ERROR;
			  }

			  if( IS_DAG2_MODIFY_REG(REG(yypvt[-3].regval)) )
			      ilnode.pm_mreg = (short) REG(yypvt[-3].regval);
			  else
			  {
			      USER_ERROR( "Illegal program memory modify register." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 441:{
			  ilnode.pm_disp = yypvt[-1].expr;

			  if( IS_DAG2_INDEX_REG(REG(yypvt[-3].regval)) )
			      ilnode.pm_ireg = (short) REG(yypvt[-3].regval);
			  else
			  {
			      USER_ERROR( "Illegal program memory index register." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 442:{
			  ilnode.pm_disp = yypvt[-3].expr;

			  if( IS_DAG2_INDEX_REG(REG(yypvt[-1].regval)) )
			      ilnode.pm_ireg = (short) REG(yypvt[-1].regval);
			  else
			  {
			      USER_ERROR( "Illegal program memory index register." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 443:{
			  if( IS_DAG1_INDEX_REG(REG(yypvt[-3].regval)) )
			      ilnode.dm_ireg = (short) REG(yypvt[-3].regval);
			  else
			  {
			      USER_ERROR( "Illegal data memory index register." );
			      ilnode.error_occurred = ASM_ERROR;
			  }

			  if( IS_DAG1_MODIFY_REG(REG(yypvt[-1].regval)) )
			      ilnode.dm_mreg = (short) REG(yypvt[-1].regval);
			  else
			  {
			      USER_ERROR( "Illegal data memory modify register." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 444:{
			  if( IS_DAG1_INDEX_REG(REG(yypvt[-1].regval)) )
			      ilnode.dm_ireg = (short) REG(yypvt[-1].regval);
			  else
			  {
			      USER_ERROR( "Illegal data memory index register." );
			      ilnode.error_occurred = ASM_ERROR;
			  }

			  if( IS_DAG1_MODIFY_REG(REG(yypvt[-3].regval)) )
			      ilnode.dm_mreg = (short) REG(yypvt[-3].regval);
			  else
			  {
			      USER_ERROR( "Illegal data memory modify register." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 445:{
			  ilnode.dm_disp= yypvt[-1].expr;
			  if( IS_DAG1_INDEX_REG(REG(yypvt[-3].regval)) )
			      ilnode.dm_ireg = (short) REG(yypvt[-3].regval);
			  else
			  {
			      USER_ERROR( "Illegal data memory index register." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 446:{
			  ilnode.dm_disp = yypvt[-3].expr;

			  if( IS_DAG1_INDEX_REG(REG(yypvt[-1].regval)) )
			      ilnode.dm_ireg = (short) REG(yypvt[-1].regval);
			  else
			  {
			      USER_ERROR( "Illegal data memory index register." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 447:{
			  ilnode.dm_addr = yypvt[-1].expr;
		      } break;
case 448:{
			  ilnode.pm_addr = yypvt[-1].expr;
		      } break;
case 449:{ ; } break;
case 450:{ ; } break;
case 451:{ ; } break;
case 452:{ ; } break;
case 453:{ ; } break;
case 454:{ ; } break;
case 455:{
			  if( IS_FLOAT_REG(yypvt[-5].regval) && IS_FLOAT_REG(yypvt[-3].regval) && IS_FLOAT_REG(yypvt[-1].regval)
			      && (yypvt[-0].lval == DEFAULT_MULT_MODIFIER) )
			  {
			      make_multiplier( REG(yypvt[-3].regval), REG(yypvt[-1].regval), REG(yypvt[-5].regval), 
					       MULTIPLIER_FP_MULT, 0L );
			  }
			  else
			  {
			     make_multiplier( REG(yypvt[-3].regval), REG(yypvt[-1].regval), REG(yypvt[-5].regval), 
					      mult_opcode(MULTIPLIER_FIXED_MULT, yypvt[-0].lval), 
					      0L );
			  }
		      } break;
case 456:{
			  if( IS_DATA_REG(yypvt[-3].regval) && IS_DATA_REG(yypvt[-1].regval) )
			  {
			      make_multiplier( REG(yypvt[-3].regval), REG(yypvt[-1].regval), NULL_OPERAND, 
					       mult_opcode(MULTIPLIER_FIXED_MULT, yypvt[-0].lval), 
					       MULTIPLIER_MRF_OR_MRB );
			  }
			  else
			  {
			      USER_ERROR( "Illegal register operands in multiplier instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 457:{
			  if( IS_DATA_REG(yypvt[-3].regval) && IS_DATA_REG(yypvt[-1].regval) )
			  {
			      make_multiplier( REG(yypvt[-3].regval), REG(yypvt[-1].regval), NULL_OPERAND, 
					       mult_opcode(MULTIPLIER_FIXED_MULT, yypvt[-0].lval),
					       MULTIPLIER_MRF_OR_MRB | MULTIPLIER_MRB );
			  }
			  else
			  {
			      USER_ERROR( "Illegal register operands in multiplier instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 458:{
			  if( IS_DATA_REG(yypvt[-7].regval) && IS_DATA_REG(yypvt[-3].regval) && IS_DATA_REG(yypvt[-1].regval) )
			  {
			      make_multiplier( REG(yypvt[-3].regval), REG(yypvt[-1].regval), REG(yypvt[-7].regval), 
					       mult_opcode(MULTIPLIER_MULT_ACCUM_ADD, yypvt[-0].lval), 0L );
			  }
			  else
			  {
			      USER_ERROR( "Illegal register operands in multiplier instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 459:{
			  if( IS_DATA_REG(yypvt[-7].regval) && IS_DATA_REG(yypvt[-3].regval) && IS_DATA_REG(yypvt[-1].regval) )
			  {
			      make_multiplier( REG(yypvt[-3].regval), REG(yypvt[-1].regval), REG(yypvt[-7].regval), 
					       mult_opcode(MULTIPLIER_MULT_ACCUM_ADD, yypvt[-0].lval), 
					       MULTIPLIER_MRB );
			  }
			  else
			  {
			      USER_ERROR( "Illegal register operands in multiplier instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 460:{
			  if( IS_DATA_REG(yypvt[-3].regval) && IS_DATA_REG(yypvt[-1].regval) )
			  {
			      make_multiplier( REG(yypvt[-3].regval), REG(yypvt[-1].regval), NULL_OPERAND, 
					       mult_opcode(MULTIPLIER_MULT_ACCUM_ADD, yypvt[-0].lval), 
					       MULTIPLIER_MRF_OR_MRB );
			  }
			  else
			  {
			      USER_ERROR( "Illegal register operands in multiplier instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 461:{
			  if( IS_DATA_REG(yypvt[-3].regval) && IS_DATA_REG(yypvt[-1].regval) )
			  {
			      make_multiplier( REG(yypvt[-3].regval), REG(yypvt[-1].regval), NULL_OPERAND, 
					       mult_opcode(MULTIPLIER_MULT_ACCUM_ADD, yypvt[-0].lval), 
					       MULTIPLIER_MRF_OR_MRB | MULTIPLIER_MRB );
			  }
			  else
			  {
			      USER_ERROR( "Illegal register operands in multiplier instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 462:{
			  if( IS_DATA_REG(yypvt[-7].regval) && IS_DATA_REG(yypvt[-3].regval) && IS_DATA_REG(yypvt[-1].regval) )
			  {
			      make_multiplier( REG(yypvt[-3].regval), REG(yypvt[-1].regval), REG(yypvt[-7].regval), 
					       mult_opcode(MULTIPLIER_MULT_ACCUM_SUB, yypvt[-0].lval), 0L );
			  }
			  else
			  {
			      USER_ERROR( "Illegal register operands in multiplier instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 463:{
			  if( IS_DATA_REG(yypvt[-7].regval) && IS_DATA_REG(yypvt[-3].regval) && IS_DATA_REG(yypvt[-1].regval) )
			  {
			      make_multiplier( REG(yypvt[-3].regval), REG(yypvt[-1].regval), REG(yypvt[-7].regval), 
					       mult_opcode(MULTIPLIER_MULT_ACCUM_SUB, yypvt[-0].lval), 
					       MULTIPLIER_MRB );
			  }
			  else
			  {
			      USER_ERROR( "Illegal register operands in multiplier instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 464:{
			  if( IS_DATA_REG(yypvt[-3].regval) && IS_DATA_REG(yypvt[-1].regval) )
			  {
			      make_multiplier( REG(yypvt[-3].regval), REG(yypvt[-1].regval), NULL_OPERAND, 
					       mult_opcode(MULTIPLIER_MULT_ACCUM_SUB, yypvt[-0].lval), 
					       MULTIPLIER_MRF_OR_MRB );
			  }
			  else
			  {
			      USER_ERROR( "Illegal register operands in multiplier instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 465:{
			  if( IS_DATA_REG(yypvt[-3].regval) && IS_DATA_REG(yypvt[-1].regval) )
			  {
			      make_multiplier( REG(yypvt[-3].regval), REG(yypvt[-1].regval), NULL_OPERAND, 
					       mult_opcode(MULTIPLIER_MULT_ACCUM_SUB, yypvt[-0].lval), 
					       MULTIPLIER_MRF_OR_MRB | MULTIPLIER_MRB );
			  }
			  else
			  {
			      USER_ERROR( "Illegal register operands in multiplier instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 466:{
			  if( IS_DATA_REG(yypvt[-4].regval) )
			  {
			      make_multiplier( NULL_OPERAND, NULL_OPERAND, REG(yypvt[-4].regval), 
					       mult_opcode(MULTIPLIER_SATURATE, yypvt[-0].lval), 0L );
			  }
			  else
			  {
			      USER_ERROR( "Illegal register operand in multiplier instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 467:{
			  if( IS_DATA_REG(yypvt[-4].regval) )
			  {
			      make_multiplier( NULL_OPERAND, NULL_OPERAND, REG(yypvt[-4].regval),
					    mult_opcode(MULTIPLIER_SATURATE, yypvt[-0].lval), MULTIPLIER_MRB );
			  }
			  else
			  {
			      USER_ERROR( "Illegal register operand in multiplier instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 468:{
			  make_multiplier( NULL_OPERAND, NULL_OPERAND, NULL_OPERAND, 
					   mult_opcode(MULTIPLIER_SATURATE, yypvt[-0].lval), 
					   MULTIPLIER_MRF_OR_MRB );
		      } break;
case 469:{
			  make_multiplier( NULL_OPERAND, NULL_OPERAND, NULL_OPERAND, 
					   mult_opcode(MULTIPLIER_SATURATE, yypvt[-0].lval), 
					   MULTIPLIER_MRF_OR_MRB | MULTIPLIER_MRB );
		      } break;
case 470:{
			  if( IS_DATA_REG(yypvt[-4].regval) )
			  {
			      make_multiplier( NULL_OPERAND, NULL_OPERAND, REG(yypvt[-4].regval), 
					       mult_opcode(MULTIPLIER_RND, yypvt[-0].lval), 0L );
			  }
			  else
			  {
			      USER_ERROR( "Illegal register operands in multiplier instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 471:{
			  if( IS_DATA_REG(yypvt[-4].regval) )
			  {
			      make_multiplier( NULL_OPERAND, NULL_OPERAND, REG(yypvt[-4].regval), 
					       mult_opcode(MULTIPLIER_RND, yypvt[-0].lval), MULTIPLIER_MRB );
			  }
			  else
			  {
			      USER_ERROR( "Illegal register operands in multiplier instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 472:{
			  make_multiplier( NULL_OPERAND, NULL_OPERAND, NULL_OPERAND, 
					   mult_opcode(MULTIPLIER_RND, yypvt[-0].lval), MULTIPLIER_MRF_OR_MRB );
		      } break;
case 473:{
			  make_multiplier( NULL_OPERAND, NULL_OPERAND, NULL_OPERAND, 
					   mult_opcode(MULTIPLIER_RND, yypvt[-0].lval), 
					   MULTIPLIER_MRF_OR_MRB | MULTIPLIER_MRB );
		      } break;
case 474:{
			  if( INT_VAL(yypvt[-0].expr) == 0 )
			      make_multiplier( NULL_OPERAND, NULL_OPERAND, NULL_OPERAND, 
					       MULTIPLIER_CLR_MRF, 0L );
			  else
			  {
			      USER_ERROR( "MRF may only be set to 0." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 475:{
			  if( INT_VAL(yypvt[-0].expr) == 0 )
			      make_multiplier( NULL_OPERAND, NULL_OPERAND, NULL_OPERAND, 
					       MULTIPLIER_CLR_MRB, 0L );
			  else
			  {
			      USER_ERROR( "MRB may only be set to zero." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 476:{ yyval.lval = yypvt[-1].lval; } break;
case 477:{ yyval.lval = DEFAULT_MULT_MODIFIER; } break;
case 478:{
			  if( IS_DATA_REG(yypvt[-4].regval) && IS_DATA_REG(yypvt[-2].regval) && IS_DATA_REG(yypvt[-0].regval) )
			      make_alu( REG(yypvt[-2].regval), REG(yypvt[-0].regval), REG(yypvt[-4].regval), FIXED_ALU_ADD );
			  else if( IS_FLOAT_REG(yypvt[-4].regval) && IS_FLOAT_REG(yypvt[-2].regval) && IS_FLOAT_REG(yypvt[-0].regval) )
			      make_alu( REG(yypvt[-2].regval), REG(yypvt[-0].regval), REG(yypvt[-4].regval), FP_ALU_ADD );
			  else
			  {
			      USER_ERROR( "Illegal register specification." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 479:{
			  if( IS_DATA_REG(yypvt[-4].regval) && IS_DATA_REG(yypvt[-2].regval) && IS_DATA_REG(yypvt[-0].regval) )
			      make_alu( REG(yypvt[-2].regval), REG(yypvt[-0].regval), REG(yypvt[-4].regval), FIXED_ALU_SUB );
			  else if( IS_FLOAT_REG(yypvt[-4].regval) && IS_FLOAT_REG(yypvt[-2].regval) && IS_FLOAT_REG(yypvt[-0].regval) )
			      make_alu( REG(yypvt[-2].regval), REG(yypvt[-0].regval), REG(yypvt[-4].regval), FP_ALU_SUB );
			  else
			  {
			      USER_ERROR( "Illegal register specification." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 480:{
			  if( INT_VAL(yypvt[-0].expr) == 2 )
			  {
			     if( IS_DATA_REG(yypvt[-8].regval) && IS_DATA_REG(yypvt[-5].regval) && IS_DATA_REG(yypvt[-3].regval) )
				 make_alu( REG(yypvt[-5].regval), REG(yypvt[-3].regval), REG(yypvt[-8].regval), FIXED_ALU_ADD_DIV_BY_2 );
			     else if( IS_FLOAT_REG(yypvt[-8].regval) && IS_FLOAT_REG(yypvt[-5].regval) && IS_FLOAT_REG(yypvt[-3].regval) )
				 make_alu( REG(yypvt[-5].regval), REG(yypvt[-3].regval), REG(yypvt[-8].regval), FP_ALU_ADD_DIV_BY_2 );
			     else
			     {
				 USER_ERROR( "Illegal register specification." );
				 ilnode.error_occurred = ASM_ERROR;
			     }
			  }
			  else
			      USER_ERROR( "Illegal constant in alu operation." );
		      } break;
case 481:{
			  if( IS_DATA_REG(yypvt[-4].regval) && IS_DATA_REG(yypvt[-2].regval) )
			      make_alu( REG(yypvt[-2].regval), NULL_OPERAND, REG(yypvt[-4].regval), FIXED_ALU_ADD_X_WITH_CARRY );
			  else
			  {
			      USER_ERROR( "Illegal operands in ADD with carry operation." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 482:{
			  if( IS_DATA_REG(yypvt[-6].regval) && IS_DATA_REG(yypvt[-4].regval) )
			  {
			      if( INT_VAL(yypvt[-0].expr) == 1)
				   make_alu( REG(yypvt[-4].regval), NULL_OPERAND, REG(yypvt[-6].regval), 
					     FIXED_ALU_ADD_X_WITH_BORROW );
			      else
			      {
				  USER_ERROR( "Ilegal constant in alu operation." );
				  ilnode.error_occurred = ASM_ERROR;
			      }
			  }
			  else
			  {
			      USER_ERROR( "Illegal operands in ADD with carry operation." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 483:{
			  if( IS_DATA_REG(yypvt[-6].regval) && IS_DATA_REG(yypvt[-4].regval) && IS_DATA_REG(yypvt[-2].regval) )
			      make_alu( REG(yypvt[-4].regval), REG(yypvt[-2].regval), REG(yypvt[-6].regval), FIXED_ALU_ADD_X_Y_WITH_CARRY );
			  else
			  {
			      USER_ERROR( "Illegal operands in ADD with carry operation." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 484:{
			  if( IS_DATA_REG(yypvt[-4].regval) && IS_DATA_REG(yypvt[-2].regval) )
			  {
			      if( INT_VAL(yypvt[-0].expr) == 1 )
				  make_alu( REG(yypvt[-2].regval), NULL_OPERAND, REG(yypvt[-4].regval), FIXED_ALU_INCREMENT );
			      else
			      {
				  USER_ERROR( "Ilegal constant in alu operation." );
				  ilnode.error_occurred = ASM_ERROR;
			      }
			  }
			  else
			  {
			      USER_ERROR( "Illegal operands in increment operation." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 485:{
			  if( IS_DATA_REG(yypvt[-4].regval) && IS_DATA_REG(yypvt[-2].regval) )
			  {
			      if( INT_VAL(yypvt[-0].expr) == 1 )
				  make_alu( REG(yypvt[-2].regval), NULL_OPERAND, REG(yypvt[-4].regval), FIXED_ALU_DECREMENT );
			      else
			      {
				  USER_ERROR( "Ilegal constant in alu operation." );
				  ilnode.error_occurred = ASM_ERROR;
			      }
			  }
			  else
			  {
			      USER_ERROR( "Illegal operands in decrement operation." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 486:{
			  if( IS_DATA_REG(yypvt[-8].regval) && IS_DATA_REG(yypvt[-6].regval) && IS_DATA_REG(yypvt[-4].regval) )
			  {
			      if( INT_VAL(yypvt[-0].expr) == 1 )
				  make_alu( REG(yypvt[-6].regval), REG(yypvt[-4].regval), REG(yypvt[-8].regval), FIXED_ALU_SUB_WITH_BORROW );
			      else
			      {
				  USER_ERROR( "Ilegal constant in alu operation." );
				  ilnode.error_occurred = ASM_ERROR;
			      } 
			  }
			  else
			  {
			      USER_ERROR( "Illegal operands in ADD with carry operation." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 487:{
			  if( IS_DATA_REG(yypvt[-3].regval) && IS_DATA_REG(yypvt[-0].regval) )
			      make_alu( REG(yypvt[-0].regval), NULL_OPERAND, REG(yypvt[-3].regval), FIXED_ALU_NEGATE );
			  else if( IS_FLOAT_REG(yypvt[-3].regval) && IS_FLOAT_REG(yypvt[-0].regval) )
			      make_alu( REG(yypvt[-0].regval), NULL_OPERAND, REG(yypvt[-3].regval), FP_ALU_NEGATE );
			  else
			  {
			      USER_ERROR( "Float and scalar register cannot be mixed." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 488:{
			  if( IS_DATA_REG(yypvt[-3].regval) && IS_DATA_REG(yypvt[-0].regval) )
			      make_alu( REG(yypvt[-0].regval), NULL_OPERAND, REG(yypvt[-3].regval), FIXED_ALU_ABS );
			  else if( IS_FLOAT_REG(yypvt[-3].regval) && IS_FLOAT_REG(yypvt[-0].regval) )
			      make_alu( REG(yypvt[-0].regval), NULL_OPERAND, REG(yypvt[-3].regval), FP_ALU_ABS );
			  else
			  {
			      USER_ERROR( "Float and scalar registers cannot be mixed." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 489:{
			  if( IS_DATA_REG(yypvt[-3].regval) && IS_DATA_REG(yypvt[-0].regval) )
			      make_alu( REG(yypvt[-0].regval), NULL_OPERAND, REG(yypvt[-3].regval), FIXED_ALU_PASS );
			  else if( IS_FLOAT_REG(yypvt[-3].regval) && IS_FLOAT_REG(yypvt[-0].regval) )
			      make_alu( REG(yypvt[-0].regval), NULL_OPERAND, REG(yypvt[-3].regval), FP_ALU_PASS );
			  else
			  {
			      USER_ERROR( "Float and scalar registers cannot be mixed." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 490:{
			  if( IS_DATA_REG(yypvt[-4].regval) && IS_DATA_REG(yypvt[-2].regval) && IS_DATA_REG(yypvt[-0].regval) )
			      make_alu( REG(yypvt[-2].regval), REG(yypvt[-0].regval), REG(yypvt[-4].regval), FIXED_ALU_AND );
			  else
			  {
			      USER_ERROR( "Illegal operands in AND instruction " );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 491:{
			  if( IS_DATA_REG(yypvt[-4].regval) && IS_DATA_REG(yypvt[-2].regval) && IS_DATA_REG(yypvt[-0].regval) )
			      make_alu( REG(yypvt[-2].regval), REG(yypvt[-0].regval), REG(yypvt[-4].regval), FIXED_ALU_OR );
			  else
			  {
			      USER_ERROR( "Illegal operands in OR instruction " );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 492:{
			  if( IS_DATA_REG(yypvt[-4].regval) && IS_DATA_REG(yypvt[-2].regval) && IS_DATA_REG(yypvt[-0].regval) )
			      make_alu( REG(yypvt[-2].regval), REG(yypvt[-0].regval), REG(yypvt[-4].regval), FIXED_ALU_XOR );
			  else
			  {
			      USER_ERROR( "Illegal operands in XOR instruction " );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 493:{
			  if( IS_DATA_REG(yypvt[-3].regval) && IS_DATA_REG(yypvt[-0].regval) )
			      make_alu( REG(yypvt[-0].regval), NULL_OPERAND, REG(yypvt[-3].regval), FIXED_ALU_NOT );
			  else
			  {
			      USER_ERROR( "Illegal operands in NOT instruction " );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 494:{
			  if( IS_DATA_REG(yypvt[-7].regval) && IS_DATA_REG(yypvt[-3].regval) && IS_DATA_REG(yypvt[-1].regval) )
			      make_alu( REG(yypvt[-3].regval), REG(yypvt[-1].regval), REG(yypvt[-7].regval), FIXED_ALU_MIN );
			  else if( IS_FLOAT_REG(yypvt[-7].regval) && IS_FLOAT_REG(yypvt[-3].regval) && IS_FLOAT_REG(yypvt[-1].regval) )
			      make_alu( REG(yypvt[-3].regval), REG(yypvt[-1].regval), REG(yypvt[-7].regval), FP_ALU_MIN );
			  else
			  {
			      USER_ERROR( "Illegal register usage in alu max instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 495:{
			  if( IS_DATA_REG(yypvt[-7].regval) && IS_DATA_REG(yypvt[-3].regval) && IS_DATA_REG(yypvt[-1].regval) )
			      make_alu( REG(yypvt[-3].regval), REG(yypvt[-1].regval), REG(yypvt[-7].regval), FIXED_ALU_MAX );
			  else if( IS_FLOAT_REG(yypvt[-7].regval) && IS_FLOAT_REG(yypvt[-3].regval) && IS_FLOAT_REG(yypvt[-1].regval) )
			      make_alu( REG(yypvt[-3].regval), REG(yypvt[-1].regval), REG(yypvt[-7].regval), FP_ALU_MAX );
			  else
			  {
			      USER_ERROR( "Illegal register usage in alu max instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 496:{
			  if( IS_DATA_REG(yypvt[-5].regval) && IS_DATA_REG(yypvt[-2].regval) && IS_DATA_REG(yypvt[-0].regval) )
			      make_alu( REG(yypvt[-2].regval), REG(yypvt[-0].regval), REG(yypvt[-5].regval), FIXED_ALU_CLIP );
			  else if( IS_FLOAT_REG(yypvt[-5].regval) && IS_FLOAT_REG(yypvt[-2].regval) && IS_FLOAT_REG(yypvt[-0].regval) )
			      make_alu( REG(yypvt[-2].regval), REG(yypvt[-0].regval), REG(yypvt[-5].regval), FP_ALU_CLIP );
			  else
			  {
			      USER_ERROR( "Illegal register usage in clip instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 497:{
			  if( IS_DATA_REG(yypvt[-3].regval) && IS_DATA_REG(yypvt[-1].regval) )
			      make_alu( REG(yypvt[-3].regval), REG(yypvt[-1].regval), NULL_OPERAND, FIXED_ALU_COMP );
			  else if( IS_FLOAT_REG(yypvt[-3].regval) && IS_FLOAT_REG(yypvt[-1].regval) )
			      make_alu( REG(yypvt[-3].regval), REG(yypvt[-1].regval), NULL_OPERAND, FP_ALU_COMP );
			  else
			  {
			     USER_ERROR( "Illegal register usage in compare instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 498:{
			  if( IS_FLOAT_REG(yypvt[-4].regval) && IS_FLOAT_REG(yypvt[-2].regval) && IS_FLOAT_REG(yypvt[-0].regval) )
			     make_alu( REG(yypvt[-2].regval), REG(yypvt[-0].regval), REG(yypvt[-4].regval), FP_ALU_COPYSIGN );
			  else
			  {
			     USER_ERROR( "Illegal register usage in copysign instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 499:{
			  if( IS_FLOAT_REG(yypvt[-7].regval) && IS_FLOAT_REG(yypvt[-3].regval) && IS_FLOAT_REG(yypvt[-1].regval) )
			      make_alu( REG(yypvt[-3].regval), REG(yypvt[-1].regval), REG(yypvt[-7].regval), FP_ALU_ABS_X_PLUS_Y );
			  else
			  {
			     USER_ERROR( "Illegal register usage in absolute value instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 500:{
			  if( IS_FLOAT_REG(yypvt[-7].regval) && IS_FLOAT_REG(yypvt[-3].regval) && IS_FLOAT_REG(yypvt[-1].regval) )
			      make_alu( REG(yypvt[-3].regval), REG(yypvt[-1].regval), REG(yypvt[-7].regval), FP_ALU_ABS_X_MINUS_Y );
			  else
			  {
			     USER_ERROR( "Illegal register usage in absolute value instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 501:{
			  if( IS_DATA_REG(yypvt[-3].regval) && IS_FLOAT_REG(yypvt[-0].regval) )
			      make_alu( REG(yypvt[-0].regval), NULL_OPERAND, REG(yypvt[-3].regval), FP_ALU_LOGB );
			  else
			  {
			      USER_ERROR( "Illegal register operands in LOGB instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 502:{
			if( IS_FLOAT_REG(yypvt[-5].regval) && IS_FLOAT_REG(yypvt[-2].regval) && IS_DATA_REG(yypvt[-0].regval) )
			    make_alu( REG(yypvt[-2].regval), REG(yypvt[-0].regval), REG(yypvt[-5].regval), FP_ALU_SCALB );
			else
			  {
			      USER_ERROR( "Illegal register operands in SCALB instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 503:{
			  if( IS_DATA_REG(yypvt[-3].regval) && IS_FLOAT_REG(yypvt[-0].regval) )
			      make_alu( REG(yypvt[-0].regval), NULL_OPERAND, REG(yypvt[-3].regval), FP_ALU_MANT );
			  else
			  {
			      USER_ERROR( "Illegal operands in MANT instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 504:{
			  if( IS_DATA_REG(yypvt[-3].regval) && IS_FLOAT_REG(yypvt[-0].regval) )
			      make_alu( REG(yypvt[-0].regval), NULL_OPERAND, REG(yypvt[-3].regval), FP_ALU_FIX_1OP );
			  else
			  {
			      USER_ERROR( "Illegal operands in FIX instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 505:{
			  if( IS_DATA_REG(yypvt[-5].regval) && IS_FLOAT_REG(yypvt[-2].regval) && IS_DATA_REG(yypvt[-0].regval) )
			      make_alu( REG(yypvt[-2].regval), REG(yypvt[-0].regval), REG(yypvt[-5].regval), FP_ALU_FIX_2OP );
			  else
			  {
			      USER_ERROR( "Illegal register operands in FIX instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 506:{
			  if( IS_DATA_REG(yypvt[-2].regval) && IS_DATA_REG(yypvt[-0].regval) && IS_FLOAT_REG(yypvt[-5].regval) )
			      make_alu( REG(yypvt[-2].regval), REG(yypvt[-0].regval), REG(yypvt[-5].regval), FP_ALU_FLOAT_2OP );
			  else
			  {
			      USER_ERROR( "Illegal register operands in FLOAT instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		     } break;
case 507:{
			  if( IS_DATA_REG(yypvt[-0].regval) && IS_FLOAT_REG(yypvt[-3].regval) )
			      make_alu( REG(yypvt[-0].regval), NULL_OPERAND, REG(yypvt[-3].regval), FP_ALU_FLOAT_1OP );
			  else
			  {
			      USER_ERROR( "Illegal operands in FLOAT instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 508:{
			  if( IS_FLOAT_REG(yypvt[-0].regval) && IS_FLOAT_REG(yypvt[-3].regval) )
			      make_alu( REG(yypvt[-0].regval), NULL_OPERAND, REG(yypvt[-3].regval), FP_ALU_RECIPS );
			  else
			  {
			      USER_ERROR( "Illegal operands in RECIPS instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 509:{
			  if( IS_FLOAT_REG(yypvt[-0].regval) && IS_FLOAT_REG(yypvt[-3].regval) )
			      make_alu( REG(yypvt[-0].regval), NULL_OPERAND, REG(yypvt[-3].regval), FP_ALU_RSQRTS );
			  else
			  {
			      USER_ERROR( "Illegal operands in RSQRTS instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 510:{
			  if( IS_FLOAT_REG(yypvt[-3].regval) && IS_FLOAT_REG(yypvt[-0].regval) )
			      make_alu( REG(yypvt[-0].regval), NULL_OPERAND, REG(yypvt[-3].regval), FP_ALU_RND );
			  else
			  {
			      USER_ERROR( "Illegal operands in round instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 511:{
			  if( !Z3 )
			      USER_WARN("Use of ADSP21060 FUNPACK instruction without -ADSP21060 switch");
			  if( IS_DATA_REG(yypvt[-0].regval) && IS_FLOAT_REG(yypvt[-3].regval) ) 
			     make_alu( REG(yypvt[-0].regval), NULL_OPERAND, REG(yypvt[-3].regval), FP_ALU_FUNPACK );
			  else
			  {
			      USER_ERROR( "Illegal operands in FUNPACK instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 512:{
			  if( !Z3 )
			      USER_WARN("Use of ADSP21060 FPACK instruction without -ADSP21060 switch");
			  if( IS_DATA_REG(yypvt[-3].regval) && IS_FLOAT_REG(yypvt[-0].regval) )
			     make_alu( REG(yypvt[-0].regval), NULL_OPERAND, REG(yypvt[-3].regval), FP_ALU_FPACK );
			  else
			  {
			      USER_ERROR( "Illegal operands in FPACK instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 513:{
			  if( !Z3 )
			      USER_WARN("Use of ADSP21060 TRUNC instruction without -ADSP21060 switch");
			  if( IS_DATA_REG(yypvt[-3].regval) && IS_FLOAT_REG(yypvt[-0].regval) ) 
			     make_alu( REG(yypvt[-0].regval), NULL_OPERAND, REG(yypvt[-3].regval), FP_ALU_TRUNC );
			  else
			  {
			      USER_ERROR( "Illegal operands in TRUNC instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 514:{
			  if( !Z3 )
			      USER_WARN("Use of ADSP21060 TRUNC BY instruction without -ADSP21060 switch");
			  if( IS_DATA_REG(yypvt[-5].regval) && IS_FLOAT_REG(yypvt[-2].regval) )
			     make_alu( REG(yypvt[-2].regval), REG(yypvt[-0].regval), REG(yypvt[-5].regval), FP_ALU_TRUNC_BY );
			  else
			  {
			      USER_ERROR( "Illegal operands in TRUNC BY instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 515:{
			  if( IS_DATA_REG(yypvt[-5].regval) && IS_DATA_REG(yypvt[-2].regval) )
			      make_shifter( REG(yypvt[-2].regval), INT_VAL(yypvt[-0].expr), REG(yypvt[-5].regval), SHIFTER_LSHIFT, 
					    SHIFT_IMMEDIATE );
			  else
			  {
			     USER_ERROR( "Illegal register specification in shifter instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 516:{
			  if( IS_DATA_REG(yypvt[-7].regval) && IS_DATA_REG(yypvt[-5].regval) && IS_DATA_REG(yypvt[-2].regval) && 
			      (REG(yypvt[-7].regval) == REG(yypvt[-5].regval)) )
			  {
			      make_shifter( REG(yypvt[-2].regval), INT_VAL(yypvt[-0].expr), REG(yypvt[-7].regval), SHIFTER_OR_LSHIFT,
					    SHIFT_IMMEDIATE );
			  }
			  else
			  {
			     USER_ERROR( "Illegal register specification in shifter instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 517:{
			  if( IS_DATA_REG(yypvt[-5].regval) && IS_DATA_REG(yypvt[-2].regval) )
			      make_shifter( REG(yypvt[-2].regval), INT_VAL(yypvt[-0].expr), REG(yypvt[-5].regval), SHIFTER_ASHIFT, 
					    SHIFT_IMMEDIATE );
			  else
			  {
			     USER_ERROR( "Illegal register specification in shifter instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 518:{
			  if( IS_DATA_REG(yypvt[-7].regval) && IS_DATA_REG(yypvt[-5].regval) && IS_DATA_REG(yypvt[-2].regval) && 
			      (REG(yypvt[-7].regval) == REG(yypvt[-5].regval)) )
			  {
			      make_shifter( REG(yypvt[-2].regval), INT_VAL(yypvt[-0].expr), REG(yypvt[-7].regval), SHIFTER_OR_ASHIFT, 
					    SHIFT_IMMEDIATE );
			  }
			  else
			  {
			     USER_ERROR( "Illegal register specification in shifter instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 519:{
			  if( IS_DATA_REG(yypvt[-5].regval) && IS_DATA_REG(yypvt[-2].regval) )
			      make_shifter( REG(yypvt[-2].regval), INT_VAL(yypvt[-0].expr), REG(yypvt[-5].regval), SHIFTER_ROT, 
					    SHIFT_IMMEDIATE );
			  else
			  {
			     USER_ERROR( "Illegal register specification in shifter instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 520:{
			  if( IS_DATA_REG(yypvt[-5].regval) && IS_DATA_REG(yypvt[-2].regval) )
			      make_shifter( REG(yypvt[-2].regval), INT_VAL(yypvt[-0].expr), REG(yypvt[-5].regval), SHIFTER_BCLR, 
					    SHIFT_IMMEDIATE );
			  else
			  {
			     USER_ERROR( "Illegal register specification in shifter instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 521:{
			  if( IS_DATA_REG(yypvt[-5].regval) && IS_DATA_REG(yypvt[-2].regval) )
			      make_shifter( REG(yypvt[-2].regval), INT_VAL(yypvt[-0].expr), REG(yypvt[-5].regval), SHIFTER_BSET, 
					    SHIFT_IMMEDIATE );
			  else
			  {
			     USER_ERROR( "Illegal register specification in shifter instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 522:{
			  if( IS_DATA_REG(yypvt[-5].regval) && IS_DATA_REG(yypvt[-2].regval) )
			      make_shifter( REG(yypvt[-2].regval), INT_VAL(yypvt[-0].expr), REG(yypvt[-5].regval), SHIFTER_BTGL, 
					    SHIFT_IMMEDIATE );
			  else
			  {
			     USER_ERROR( "Illegal register specification in shifter instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 523:{
			  if( IS_DATA_REG(yypvt[-2].regval) )
			       make_shifter( REG(yypvt[-2].regval), INT_VAL(yypvt[-0].expr), NULL_OPERAND, SHIFTER_BTST, 
					     SHIFT_IMMEDIATE );
			  else
			  {
			     USER_ERROR( "Illegal register specification in shifter instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 524:{
			  if( IS_DATA_REG(yypvt[-6].regval) && IS_DATA_REG(yypvt[-3].regval) )
			      make_shifter( REG(yypvt[-3].regval), INT_VAL(yypvt[-1].expr), REG(yypvt[-6].regval), ((yypvt[-0].lval != SE) ? 
					    SHIFTER_FDEP : SHIFTER_FDEP_SIGN_EXT), SHIFT_IMMEDIATE );
			  else
			  {
			     USER_ERROR( "Illegal register specification in shifter instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 525:{
			  if( IS_DATA_REG(yypvt[-8].regval) && IS_DATA_REG(yypvt[-6].regval) && IS_DATA_REG(yypvt[-3].regval) && 
			      (REG(yypvt[-8].regval) == REG(yypvt[-6].regval)) )
			  {
			      make_shifter( REG(yypvt[-3].regval), INT_VAL(yypvt[-1].expr), REG(yypvt[-8].regval), ((yypvt[-0].lval != SE) ? 
					    SHIFTER_OR_FDEP : SHIFTER_OR_FDEP_SIGN_EXT), 
					    SHIFT_IMMEDIATE );
			  }
			  else
			  {
			     USER_ERROR( "Illegal register specification in shifter instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 526:{
			  if( IS_DATA_REG(yypvt[-6].regval) && IS_DATA_REG(yypvt[-3].regval) )
			      make_shifter( REG(yypvt[-3].regval), INT_VAL(yypvt[-1].expr), REG(yypvt[-6].regval), ((yypvt[-0].lval != SE) ? 
					    SHIFTER_FEXT : SHIFTER_FEXT_SIGN_EXT), SHIFT_IMMEDIATE );
			  else
			  {
			     USER_ERROR( "Illegal register specification in shifter instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 527:{
			  if( IS_DATA_REG(yypvt[-7].regval) && IS_DATA_REG(yypvt[-4].regval) )
			      make_shifter( REG(yypvt[-2].regval), INT_VAL(yypvt[-0].expr), REG(yypvt[-7].regval), SHIFTER_FMERG, 
					    SHIFT_BOTH );
			  else
			  {
			     USER_ERROR( "Illegal register specification in shifter instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		       } break;
case 528:{
			  if( IS_DATA_REG(yypvt[-5].regval) && IS_DATA_REG(yypvt[-2].regval) )
			      make_shifter( REG(yypvt[-2].regval), INT_VAL(yypvt[-0].expr), REG(yypvt[-5].regval), SHIFTER_PACK, 
					    SHIFT_IMMEDIATE );
			  else
			  {
			     USER_ERROR( "Illegal register specification in shifter instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 529:{
			  if( IS_DATA_REG(yypvt[-6].regval) && IS_DATA_REG(yypvt[-3].regval) )
			  {
			      long opcode;

			      switch( (int) yypvt[-0].lval )
			      {
				      case NU:
					 opcode = SHIFTER_UNPACK_NO_UP;
					 break;

				      case SE:
					 opcode = SHIFTER_UNPACK_SIGN_EXT;
					 break;

				      case NU + SE:
					 opcode = SHIFTER_UNPACK_NO_SIGN;
					 break;

				      default:
					 opcode = SHIFTER_UNPACK;
					 break;
			      }
			      make_shifter( REG(yypvt[-3].regval), INT_VAL(yypvt[-1].expr), REG(yypvt[-6].regval), opcode, SHIFT_IMMEDIATE );
			  }
			  else
			  {
			     USER_ERROR( "Illegal register specification in shifter instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 530:{
			  if( IS_DATA_REG(yypvt[-5].regval) && IS_DATA_REG(yypvt[-2].regval) && IS_DATA_REG(yypvt[-0].regval) )
			      make_shifter( REG(yypvt[-2].regval), REG(yypvt[-0].regval), REG(yypvt[-5].regval), SHIFTER_LSHIFT, SHIFT_DREG );
			  else
			  {
			     USER_ERROR( "Illegal register specification in shift instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 531:{
			  if( IS_DATA_REG(yypvt[-7].regval) && IS_DATA_REG(yypvt[-5].regval) && IS_DATA_REG(yypvt[-2].regval) && 
			      (REG(yypvt[-7].regval) == REG(yypvt[-5].regval)) )
			  {
			      make_shifter( REG(yypvt[-2].regval), REG(yypvt[-0].regval), REG(yypvt[-7].regval), SHIFTER_OR_LSHIFT, 
					    SHIFT_DREG );
			  }
			  else
			  {
			     USER_ERROR( "Illegal register specification in shift instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 532:{
			  if( IS_DATA_REG(yypvt[-5].regval) && IS_DATA_REG(yypvt[-2].regval) && IS_DATA_REG(yypvt[-0].regval) )
			      make_shifter( REG(yypvt[-2].regval), REG(yypvt[-0].regval), REG(yypvt[-5].regval), SHIFTER_ASHIFT, SHIFT_DREG );
			  else
			  {
			     USER_ERROR( "Illegal register specification in shift instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 533:{
			  if( IS_DATA_REG(yypvt[-7].regval) && IS_DATA_REG(yypvt[-5].regval) && IS_DATA_REG(yypvt[-2].regval) && 
			      (REG(yypvt[-7].regval) == REG(yypvt[-5].regval)) )
			  {
			      make_shifter( REG(yypvt[-2].regval), REG(yypvt[-0].regval), REG(yypvt[-7].regval), SHIFTER_OR_ASHIFT, 
					    SHIFT_DREG );
			  }
			  else
			     USER_ERROR( "Illegal register specification in shift instruction." );
		      } break;
case 534:{
			  if( IS_DATA_REG(yypvt[-5].regval) && IS_DATA_REG(yypvt[-2].regval) && IS_DATA_REG(yypvt[-0].regval) )
			      make_shifter( REG(yypvt[-2].regval), REG(yypvt[-0].regval), REG(yypvt[-5].regval), SHIFTER_ROT, SHIFT_DREG );
			  else
			  {
			     USER_ERROR( "Illegal register specification in shift instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 535:{
			  if( IS_DATA_REG(yypvt[-5].regval) && IS_DATA_REG(yypvt[-2].regval) && IS_DATA_REG(yypvt[-0].regval) )
			      make_shifter( REG(yypvt[-2].regval), REG(yypvt[-0].regval), REG(yypvt[-5].regval), SHIFTER_BCLR, SHIFT_DREG );
			  else
			  {
			     USER_ERROR( "Illegal register specification in shift instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 536:{
			  if( IS_DATA_REG(yypvt[-5].regval) && IS_DATA_REG(yypvt[-2].regval) && IS_DATA_REG(yypvt[-0].regval) )
			      make_shifter( REG(yypvt[-2].regval), REG(yypvt[-0].regval), REG(yypvt[-5].regval), SHIFTER_BSET, SHIFT_DREG );
			  else
			  {
			     USER_ERROR( "Illegal register specification in shift instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 537:{
			  if( IS_DATA_REG(yypvt[-5].regval) && IS_DATA_REG(yypvt[-2].regval) && IS_DATA_REG(yypvt[-0].regval) )
			      make_shifter( REG(yypvt[-2].regval), REG(yypvt[-0].regval), REG(yypvt[-5].regval), SHIFTER_BTGL, SHIFT_DREG );
			  else
			  {
			     USER_ERROR( "Illegal register specification in shift instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 538:{
			  if( IS_DATA_REG(yypvt[-2].regval) && IS_DATA_REG(yypvt[-0].regval) )
			      make_shifter( REG(yypvt[-2].regval), REG(yypvt[-0].regval), NULL_OPERAND, SHIFTER_BTST, 
					    SHIFT_DREG );
			  else
			  {
			     USER_ERROR( "Illegal register specification in shift instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 539:{
			  if( IS_DATA_REG(yypvt[-6].regval) && IS_DATA_REG(yypvt[-3].regval) && IS_DATA_REG(yypvt[-1].regval) )
			      make_shifter( REG(yypvt[-3].regval), REG(yypvt[-1].regval), REG(yypvt[-6].regval), ((yypvt[-0].lval != SE) ? 
					SHIFTER_FDEP : SHIFTER_FDEP_SIGN_EXT), SHIFT_DREG );
			  else
			  {
			     USER_ERROR( "Illegal register specification in shift instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 540:{
			  if( IS_DATA_REG(yypvt[-8].regval) && IS_DATA_REG(yypvt[-6].regval) && IS_DATA_REG(yypvt[-3].regval) && 
			      IS_DATA_REG(yypvt[-1].regval) && (REG(yypvt[-8].regval) == REG(yypvt[-6].regval)) )
			  {
			      make_shifter( REG(yypvt[-3].regval), REG(yypvt[-1].regval), REG(yypvt[-8].regval), ((yypvt[-0].lval != SE) ? 
					    SHIFTER_OR_FDEP : SHIFTER_OR_FDEP_SIGN_EXT), 
					    SHIFT_DREG );
			  }
			  else
			  {
			     USER_ERROR( "Illegal register specification." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 541:{
			  if( IS_DATA_REG(yypvt[-6].regval) && IS_DATA_REG(yypvt[-3].regval) && IS_DATA_REG(yypvt[-1].regval) )
			      make_shifter( REG(yypvt[-3].regval), REG(yypvt[-1].regval), REG(yypvt[-6].regval), ((yypvt[-0].lval != SE) ? 
					    SHIFTER_FEXT : SHIFTER_FEXT_SIGN_EXT), SHIFT_DREG );
			  else
			  {
			     USER_ERROR( "Illegal register specification in shift instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 542:{
			  if( IS_DATA_REG(yypvt[-7].regval) && IS_DATA_REG(yypvt[-4].regval) && IS_DATA_REG(yypvt[-2].regval) && 
			      IS_DATA_REG(yypvt[-0].regval) && (REG(yypvt[-7].regval) == REG(yypvt[-4].regval)) )
			  {    
			      make_shifter( REG(yypvt[-2].regval), REG(yypvt[-0].regval), REG(yypvt[-7].regval), SHIFTER_FMERG, SHIFT_DREG );
			  }
			  else
			  {
			     USER_ERROR( "Illegal register specification in shift instruciton." );
			     ilnode.error_occurred = ASM_ERROR;                       
			  }

		      } break;
case 543:{
			  if( IS_DATA_REG(yypvt[-5].regval) && IS_DATA_REG(yypvt[-2].regval) && IS_DATA_REG(yypvt[-0].regval) )
			      make_shifter( REG(yypvt[-2].regval), REG(yypvt[-0].regval), REG(yypvt[-5].regval), SHIFTER_PACK, SHIFT_DREG );
			  else
			  {
			     USER_ERROR( "Illegal register specification in shift instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 544:{
			  if( IS_DATA_REG(yypvt[-6].regval) && IS_DATA_REG(yypvt[-3].regval) && IS_DATA_REG(yypvt[-1].regval) )
			  {
			      long opcode;

			      switch( (int) yypvt[-0].lval )
			      {
				      case NU:
					 opcode = SHIFTER_UNPACK_NO_UP;
					 break;

				      case SE:
					 opcode = SHIFTER_UNPACK_SIGN_EXT;
					 break;

				      case NU + SE:
					 opcode = SHIFTER_UNPACK_NO_SIGN;
					 break;

				      default:
					 opcode = SHIFTER_UNPACK;
					 break;
			      }
			      make_shifter( REG(yypvt[-3].regval), REG(yypvt[-1].regval), REG(yypvt[-6].regval), opcode, SHIFT_DREG );
			  }
			  else
			  {
			     USER_ERROR( "Illegal register specification in shift instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 545:{
			  if( IS_DATA_REG(yypvt[-4].regval) && IS_DATA_REG(yypvt[-1].regval) )
			      make_shifter( REG(yypvt[-1].regval), NULL_OPERAND, REG(yypvt[-4].regval), ((yypvt[-0].lval != EX) ? 
					    SHIFTER_EXP : SHIFTER_EXP_EXTENDED), SHIFT_DREG );
			  else
			  {
			     USER_ERROR( "Illegal register specification in shift instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 546:{
			  if( IS_DATA_REG(yypvt[-3].regval) && IS_DATA_REG(yypvt[-0].regval) )
			      make_shifter( REG(yypvt[-0].regval), NULL_OPERAND, REG(yypvt[-3].regval), SHIFTER_LEFTZ, 
					    SHIFT_DREG );
			  else
			  {
			     USER_ERROR( "Illegal register specification in shift instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 547:{
			  if( IS_DATA_REG(yypvt[-3].regval) && IS_DATA_REG(yypvt[-0].regval) )
			      make_shifter( REG(yypvt[-0].regval), NULL_OPERAND, REG(yypvt[-3].regval), SHIFTER_LEFTO, 
					    SHIFT_DREG );
			  else
			  {
			     USER_ERROR( "Illegal register specification in shift instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 548:{
			  if( IS_DATA_REG(yypvt[-3].regval) && IS_DATA_REG(yypvt[-0].regval) )
			      make_shifter( REG(yypvt[-0].regval), NULL_OPERAND, REG(yypvt[-3].regval), SHIFTER_NOFZ, 
					    SHIFT_DREG );
			  else
			  {
			     USER_ERROR( "Illegal register specification in shift instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 549:{
			  if( IS_DATA_REG(yypvt[-3].regval) && IS_DATA_REG(yypvt[-0].regval) )
			      make_shifter( REG(yypvt[-0].regval), NULL_OPERAND, REG(yypvt[-3].regval), SHIFTER_NOFO, 
					    SHIFT_DREG );
			  else
			  {
			     USER_ERROR( "Illegal register specification in shift instruction." );
			     ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 550:{ yyval.lval = yypvt[-1].lval; } break;
case 551:{ yyval.lval = yypvt[-1].lval; } break;
case 552:{ yyval.lval = yypvt[-1].lval; } break;
case 553:{ yyval.lval = yypvt[-3].lval + yypvt[-1].lval; } break;
case 554:{ yyval.lval = 0; /*EK*/ } break;
case 555:{
			  if( IS_FLOAT_REG(yypvt[-3].regval) )
			      make_function_unit( NULL_OPERAND, NULL_OPERAND, REG(yypvt[-3].regval), yypvt[-0].lval, 
						  FUNCTION_TRANSFER );
			  else
			  {
			      USER_ERROR( "Illegal operand in function unit instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 556:{
			  if( IS_FLOAT_REG(yypvt[-3].regval) && IS_FLOAT_REG(yypvt[-1].regval) )
			      make_function_unit( REG(yypvt[-3].regval), REG(yypvt[-1].regval), NULL_TRANSFER, yypvt[-0].lval,
						  FUNCTION_DIVIDE );
			  else
			  {
			      USER_ERROR( "Illegal operand in function unit instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 557:{
			  if( IS_FLOAT_REG(yypvt[-9].regval) &&  IS_FLOAT_REG(yypvt[-3].regval) && IS_FLOAT_REG(yypvt[-1].regval) )
			      make_function_unit( REG(yypvt[-3].regval), REG(yypvt[-1].regval), REG(yypvt[-9].regval), yypvt[-0].lval, FUNCTION_DIVIDE );
			  else
			  {
			      USER_ERROR( "Illegal operand in function unit instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 558:{
			  if(  IS_FLOAT_REG(yypvt[-1].regval) && INT_VAL(yypvt[-3].expr) == 1 )
			  {
			      make_function_unit( NULL_OPERAND, REG(yypvt[-1].regval), NULL_TRANSFER, yypvt[-0].lval, 
						  FUNCTION_1_DIV_N );
			  }
			  else
			  {
			      USER_ERROR( "Illegal operand in function unit instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 559:{
			  if(  IS_FLOAT_REG(yypvt[-9].regval) && (INT_VAL(yypvt[-3].expr) == 1) && IS_FLOAT_REG(yypvt[-1].regval) )
			  {
			      make_function_unit( NULL_OPERAND, REG(yypvt[-1].regval), REG(yypvt[-9].regval), yypvt[-0].lval, 
						  FUNCTION_1_DIV_N );
			  }
			  else
			  {
			      USER_ERROR( "Illegal operand in function unit instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 560:{
			  if( IS_FLOAT_REG(yypvt[-4].regval) &&  IS_FLOAT_REG(yypvt[-2].regval) )
			      make_function_unit( REG(yypvt[-4].regval), REG(yypvt[-2].regval), NULL_TRANSFER, yypvt[-0].lval, 
						  FUNCTION_MOD );
			  else
			  {
			      USER_ERROR( "Illegal operand in function unit instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 561:{
			  if( IS_FLOAT_REG(yypvt[-12].regval) && IS_FLOAT_REG(yypvt[-4].regval) && IS_FLOAT_REG(yypvt[-2].regval) )
			      make_function_unit( REG(yypvt[-4].regval), REG(yypvt[-2].regval), REG(yypvt[-12].regval), yypvt[-0].lval, FUNCTION_MOD );
			  else
			  {
			      USER_ERROR( "Illegal operand in function unit instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 562:{
			  if( IS_FLOAT_REG(yypvt[-1].regval) )
			      make_function_unit( REG(yypvt[-1].regval), NULL_OPERAND, NULL_TRANSFER, yypvt[-0].lval, 
						  FUNCTION_SQR );
			  else
			  {
			      USER_ERROR( "Illegal operand in function unit instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 563:{
			  if(  IS_FLOAT_REG(yypvt[-8].regval) && IS_FLOAT_REG(yypvt[-1].regval) )
			       make_function_unit( REG(yypvt[-1].regval), NULL_OPERAND, REG(yypvt[-8].regval), yypvt[-0].lval, 
						   FUNCTION_SQR );
			  else
			  {
			      USER_ERROR( "Illegal operand in function unit instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 564:{
			  if( INT_VAL(yypvt[-4].expr) == 1 && IS_FLOAT_REG(yypvt[-2].regval) )
			  {
			      make_function_unit( REG(yypvt[-2].regval), NULL_OPERAND, NULL_TRANSFER, yypvt[-0].lval, 
						  FUNCTION_SQR_1_DIV_N );
			  }
			  else
			  {
			      USER_ERROR( "Illegal operand in function unit instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 565:{
			  if( IS_FLOAT_REG(yypvt[-12].regval) && INT_VAL(yypvt[-4].expr) == 1 && IS_FLOAT_REG(yypvt[-2].regval) )
			  {
			      make_function_unit( REG(yypvt[-2].regval), NULL_OPERAND, REG(yypvt[-12].regval), yypvt[-0].lval, 
						  FUNCTION_SQR_1_DIV_N );
			  }
			  else
			  {
			      USER_ERROR( "Illegal operand in function unit instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 566:{
			  if( IS_FLOAT_REG(yypvt[-1].regval) )
			      make_function_unit( REG(yypvt[-1].regval), NULL_OPERAND, NULL_TRANSFER, yypvt[-0].lval, 
						  FUNCTION_EXP2 );
			  else
			  {
			      USER_ERROR( "Illegal operand in function unit instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 567:{
			  if( IS_FLOAT_REG(yypvt[-8].regval) && IS_FLOAT_REG(yypvt[-1].regval) )
			      make_function_unit( REG(yypvt[-1].regval), NULL_OPERAND, REG(yypvt[-8].regval), yypvt[-0].lval, 
						  FUNCTION_EXP2 );
			  else
			  {
			      USER_ERROR( "Illegal operand in function unit instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 568:{
			  if( IS_FLOAT_REG(yypvt[-1].regval) )
			      make_function_unit( REG(yypvt[-1].regval), NULL_OPERAND, NULL_TRANSFER, yypvt[-0].lval, 
						  FUNCTION_LOG2 );
			  else
			  {
			      USER_ERROR( "Illegal operand in function unit instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 569:{
			  if( IS_FLOAT_REG(yypvt[-8].regval) && IS_FLOAT_REG(yypvt[-1].regval) )
			      make_function_unit( REG(yypvt[-1].regval), NULL_OPERAND, REG(yypvt[-8].regval), yypvt[-0].lval, 
						  FUNCTION_LOG2 );
			  else
			  {
			      USER_ERROR( "Illegal operand in function unit instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 570:{
			  if( IS_FLOAT_REG(yypvt[-1].regval) )
			      make_function_unit( REG(yypvt[-1].regval), NULL_OPERAND, NULL_TRANSFER, yypvt[-0].lval, 
						  FUNCTION_SIN );
			  else
			  {
			      USER_ERROR( "Illegal operand in function unit instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 571:{
			  if( IS_FLOAT_REG(yypvt[-8].regval) && IS_FLOAT_REG(yypvt[-1].regval) )
			      make_function_unit( REG(yypvt[-1].regval), NULL_OPERAND, REG(yypvt[-8].regval), yypvt[-0].lval, FUNCTION_SIN );
			  else
			  {
			      USER_ERROR( "Illegal operand in function unit instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 572:{
			  if( IS_FLOAT_REG(yypvt[-1].regval) )
			     make_function_unit( REG(yypvt[-1].regval), NULL_OPERAND, NULL_TRANSFER, yypvt[-0].lval, 
						 FUNCTION_COS );
			  else
			  {
			      USER_ERROR( "Illegal operand in function unit instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 573:{
			  if( IS_FLOAT_REG(yypvt[-8].regval) && IS_FLOAT_REG(yypvt[-1].regval) )
			      make_function_unit( REG(yypvt[-1].regval), NULL_OPERAND, REG(yypvt[-8].regval), yypvt[-0].lval, FUNCTION_COS );
			  else
			  {
			      USER_ERROR( "Illegal operand in function unit instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 574:{
			  if( IS_FLOAT_REG(yypvt[-1].regval) )
			      make_function_unit( REG(yypvt[-1].regval), NULL_OPERAND, NULL_TRANSFER, yypvt[-0].lval, 
						  FUNCTION_ACT );
			  else
			  {
			      USER_ERROR( "Illegal operand in function unit instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 575:{
			  if( IS_FLOAT_REG(yypvt[-8].regval) && IS_FLOAT_REG(yypvt[-1].regval) )
			      make_function_unit( REG(yypvt[-1].regval), NULL_OPERAND, REG(yypvt[-8].regval), yypvt[-0].lval, FUNCTION_ACT );
			  else
			  {
			      USER_ERROR( "Illegal operand in function unit instruction." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 576:{
			  make_function_unit( NULL_OPERAND, NULL_OPERAND, NULL_TRANSFER, 
					      0L, FUNCTION_STEP );
		      } break;
case 577:{ yyval.lval = yypvt[-1].lval; } break;
case 578:{ yyval.lval = FUNCTION_PRECISION40; } break;
case 579:{
			  yyval.lval = yypvt[-3].lval | yypvt[-1].lval;
		      } break;
case 580:{
			  yyval.lval = yypvt[-3].lval | yypvt[-1].lval;
		      } break;
case 581:{
			  yyval.lval = yypvt[-1].lval;
		      } break;
case 582:{
			  yyval.lval = yypvt[-1].lval;
		      } break;
case 583:{
			  yyval.lval = FUNCTION_PRECISION40;
		      } break;
case 584:{ yyval.lval = FUNCTION_SINGLE_STEP; } break;
case 585:{ yyval.lval = FUNCTION_PRECISION20; } break;
case 586:{ yyval.lval = FUNCTION_PRECISION24; } break;
case 587:{ yyval.lval = FUNCTION_PRECISION32; } break;
case 588:{ yyval.lval = FUNCTION_PRECISION40; } break;
case 589:{
			  if( IS_REG_FILE(REG(yypvt[-2].regval)) )
			      make_transfer( REG(yypvt[-2].regval), yypvt[-0].lval, CUREG_TO_DREG );
			  else
			  {
			      USER_ERROR( "Illegal register for transfer." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 590:{
			 if( IS_REG_FILE(REG(yypvt[-0].regval)) )
			     make_transfer( REG(yypvt[-0].regval), yypvt[-2].lval, DREG_TO_CUREG );
			  else
			  {
			      USER_ERROR( "Illegal register for transfer." );
			      ilnode.error_occurred = ASM_ERROR;
			  }
		      } break;
case 591:{
			  yyval.lval = get_register_number( yypvt[-0].lval );
		      } break;
case 592:{
			  yyval.lval = get_register_number( yypvt[-0].lval );
		      } break;
case 593:{
			  yyval.lval = get_register_number( yypvt[-0].lval );
		      } break;
case 594:{
			  yyval.lval = get_register_number( yypvt[-0].lval );
		      } break;
case 595:{
			  yyval.lval = get_register_number( yypvt[-0].lval );
		      } break;
case 596:{
			  yyval.lval = get_register_number( yypvt[-0].lval );
		      } break;
case 597:{
			  yyval.lval = get_register_number( yypvt[-0].lval );
		      } break;
case 598:{
			  yyval.lval = get_register_number( yypvt[-0].lval );
		      } break;
case 610:{
			  yyval.regval.reg = get_register_number( yypvt[-0].lval );
			  yyval.regval.type = SCALAR_TYPE;
		      } break;
case 611:{
			  yyval.regval.reg = get_register_number( yypvt[-0].lval );
			  yyval.regval.type = FLOAT_TYPE;
		      } break;
case 612:{
			  yyval.regval.reg = get_register_number( yypvt[-0].lval );
			  yyval.regval.type = SCALAR_TYPE;
		      } break;
case 613:{
			  yyval.regval.reg = get_register_number( yypvt[-0].lval );
			  yyval.regval.type = SCALAR_TYPE;
		      } break;
case 614:{
			  yyval.regval.reg = get_register_number( yypvt[-0].lval );
			  yyval.regval.type = SCALAR_TYPE;
		      } break;
case 615:{
			  yyval.regval.reg = get_register_number( yypvt[-0].lval );
			  yyval.regval.type = SCALAR_TYPE;
		      } break;
case 616:{
			  yyval.regval.reg = get_register_number( yypvt[-0].lval );
			  yyval.regval.type = SCALAR_TYPE;
		      } break;
case 617:{
			  yyval.regval.reg = get_register_number( yypvt[-0].lval );
			  yyval.regval.type = SCALAR_TYPE;
		      } break;
case 618:{
			  yyval.regval.reg = get_register_number( yypvt[-0].lval );
			  yyval.regval.type = SCALAR_TYPE;
		      } break;
case 619:{
			  ilnode.cs = CS_ACAM;
		      } break;
case 620:{
			  ilnode.cs = CS_UPPER;
		      } break;
case 621:{
			  ilnode.cs = CS_LOWER;
		      } break;
case 622:{
			  yyval.regval.reg = get_register_number( yypvt[-0].lval );
			  yyval.regval.type = SCALAR_TYPE;
		      } break;
case 623:{
			  yyval.regval.reg = get_register_number( yypvt[-0].lval );
			  yyval.regval.type = SCALAR_TYPE;
		      } break;
case 624:{
			 if( yypvt[-2].expr.expr_type != EXPR_TYPE_INT || yypvt[-0].expr.expr_type != EXPR_TYPE_INT )
			 {
			     USER_ERROR( "Illegal bit field specifiers." );
			     ilnode.error_occurred = ASM_ERROR;
			 }

			 if( yypvt[-2].expr.value.int_val > 63 || yypvt[-0].expr.value.int_val > 63 )
			 {
			     USER_ERROR( "Bit field specifier is out of range." );
			     ilnode.error_occurred = ASM_ERROR;
			 }
	   
			 yyval.expr.value.int_val = ((yypvt[-0].expr.value.int_val & 0x3FL) << 6) | 
					     (yypvt[-2].expr.value.int_val & 0x3FL);
			 yyval.expr.expr_type = EXPR_TYPE_INT;
			 yyval.expr.sym_ptr = (SYMBOL *) NULL;
		      } break;
case 629:{
			  expression_add( &( yypvt[-2].expr ), &( yypvt[-0].expr ), &( yyval.expr ) );
		      } break;
case 630:{
			  expression_subtract( &( yypvt[-2].expr ), &( yypvt[-0].expr ), &( yyval.expr ) );
		      } break;
case 631:{
			  expression_multiply( &( yypvt[-2].expr ), &( yypvt[-0].expr ), &( yyval.expr ) );
		      } break;
case 632:{
			  expression_divide( &( yypvt[-2].expr ), &( yypvt[-0].expr ), &( yyval.expr ) );
		      } break;
case 633:{
			  expression_general( &( yypvt[-2].expr ), &( yypvt[-0].expr ), &( yyval.expr ), EXPR_OP_AND );
		      } break;
case 634:{
			  expression_general( &( yypvt[-2].expr ), &( yypvt[-0].expr ), &( yyval.expr ), EXPR_OP_OR );
		      } break;
case 635:{
			  expression_general( &( yypvt[-2].expr ), &( yypvt[-0].expr ), &( yyval.expr ), EXPR_OP_XOR );
		      } break;
case 636:{
			  expression_general( &( yypvt[-2].expr ), &( yypvt[-0].expr ), &( yyval.expr ), EXPR_OP_SHIFT_RIGHT );
		      } break;
case 637:{
			  expression_general( &( yypvt[-2].expr ), &( yypvt[-0].expr ), &( yyval.expr ), EXPR_OP_SHIFT_LEFT );
		      } break;
case 638:{
			  expression_general( &( yypvt[-2].expr ), &( yypvt[-0].expr ), &( yyval.expr ), EXPR_OP_MOD );
		      } break;
case 639:{
			  yyval.expr = yypvt[-1].expr;
		      } break;
case 640:{
			  if( !IS_SYM_PTR( (EXPR *) &(yypvt[-0].expr)) )
			  {
			      yyval.expr.expr_type = yypvt[-0].expr.expr_type;
			      yyval.expr.sym_ptr = (SYMBOL *) NULL;

			      if( yypvt[-0].expr.expr_type == EXPR_TYPE_INT )
				  yyval.expr.value.int_val = -yypvt[-0].expr.value.int_val;
			      else if( yypvt[-0].expr.expr_type == EXPR_TYPE_FLOAT )
				  yyval.expr.value.float_val = -yypvt[-0].expr.value.float_val;
			       
			  }
			  else
			  {
			      USER_ERROR( "Cannot negate a non-constant expression" );
			      yyval.expr.sym_ptr = (SYMBOL *) NULL;
			      yyval.expr.expr_type = EXPR_TYPE_UNDEFINED;
			      yyval.expr.value.float_val = 0.0;
			  }
		      } break;
case 641:{ yyval.expr = yypvt[-0].expr; } break;
case 642:{
			  if( IS_SYM_PTR( (EXPR *) &(yypvt[-0].expr)) )
			  {
			      USER_ERROR( "Cannot take the one's complement of a non-constant" );
			      yyval.expr.expr_type = EXPR_TYPE_UNDEFINED;
			      yyval.expr.value.float_val = 0.0;
			      yyval.expr.sym_ptr = (SYMBOL *) NULL;
			  }
			  else
			  {
			      if( IS_FLOAT( (EXPR *) &(yypvt[-0].expr)) )
			      {
				  USER_ERROR( "Cannot take the one's complement of a float" );
				  yyval.expr.expr_type = EXPR_TYPE_UNDEFINED;
				  yyval.expr.value.float_val = 0.0;
				  yyval.expr.sym_ptr = (SYMBOL *) NULL;
			      }
			      else
			      {
				  yyval.expr.expr_type = EXPR_TYPE_INT;
				  yyval.expr.value.int_val = ~ (yypvt[-0].expr.value.int_val);
				  yyval.expr.sym_ptr = (SYMBOL *) NULL;
			      }
			  }
		      } break;
case 643:{
			current_symbol = ADD_IDENTIFIER( last_identifier, 0L, 0L, STYPE_UNDEFINED, 0L);
			yyval.expr.expr_type = (short) BASIC_TYPE( current_symbol->type );
			if( yyval.expr.expr_type != STYPE_ABS )
			{
			  yyval.expr.expr_type = EXPR_TYPE_INT;
			  yyval.expr.sym_ptr = current_symbol;
			  yyval.expr.value.int_val = 0L;
			}
			else
			{
			  yyval.expr.expr_type = EXPR_TYPE_INT;
			  yyval.expr.value.int_val = current_symbol->value;
			  yyval.expr.sym_ptr = (SYMBOL *) NULL;
			}
		      } break;
case 644:{
			  yyval.expr.expr_type = EXPR_TYPE_INT;
			  yyval.expr.value.int_val = yypvt[-0].lval;
			  yyval.expr.sym_ptr = (SYMBOL *) NULL;
		      } break;
case 645:{
			if (yypvt[-0].dval >= 1.0) {
			    USER_ERROR( "absolute value of fract must be less than 1");
			} else {
			  yyval.expr.expr_type = EXPR_TYPE_INT;
			  yyval.expr.value.int_val = (long)(yypvt[-0].dval * 2147483648.0);
			  yyval.expr.sym_ptr = (SYMBOL *) NULL;
			}
		      } break;
case 646:{
			if (yypvt[-0].dval >= 1.0) {
			    USER_ERROR( "absolute value of fract must be less than 1");
			} else {
			  yyval.expr.expr_type = EXPR_TYPE_INT;
			  yyval.expr.value.int_val = (long)(-yypvt[-0].dval * 2147483648.0);
			  yyval.expr.sym_ptr = (SYMBOL *) NULL;
			}
		      } break;
case 647:{
			  yyval.expr.expr_type = EXPR_TYPE_FLOAT;
			  yyval.expr.value.float_val = yypvt[-0].dval;
			  yyval.expr.sym_ptr = (SYMBOL *) NULL;
		      } break;
case 648:{
			  yyval.expr.expr_type = EXPR_TYPE_HEX40;
			  yyval.expr.value.hex40_val[0] = yypvt[-0].hex40[0];
			  yyval.expr.value.hex40_val[1] = yypvt[-0].hex40[1];
			  yyval.expr.value.hex40_val[2] = yypvt[-0].hex40[2];
			  yyval.expr.value.hex40_val[3] = yypvt[-0].hex40[3];
			  yyval.expr.value.hex40_val[4] = yypvt[-0].hex40[4];
/*                          strncpy( $$.value.hex40_val, $1, DATA_SIZE );    */
			  yyval.expr.sym_ptr = (SYMBOL *) NULL;
		      } break;
case 649:{
			  if( yypvt[-0].expr.sym_ptr != (SYMBOL *) NULL )
			  {
			      yyval.expr.sym_ptr = (SYMBOL *) NULL;
			      yyval.expr.value.int_val = yypvt[-0].expr.sym_ptr->length;
			      yyval.expr.expr_type = EXPR_TYPE_INT;
			      ilnode.length = AFFIRMATIVE;
			      if (yypvt[-0].expr.sym_ptr->length == 0)
				USER_WARN("buffer is evaluated at zero length");
			  }
			  else
			  {
			      USER_ERROR( "Cannot take the length of a non-symbol." );
			      yyval.expr.expr_type = EXPR_TYPE_UNDEFINED;
			      yyval.expr.value.float_val = 0.0;
			      yyval.expr.sym_ptr = (SYMBOL *) NULL;
			  }                              
		      } break;
case 651:{
			  pc->value = newpc;
			  WRITE_INTERMEDIATE( &yylineno, 0, NEW_STATEMENT, NULL );
		      } break;
case 653:{
			  expression_process_initializers( &(yypvt[-0].expr) );
			  ++num_initializers; 
		      } break;
case 654:{
			  ilnode.compute.compute_type = COMPUTE_NULL;
			  ilnode.instruction_type = INSTRUCTION_TYPE27;
		      } break;
case 655:{
			  ilnode.compute.compute_type = COMPUTE_NULL;
			  ilnode.instruction_type = INSTRUCTION_TYPE28;
		      } break;
case 656:{
			  ilnode.pm_addr = yypvt[-3].expr;
			  ilnode.address_type = ADDRESS_DIRECT;
			  ilnode.cond = COND_TRUE;
			  ilnode.b = B_CALL;
			  ilnode.instruction_type = INSTRUCTION_TYPE29;
		      } break;
case 657:{
			  ilnode.address_type = ADDRESS_PC_RELATIVE;
			  ilnode.cond = COND_TRUE;
			  ilnode.instruction_type = INSTRUCTION_TYPE29;
		      } break;
case 658:{ 
			  ilnode.compute.compute_type = COMPUTE_NULL;
			  ilnode.instruction_type = INSTRUCTION_TYPE25A;
		      } break;
case 659:{
			  ilnode.oelse = 1;
			  if( !Z3 )
			      USER_WARN("Use of Z# ELSE clause without -ADSP21060 switch");
		      } break;
case 660:{
			  ilnode.oelse = 0;
		      } break;
case 661:{
			  ilnode.oelse = 0;
		      } break;
		}
		goto yystack;  /* stack new state and value */

	}
